{
  "topicId": "tech-1-4-1",
  "title": "アルゴリズムとデータ構造の基礎",
  "flashcards": [
    {
      "id": "fc-tech-1-4-1-001",
      "front": "アルゴリズムとは何ですか？",
      "back": "問題を解決するための手順や方法です。\n\n特徴:\n・有限の手順で終了\n・明確に定義されている\n・入力と出力が明確\n・効率性が重要\n\n例: ソート、探索、計算",
      "importance": 5
    },
    {
      "id": "fc-tech-1-4-1-002",
      "front": "配列とは何ですか？",
      "back": "同じ型のデータを連続したメモリ領域に格納するデータ構造です。\n\n特徴:\n・インデックスで要素にアクセス（O(1)）\n・サイズは固定（多くの言語で）\n・メモリ効率が良い\n\n例: int array[10];",
      "importance": 5
    },
    {
      "id": "fc-tech-1-4-1-003",
      "front": "リスト（線形リスト）とは何ですか？",
      "back": "データを順序付けて並べたデータ構造です。\n\n種類:\n・配列リスト: 配列で実装\n・連結リスト: ポインタで接続\n\n特徴:\n・動的にサイズ変更可能\n・要素の挿入・削除が容易",
      "importance": 5
    },
    {
      "id": "fc-tech-1-4-1-004",
      "front": "連結リスト（linked list）とは？",
      "back": "各要素がデータと次要素へのポインタを持つデータ構造です。\n\n構成:\n・ノード: データ + 次ノードへのポインタ\n・先頭ポインタ: リストの開始位置\n\n利点: 動的サイズ、挿入削除が高速\n欠点: ランダムアクセス不可",
      "importance": 5
    },
    {
      "id": "fc-tech-1-4-1-005",
      "front": "スタック（stack）とは何ですか？",
      "back": "後入れ先出し（LIFO: Last In First Out）のデータ構造です。\n\n操作:\n・push: データを追加\n・pop: データを取り出す\n・peek: 先頭を参照（取り出さない）\n\n例: 関数呼び出し、戻るボタン",
      "importance": 5
    },
    {
      "id": "fc-tech-1-4-1-006",
      "front": "キュー（queue）とは何ですか？",
      "back": "先入れ先出し（FIFO: First In First Out）のデータ構造です。\n\n操作:\n・enqueue: データを追加（末尾）\n・dequeue: データを取り出す（先頭）\n\n例: 待ち行列、プリンタスプール",
      "importance": 5
    },
    {
      "id": "fc-tech-1-4-1-007",
      "front": "木構造（tree）とは何ですか？",
      "back": "階層的な親子関係を持つデータ構造です。\n\n用語:\n・根（root）: 最上位のノード\n・葉（leaf）: 子を持たないノード\n・親・子・兄弟: 階層関係\n・深さ: 根からの距離\n・高さ: 最大深さ",
      "importance": 5
    },
    {
      "id": "fc-tech-1-4-1-008",
      "front": "2分木（binary tree）とは？",
      "back": "各ノードが最大2つの子を持つ木構造です。\n\n種類:\n・完全2分木: 最下層以外は満杯\n・満2分木: すべてのノードが0or2個の子\n・平衡2分木: 左右の高さの差が小さい",
      "importance": 5
    },
    {
      "id": "fc-tech-1-4-1-009",
      "front": "2分探索木（binary search tree）とは？",
      "back": "左の子 < 親 < 右の子の関係を持つ2分木です。\n\n特徴:\n・探索: O(log n)（平均）\n・挿入: O(log n)（平均）\n・削除: O(log n)（平均）\n\n※不均衡だとO(n)に劣化",
      "importance": 5
    },
    {
      "id": "fc-tech-1-4-1-010",
      "front": "ヒープ（heap）とは何ですか？",
      "back": "完全2分木で親≥子（最大ヒープ）または親≤子（最小ヒープ）の条件を満たすデータ構造です。\n\n用途:\n・優先度付きキュー\n・ヒープソート\n\n操作: O(log n)で挿入・削除",
      "importance": 4
    },
    {
      "id": "fc-tech-1-4-1-011",
      "front": "グラフ（graph）とは何ですか？",
      "back": "頂点（vertex）と辺（edge）で構成されるデータ構造です。\n\n種類:\n・無向グラフ: 辺に方向なし\n・有向グラフ: 辺に方向あり\n・重み付きグラフ: 辺に重みあり\n\n用途: ネットワーク、経路探索",
      "importance": 5
    },
    {
      "id": "fc-tech-1-4-1-012",
      "front": "ハッシュテーブル（hash table）とは？",
      "back": "キーから値を高速に検索できるデータ構造です。\n\nハッシュ関数でキーをインデックスに変換。\n\n特徴:\n・探索: O(1)（平均）\n・挿入: O(1)（平均）\n・削除: O(1)（平均）\n\n衝突処理が重要。",
      "importance": 5
    },
    {
      "id": "fc-tech-1-4-1-013",
      "front": "データ構造選択の基準は？",
      "back": "操作の頻度と計算量を考慮します。\n\n配列: ランダムアクセス多用\nリスト: 挿入削除多用\nスタック: LIFO操作\nキュー: FIFO操作\n木: 階層構造、探索\nハッシュ: 高速検索",
      "importance": 4
    },
    {
      "id": "fc-tech-1-4-1-014",
      "front": "再帰（recursion）とは何ですか？",
      "back": "関数が自分自身を呼び出す手法です。\n\n必要な要素:\n・基底条件（終了条件）\n・再帰呼び出し\n\n例: 階乗計算、木の探索\n\n利点: コードが簡潔\n欠点: スタック消費、速度",
      "importance": 5
    }
  ]
}
