{
  "topicId": "tech-2-3-5",
  "title": "仮想記憶管理",
  "questions": [
    {
      "id": "tech-2-3-5-q1",
      "type": "multiple_choice",
      "question": "仮想記憶の主な利点として正しくないものはどれですか？",
      "options": [
        "物理メモリより大きなプログラムを実行できる",
        "複数のプログラムを効率的に同時実行できる",
        "ハードディスクへのアクセスが不要になり、システムが高速化する",
        "プログラマはメモリ容量を気にせずプログラムを開発できる"
      ],
      "correctAnswer": 2,
      "explanation": "「ハードディスクへのアクセスが不要になり、システムが高速化する」は正しくありません。仮想記憶では、物理メモリに収まらないページはハードディスクに保存され、必要に応じてハードディスクからRAMに読み込まれます（ページイン）。ハードディスクへのアクセスは非常に遅い（RAMの100万倍遅い）ため、ページフォルトが頻繁に発生するとシステムは遅くなります。仮想記憶の利点は、①物理メモリより大きなプログラムを実行できる、②複数のプログラムを効率的に同時実行できる、③プログラマはメモリ容量を気にせずプログラムを開発できる（透過性）、です。仮想記憶は、メモリの抽象化と保護を提供しますが、ハードディスクへのアクセスが発生するため、全てのメモリアクセスがRAM内で完結する場合より遅くなります。ページフォルト率を低く保つことが、仮想記憶の性能向上の鍵です。"
    },
    {
      "id": "tech-2-3-5-q2",
      "type": "multiple_choice",
      "question": "ページング方式において、1ページのサイズが4KB、プログラムのサイズが20KBの場合、プログラムは何ページに分割されますか？",
      "options": [
        "4ページ",
        "5ページ",
        "6ページ",
        "8ページ"
      ],
      "correctAnswer": 1,
      "explanation": "「5ページ」が正しいです。ページ数 = プログラムのサイズ ÷ 1ページのサイズ = 20KB ÷ 4KB = 5ページです。プログラムは、ページ0（0～4KB）、ページ1（4KB～8KB）、ページ2（8KB～12KB）、ページ3（12KB～16KB）、ページ4（16KB～20KB）の5ページに分割されます。ページング方式では、プログラムを固定サイズの小さな単位（ページ）に分割し、各ページを物理メモリのページフレームまたはハードディスクに配置します。1ページのサイズは、一般的に4KB（4,096バイト）です。ページサイズが小さいと、①ページ数が増える、②ページテーブルのサイズが大きくなる、③内部フラグメンテーションが少ない、という特徴があります。ページサイズが大きいと、①ページ数が減る、②ページテーブルのサイズが小さくなる、③内部フラグメンテーションが多い、という特徴があります。"
    },
    {
      "id": "tech-2-3-5-q3",
      "type": "multiple_choice",
      "question": "ページフォルトの説明として正しいものはどれですか？",
      "options": [
        "プログラムがアクセスしようとしたページが物理メモリに存在しない場合に発生するエラーで、プログラムが異常終了する",
        "プログラムがアクセスしようとしたページが物理メモリに存在しない場合に発生する例外で、OSが自動的にページをハードディスクからRAMに読み込む",
        "物理メモリが不足している場合に発生するエラーで、新しいプログラムを起動できなくなる",
        "ページテーブルが破損している場合に発生するエラーで、システムが再起動する"
      ],
      "correctAnswer": 1,
      "explanation": "「プログラムがアクセスしようとしたページが物理メモリに存在しない場合に発生する例外で、OSが自動的にページをハードディスクからRAMに読み込む」が正しいです。ページフォルト（Page Fault）は、仮想記憶では正常な動作で、プログラムが異常終了することはありません。ページフォルトが発生すると、OSは以下の処理を実行します。①必要なページをハードディスクから物理メモリに読み込む（ページイン）、②もし物理メモリが満杯の場合、ページ置き換えアルゴリズム（LRU）で1つのページを選び、ハードディスクに退避（ページアウト）してスペースを空ける、③ページテーブルを更新、④プログラムの実行を再開。ページフォルトの処理には、ハードディスクへのアクセスが必要なため、数ミリ秒～数十ミリ秒かかります。ページフォルトが頻繁に発生するとシステムが遅くなります（スラッシング）。選択肢①③④は間違っています。"
    },
    {
      "id": "tech-2-3-5-q4",
      "type": "multiple_choice",
      "question": "次のページ置き換えアルゴリズムのうち、「最も長い間使われていないページを置き換える」アルゴリズムはどれですか？",
      "options": [
        "FIFO（First In First Out）",
        "LRU（Least Recently Used）",
        "LFU（Least Frequently Used）",
        "Clock アルゴリズム"
      ],
      "correctAnswer": 1,
      "explanation": "「LRU（Least Recently Used）」が正しいです。LRUは、最も長い間使われていないページを置き換えるアルゴリズムです。LRUは、時間的局所性（最近アクセスされたメモリは、近い将来も再びアクセスされる可能性が高い）を活用し、効率的にページを置き換えます。LRUの利点は、よく使われるページは残るため、ページフォルト率が低いことです。欠点は、実装が複雑で、各ページの最終アクセス時刻を記録する必要があることです。選択肢①FIFO（First In First Out）は、最も古くRAMに読み込まれたページを置き換えます。③LFU（Least Frequently Used）は、最も使用頻度が低いページを置き換えます。④Clock アルゴリズムは、LRUを近似したアルゴリズムで、実装が簡単です。現在のOSでは、LRUまたはLRUに近いアルゴリズム（Clock アルゴリズム）が広く使われています。"
    },
    {
      "id": "tech-2-3-5-q5",
      "type": "multiple_choice",
      "question": "32ビットシステムで、1ページのサイズが4KB（2^12バイト）の場合、仮想アドレス0x00123456のページ番号（上位ビット）はいくつですか？",
      "options": [
        "0x123",
        "0x456",
        "0x001",
        "0x234"
      ],
      "correctAnswer": 0,
      "explanation": "「0x123」が正しいです。32ビットシステムで、1ページのサイズが4KB = 2^12バイトの場合、仮想アドレスは以下のように分割されます。上位20ビット（ページ番号） + 下位12ビット（ページ内オフセット）= 32ビット。仮想アドレス0x00123456を2進数に変換すると、0000 0000 0001 0010 0011 0100 0101 0110です。ページ番号は上位20ビット = 0000 0000 0001 0010 0011（16進数で0x123）です。ページ内オフセットは下位12ビット = 0100 0101 0110（16進数で0x456 = 1110バイト）です。OSは、ページテーブルを使って、ページ番号0x123に対応する物理アドレス（ページフレーム番号）を調べ、物理アドレスを計算します。選択肢②0x456はページ内オフセット、③④は間違っています。アドレス変換は、CPUのMMU（Memory Management Unit）というハードウェアが自動的に実行します。"
    },
    {
      "id": "tech-2-3-5-q6",
      "type": "multiple_choice",
      "question": "TLB（Translation Lookaside Buffer）の説明として正しいものはどれですか？",
      "options": [
        "ハードディスクからRAMにページを読み込む際に使用される一時的なバッファ",
        "最近使われたページテーブルのエントリをキャッシュするCPUのハードウェアで、アドレス変換を高速化する",
        "ページ置き換えアルゴリズムで使用される、ページの使用履歴を記録するデータ構造",
        "仮想アドレスと物理アドレスの対応を記録した表（ページテーブル）の別名"
      ],
      "correctAnswer": 1,
      "explanation": "「最近使われたページテーブルのエントリをキャッシュするCPUのハードウェアで、アドレス変換を高速化する」が正しいです。TLB（Translation Lookaside Buffer）は、CPUのキャッシュの一種で、最近使われたページテーブルのエントリ（仮想アドレス→物理アドレスの対応）を保存します。TLBヒット（キャッシュにエントリがある）の場合、ページテーブルへのアクセスなしで、直接物理アドレスを取得できます（所要時間: 数ナノ秒、確率: 90%以上）。TLBミス（キャッシュにエントリがない）の場合、ページテーブル（RAM）にアクセスして物理アドレスを取得します（所要時間: 数十ナノ秒、確率: 10%未満）。TLBにより、アドレス変換を大幅に高速化できます（TLBなしだと全てのメモリアクセスでページテーブルへのアクセスが必要 → 2倍遅い）。選択肢①③④は間違っています。"
    },
    {
      "id": "tech-2-3-5-q7",
      "type": "multiple_choice",
      "question": "スラッシング（Thrashing）の症状として正しくないものはどれですか？",
      "options": [
        "システムが非常に遅く、マウスのクリックに数秒～数十秒かかる",
        "ハードディスクのアクセスランプが常に点灯している",
        "CPU使用率が100%に達し、CPUが常にフル稼働している",
        "メモリ使用率が100%に達している"
      ],
      "correctAnswer": 2,
      "explanation": "「CPU使用率が100%に達し、CPUが常にフル稼働している」は正しくありません。スラッシング（Thrashing）が発生すると、CPUはページフォルト処理（ハードディスクへのアクセス）を待つため、アイドル状態（待機状態）になり、CPU使用率は低下します（例: 10%）。スラッシングの症状は、①システムが非常に遅い（マウスのクリックに数秒～数十秒かかる）、②ハードディスクのアクセスランプが常に点灯（ページの読み込み・退避が頻繁に発生）、③CPU使用率が低い（CPUがページフォルト処理を待っている）、④メモリ使用率が100%、です。スラッシングの原因は、物理メモリに対して実行するプログラムが多すぎることです。対策は、①同時に実行するプログラムを減らす、②物理メモリを増設する、③ページ置き換えアルゴリズムを改善する（LRU）、④ワーキングセットモデルを使用する、です。"
    },
    {
      "id": "tech-2-3-5-q8",
      "type": "multiple_choice",
      "question": "ワーキングセット（Working Set）の説明として正しいものはどれですか？",
      "options": [
        "プログラムが一定期間内に頻繁にアクセスするページの集合で、プログラムの実行に必要な最小限のページ数",
        "物理メモリに配置されている全てのページの集合",
        "ページフォルトが発生した際に、ハードディスクから読み込まれるページの集合",
        "プログラムが使用する仮想メモリ空間全体"
      ],
      "correctAnswer": 0,
      "explanation": "「プログラムが一定期間内に頻繁にアクセスするページの集合で、プログラムの実行に必要な最小限のページ数」が正しいです。ワーキングセット（Working Set）は、プログラムの実行に必要な最小限のページ数を表します。OSは、各プログラムのワーキングセットを計算し、ワーキングセット全体が物理メモリに収まるように、実行するプログラム数を調整します（プロセス数の制御）。例えば、物理メモリが4GBで、各プログラムのワーキングセットが500MBの場合、OSは最大8個のプログラムしか同時に実行しません（8 × 500MB = 4GB）。ワーキングセットモデルにより、スラッシングを防ぎ、システムの性能を維持できます。ワーキングセットは、局所性の原理（時間的局所性、空間的局所性）に基づいて計算されます。選択肢②③④は間違っています。ワーキングセットモデルは、Windows、Linuxなどの現代のOSで使用されています。"
    },
    {
      "id": "tech-2-3-5-q9",
      "type": "multiple_choice",
      "question": "局所性の原理のうち、「最近アクセスされたメモリは、近い将来も再びアクセスされる可能性が高い」という性質を何と言いますか？",
      "options": [
        "時間的局所性（Temporal Locality）",
        "空間的局所性（Spatial Locality）",
        "論理的局所性（Logical Locality）",
        "物理的局所性（Physical Locality）"
      ],
      "correctAnswer": 0,
      "explanation": "「時間的局所性（Temporal Locality）」が正しいです。時間的局所性とは、最近アクセスされたメモリは、近い将来も再びアクセスされる可能性が高いという性質です。例えば、ループ内の変数、関数のローカル変数は、繰り返しアクセスされます。時間的局所性により、LRU（Least Recently Used）アルゴリズムが効果的に機能します（最も長い間使われていないページを置き換える）。選択肢②空間的局所性（Spatial Locality）は、あるメモリ領域がアクセスされると、その近くのメモリ領域もアクセスされる可能性が高いという性質です（例: 配列の要素）。空間的局所性により、ページング方式が効果的に機能します（1ページ = 4KB、近くのアドレスは同じページ内）。選択肢③④は存在しない用語です。局所性の原理により、仮想記憶は実用的な性能を達成しています（ページフォルト率を低く保てる）。"
    },
    {
      "id": "tech-2-3-5-q10",
      "type": "multiple_choice",
      "question": "セグメント方式の説明として正しいものはどれですか？",
      "options": [
        "プログラムを固定サイズの小さな単位（ページ）に分割して管理する方式",
        "プログラムを論理的な単位（コード、データ、スタック）に分割して管理する方式で、セグメントは可変サイズ",
        "プログラムを複数のモジュールに分割し、必要なモジュールだけを順次メモリに読み込む方式",
        "プログラム全体をハードディスクに退避し、メモリを空ける方式"
      ],
      "correctAnswer": 1,
      "explanation": "「プログラムを論理的な単位（コード、データ、スタック）に分割して管理する方式で、セグメントは可変サイズ」が正しいです。セグメント方式（Segmentation）は、プログラムの論理構造に応じて分割します（例: コードセグメント、データセグメント、スタックセグメント）。各セグメントは可変サイズで、セグメントテーブルを使って管理されます。セグメント方式の利点は、①プログラムの論理構造を反映できる（モジュール化）、②セグメント単位でアクセス制御ができる（例: コードセグメントは読み取り専用）、です。欠点は、①外部フラグメンテーションが発生する（セグメントは可変サイズ）、②実装が複雑、です。選択肢①はページング方式、③はオーバーレイ方式、④はスワッピング方式の説明です。現在のOSでは、ページング方式が主流で、セグメント方式はほとんど使われていません。一部のOSでは、ページング方式とセグメント方式を組み合わせた方式（セグメントページング方式）が使われています。"
    }
  ]
}
