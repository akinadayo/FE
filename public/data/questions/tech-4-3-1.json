{
  "topicId": "tech-4-3-1",
  "title": "アルゴリズムの基礎",
  "questions": [
    {
      "id": "tech-4-3-1-q1",
      "type": "multiple_choice",
      "question": "アルゴリズムが満たすべき条件として、正しくないものはどれですか？",
      "options": [
        "0個以上の入力がある",
        "1個以上の出力がある",
        "各手順が明確で曖昧さがない",
        "無限の手順で終了してもよい"
      ],
      "correctAnswer": 3,
      "explanation": "「無限の手順で終了してもよい」が誤りです。アルゴリズムが満たすべき5つの条件は、①入力：0個以上の入力がある、②出力：1個以上の出力がある、③明確性：各手順が明確で曖昧さがない、④有限性：有限の手順で終了する、⑤有効性：各手順が実行可能である、です。選択肢④「無限の手順で終了してもよい」は、条件④「有限性」に反します。アルゴリズムは、有限の手順で必ず終了する必要があります。無限ループ（終わらない処理）はアルゴリズムの条件を満たしません。例えば、「while (true) 処理」のように、終了条件がない繰り返しは、アルゴリズムとして不適切です。選択肢①②③は、アルゴリズムの条件を正しく説明しています。なお、選択肢①「0個以上」は、入力がない場合（例：現在時刻を出力するアルゴリズム）も許容することを意味します。"
    },
    {
      "id": "tech-4-3-1-q2",
      "type": "multiple_choice",
      "question": "フローチャートの記号において、「条件分岐（Yes/No）」を表す記号はどれですか？",
      "options": [
        "楕円（○）",
        "長方形（□）",
        "ひし形（◇）",
        "平行四辺形（▱）"
      ],
      "correctAnswer": 2,
      "explanation": "「ひし形（◇）」が正しいです。フローチャートでは、ひし形は**判断記号**として使用され、条件分岐（Yes/No）を表します。ひし形の中に条件（例：A > B?、カウンタ < 10?）を記述し、ひし形から2本以上の流れ線が出ます（通常はYesとNo）。例えば、「点数 >= 60?」という条件を判断し、Yesの場合は「合格」、Noの場合は「不合格」という処理に分岐します。選択肢①楕円（○）は端子記号で、処理の開始・終了を表します。選択肢②長方形（□）は処理記号で、計算、代入などの処理を表します（例：合計 ← 合計 + 値）。選択肢④平行四辺形（▱）は入出力記号で、データの入力・出力を表します（例：Aを入力、結果を出力）。フローチャートを読み解く際は、各記号の意味を正確に理解することが重要です。"
    },
    {
      "id": "tech-4-3-1-q3",
      "type": "multiple_choice",
      "question": "構造化プログラミングの3つの基本制御構造に含まれないものはどれですか？",
      "options": [
        "順次構造",
        "選択構造",
        "繰返し構造",
        "並列構造"
      ],
      "correctAnswer": 3,
      "explanation": "「並列構造」が含まれません。構造化プログラミングの3つの基本制御構造は、①順次構造（Sequence）：処理を順番に実行、②選択構造（Selection、分岐）：条件によって処理を分岐（if-else文）、③繰返し構造（Iteration、反復）：条件を満たす間、処理を繰り返す（while文、for文）、です。すべてのプログラムは、これら3つの制御構造の組み合わせで表現できるというのが、構造化プログラミングの基本原理です。選択肢④「並列構造」は、3つの基本制御構造には含まれません。並列処理（複数の処理を同時に実行）は、より高度なプログラミング技法であり、基本制御構造とは別の概念です。基本情報技術者試験では、3つの基本制御構造を正確に理解し、擬似言語やフローチャートで表現できることが求められます。"
    },
    {
      "id": "tech-4-3-1-q4",
      "type": "multiple_choice",
      "question": "次の擬似言語で、変数「合計」の最終値はいくつですか？\n\n```\n合計 ← 0\nfor (i ← 1, 5, 1)\n  合計 ← 合計 + i * 2\nendfor\n```",
      "options": [
        "15",
        "20",
        "30",
        "55"
      ],
      "correctAnswer": 2,
      "explanation": "「30」が正しいです。このアルゴリズムは、1から5までの各数値を2倍して合計する処理です。\n\n【処理の流れ】\n初期状態：合計=0\n\ni=1：合計=0+(1×2)=0+2=2\ni=2：合計=2+(2×2)=2+4=6\ni=3：合計=6+(3×2)=6+6=12\ni=4：合計=12+(4×2)=12+8=20\ni=5：合計=20+(5×2)=20+10=30\n\n最終値：合計=30\n\nfor文の構文は「for (変数 ← 初期値, 終了値, 増分)」で、この場合、iは1から5まで1ずつ増加します（5回繰り返す）。各ループで「合計 ← 合計 + i * 2」が実行され、i×2を合計に加算します。選択肢①15は、1+2+3+4+5の結果（i×2を忘れた場合）、選択肢④55は、1+2+3+...+10の結果（ループ回数を間違えた場合）です。試験では、変数の値を1ステップずつ追跡する練習が重要です。"
    },
    {
      "id": "tech-4-3-1-q5",
      "type": "multiple_choice",
      "question": "次の擬似言語で、変数「カウント」の最終値はいくつですか？\n\n```\n配列A = [15, 28, 33, 42, 19]\nカウント ← 0\nfor (i ← 1, 5, 1)\n  if (A[i] >= 30)\n    カウント ← カウント + 1\n  endif\nendfor\n```",
      "options": [
        "1",
        "2",
        "3",
        "5"
      ],
      "correctAnswer": 1,
      "explanation": "「2」が正しいです。このアルゴリズムは、配列Aの要素のうち、30以上の値の個数を数える処理です。\n\n【処理の流れ】\n配列A = [15, 28, 33, 42, 19]\n初期状態：カウント=0\n\ni=1：A[1]=15 >= 30（偽）→ カウント=0（変更なし）\ni=2：A[2]=28 >= 30（偽）→ カウント=0（変更なし）\ni=3：A[3]=33 >= 30（真）→ カウント=0+1=1\ni=4：A[4]=42 >= 30（真）→ カウント=1+1=2\ni=5：A[5]=19 >= 30（偽）→ カウント=2（変更なし）\n\n最終値：カウント=2\n\n配列Aの要素のうち、30以上なのは33と42の2個です。このような条件付きカウントアルゴリズムでは、①カウンタの初期値を0に設定、②if文で条件をチェック、③条件を満たす場合のみカウンタを増やす、という手順が基本パターンです。試験では、配列の各要素を正確に確認し、条件を満たすかどうかを判定する必要があります。"
    },
    {
      "id": "tech-4-3-1-q6",
      "type": "multiple_choice",
      "question": "次の擬似言語で、変数「最大値」の最終値はいくつですか？\n\n```\n配列A = [25, 18, 47, 32, 41]\n最大値 ← A[1]\nfor (i ← 2, 5, 1)\n  if (A[i] > 最大値)\n    最大値 ← A[i]\n  endif\nendfor\n```",
      "options": [
        "25",
        "32",
        "41",
        "47"
      ],
      "correctAnswer": 3,
      "explanation": "「47」が正しいです。このアルゴリズムは、配列Aの要素の中から最大値を求める処理です。\n\n【処理の流れ】\n配列A = [25, 18, 47, 32, 41]\n初期状態：最大値=A[1]=25\n\ni=2：A[2]=18 > 25（偽）→ 最大値=25（変更なし）\ni=3：A[3]=47 > 25（真）→ 最大値=47\ni=4：A[4]=32 > 47（偽）→ 最大値=47（変更なし）\ni=5：A[5]=41 > 47（偽）→ 最大値=47（変更なし）\n\n最終値：最大値=47\n\n最大値探索アルゴリズムのポイントは、①最大値の初期値を配列の1番目の要素に設定、②2番目以降の要素と比較、③より大きい値が見つかれば更新、です。配列Aの要素を順番に確認すると、25→18（更新なし）→47（更新）→32（更新なし）→41（更新なし）となり、最終的に最大値=47になります。選択肢①25は初期値、選択肢②③はそれぞれA[4]、A[5]の値ですが、A[3]=47が最大です。試験では、各ループでの比較結果と、最大値の更新タイミングを正確に追跡する必要があります。"
    },
    {
      "id": "tech-4-3-1-q7",
      "type": "multiple_choice",
      "question": "次の擬似言語で、変数「平均」の最終値はいくつですか？\n\n```\n配列A = [80, 70, 90, 60]\n合計 ← 0\nfor (i ← 1, 4, 1)\n  合計 ← 合計 + A[i]\nendfor\n平均 ← 合計 / 4\n```",
      "options": [
        "70",
        "75",
        "80",
        "300"
      ],
      "correctAnswer": 1,
      "explanation": "「75」が正しいです。このアルゴリズムは、配列Aの要素の平均値を求める処理です。\n\n【処理の流れ】\n配列A = [80, 70, 90, 60]\n初期状態：合計=0\n\n①まず合計を求める（for文）\ni=1：合計=0+80=80\ni=2：合計=80+70=150\ni=3：合計=150+90=240\ni=4：合計=240+60=300\n\n②平均を計算\n平均=300÷4=75\n\n最終値：平均=75\n\n平均値計算アルゴリズムのポイントは、①まず全ての値を合計する（for文で累積）、②合計を個数で割る、の2ステップです。配列Aの要素の合計は80+70+90+60=300、個数は4なので、平均=300÷4=75になります。選択肢①70はA[2]の値、選択肢③80はA[1]の値、選択肢④300は合計値です。試験では、合計と平均を混同しないように注意が必要です。平均は「合計÷個数」であることを確認しましょう。"
    },
    {
      "id": "tech-4-3-1-q8",
      "type": "multiple_choice",
      "question": "次の擬似言語で、2つの変数AとBの値を入れ替える処理として、正しいものはどれですか？（初期状態：A=10、B=20）",
      "options": [
        "A ← B\nB ← A",
        "temp ← A\nA ← B\nB ← temp",
        "A ← A + B\nB ← A - B\nA ← A - B",
        "選択肢②と③の両方が正しい"
      ],
      "correctAnswer": 3,
      "explanation": "「選択肢②と③の両方が正しい」です。2つの変数の値を入れ替える方法は、複数あります。\n\n【選択肢①の誤り】\nA ← B  → A=20になる\nB ← A  → B=20になる（Aはすでに20）\n結果：A=20、B=20（Aの元の値10が失われる）\n\n【選択肢②（作業変数を使う方法）】\ntemp ← A   → temp=10（Aの値を退避）\nA ← B      → A=20\nB ← temp   → B=10\n結果：A=20、B=10（正しい）\n\n【選択肢③（算術演算を使う方法）】\nA ← A + B  → A=10+20=30\nB ← A - B  → B=30-20=10（元のAの値）\nA ← A - B  → A=30-10=20（元のBの値）\n結果：A=20、B=10（正しい）\n\n選択肢②は最も一般的な方法で、作業変数（temp）を使います。選択肢③は、作業変数を使わずに算術演算だけで入れ替える巧妙な方法です。どちらも正しい入れ替え方法ですが、試験では選択肢②（作業変数を使う方法）が基本パターンとして出題されることが多いです。"
    },
    {
      "id": "tech-4-3-1-q9",
      "type": "multiple_choice",
      "question": "次のフローチャートで、「カウンタ < 10?」という判断を10回繰り返すための、カウンタの初期値と増分の組み合わせとして、正しいものはどれですか？\n\n```\n開始 → カウンタ ← 初期値 → カウンタ < 10? → Yes → 処理 → カウンタ ← カウンタ + 増分 → カウンタ < 10?に戻る → No → 終了\n```",
      "options": [
        "初期値=0、増分=1",
        "初期値=1、増分=1",
        "初期値=0、増分=2",
        "初期値=1、増分=2"
      ],
      "correctAnswer": 0,
      "explanation": "「初期値=0、増分=1」が正しいです。このフローチャートは、カウンタが10未満の間、処理を繰り返すループです。\n\n【選択肢①：初期値=0、増分=1】\nカウンタ=0 < 10（真）→ 処理 → カウンタ=1\nカウンタ=1 < 10（真）→ 処理 → カウンタ=2\n...\nカウンタ=9 < 10（真）→ 処理 → カウンタ=10\nカウンタ=10 < 10（偽）→ ループ終了\n繰り返し回数：10回（カウンタ=0, 1, 2, ..., 9）\n\n【選択肢②：初期値=1、増分=1】\nカウンタ=1, 2, ..., 9 → 9回繰り返し\n\n【選択肢③：初期値=0、増分=2】\nカウンタ=0, 2, 4, 6, 8 → 5回繰り返し\n\n【選択肢④：初期値=1、増分=2】\nカウンタ=1, 3, 5, 7, 9 → 5回繰り返し\n\n条件が「カウンタ < 10」の場合、10回繰り返すには、カウンタが0から9まで（10個の値）を取る必要があります。そのためには、初期値=0、増分=1が正しい組み合わせです。試験では、ループの回数を正確に数える練習が重要です。"
    },
    {
      "id": "tech-4-3-1-q10",
      "type": "multiple_choice",
      "question": "次の擬似言語で、while文とfor文のループ回数の組み合わせとして、正しいものはどれですか？\n\n【while文】\n```\nカウンタ ← 5\nwhile (カウンタ > 0)\n  処理\n  カウンタ ← カウンタ - 2\nendwhile\n```\n\n【for文】\n```\nfor (i ← 1, 10, 2)\n  処理\nendfor\n```",
      "options": [
        "while文=2回、for文=5回",
        "while文=3回、for文=5回",
        "while文=2回、for文=10回",
        "while文=3回、for文=10回"
      ],
      "correctAnswer": 1,
      "explanation": "「while文=3回、for文=5回」が正しいです。\n\n【while文の処理】\n初期状態：カウンタ=5\n\n1周目：カウンタ=5 > 0（真）→ 処理 → カウンタ=5-2=3\n2周目：カウンタ=3 > 0（真）→ 処理 → カウンタ=3-2=1\n3周目：カウンタ=1 > 0（真）→ 処理 → カウンタ=1-2=-1\n4周目：カウンタ=-1 > 0（偽）→ ループ終了\n\n繰り返し回数：3回\n\n【for文の処理】\nfor (i ← 1, 10, 2) は、iが1から10まで、2ずつ増加する繰り返しです。\n\ni=1（1 <= 10、真）→ 処理 → i=3\ni=3（3 <= 10、真）→ 処理 → i=5\ni=5（5 <= 10、真）→ 処理 → i=7\ni=7（7 <= 10、真）→ 処理 → i=9\ni=9（9 <= 10、真）→ 処理 → i=11\ni=11（11 <= 10、偽）→ ループ終了\n\n繰り返し回数：5回（i=1, 3, 5, 7, 9）\n\nwhile文では、カウンタが5→3→1→-1と変化し、3回繰り返します。for文では、iが1→3→5→7→9と変化し、5回繰り返します。試験では、ループの条件（>、>=、<、<=）と、変数の増減（+、-）を正確に確認することが重要です。"
    }
  ]
}
