{
  "topicId": "tech-4-3-2",
  "title": "データ構造",
  "questions": [
    {
      "id": "tech-4-3-2-q1",
      "type": "multiple_choice",
      "question": "配列と連結リストに関する記述のうち、正しいものはどれですか？",
      "options": [
        "配列は可変サイズで、要素の追加・削除が容易である",
        "連結リストは、n番目の要素にO(1)でアクセスできる",
        "配列は、添え字を使ってO(1)で要素にアクセスできる",
        "連結リストは、ポインタを使用しないため、配列よりメモリ効率が良い"
      ],
      "correctAnswer": 2,
      "explanation": "「配列は、添え字を使ってO(1)で要素にアクセスできる」が正しいです。配列は、メモリ上に連続して配置されており、添え字（インデックス）を使って直接アクセスできます（ランダムアクセス）。例えば、成績[2]は、配列の先頭アドレス + (2 × 要素のサイズ) で計算でき、O(1)でアクセスできます。選択肢①配列は固定サイズで、要素の追加・削除は困難です（O(n)）。選択肢②連結リストは、先頭から順番にアクセスするため、n番目の要素にアクセスするにはO(n)かかります。選択肢④連結リストは、各ノードがポインタ（次のノードへの参照）を持つため、配列よりメモリ使用量が多いです。配列と連結リストの使い分けとして、①ランダムアクセスが多い場合→配列、②挿入・削除が多い場合→連結リストを選択します。"
    },
    {
      "id": "tech-4-3-2-q2",
      "type": "multiple_choice",
      "question": "スタック（Stack）を使って実現できる処理はどれですか？",
      "options": [
        "印刷ジョブを先に送られた順番に処理する",
        "関数呼び出しの管理（コールスタック）",
        "タスクを優先度順に処理する",
        "データベースのインデックスを高速に検索する"
      ],
      "correctAnswer": 1,
      "explanation": "「関数呼び出しの管理（コールスタック）」が正しいです。スタックは、後入れ先出し（LIFO: Last In First Out）のデータ構造で、最後に入れたデータが最初に取り出されます。プログラムで関数を呼び出すとき、関数の戻り先のアドレス、ローカル変数などをスタックに積みます（コールスタック）。関数が終了すると、スタックから戻り先を取り出し、呼び出し元に戻ります。例えば、funcA → funcB → funcCの順で呼び出すと、スタックは[funcA, funcB, funcC]となり、funcCが終了するとpopして[funcA, funcB]に戻ります。選択肢①印刷ジョブを順番に処理するのは、キュー（FIFO）です。選択肢③タスクを優先度順に処理するのは、ヒープ（優先度付きキュー）です。選択肢④データベースのインデックスは、2分探索木やハッシュテーブルで実現されます。スタックの応用例として、関数呼び出し、括弧の対応チェック、逆ポーランド記法の計算、DFS（深さ優先探索）があります。"
    },
    {
      "id": "tech-4-3-2-q3",
      "type": "multiple_choice",
      "question": "次のプログラムで、スタックの状態はどうなりますか？\n\n```\nスタック S = []（空）\nS.push(10)\nS.push(20)\nS.push(30)\nS.pop()\nS.push(40)\n```",
      "options": [
        "[10, 20, 40]",
        "[10, 20, 30, 40]",
        "[10, 40]",
        "[40, 20, 10]"
      ],
      "correctAnswer": 0,
      "explanation": "「[10, 20, 40]」が正しいです。スタックは、後入れ先出し（LIFO）のデータ構造で、pushは末尾に追加、popは末尾から削除します。プログラムの実行を追うと、①S.push(10) → S = [10]、②S.push(20) → S = [10, 20]、③S.push(30) → S = [10, 20, 30]、④S.pop() → 末尾（30）を削除 → S = [10, 20]、⑤S.push(40) → S = [10, 20, 40]、となります。スタックでは、常に末尾（トップ）から追加・削除されます。選択肢②は、popが実行されていないため間違いです。選択肢③は、20が削除されていますが、スタックは末尾から削除するため間違いです。選択肢④は、スタックの順序が逆になっており間違いです（スタックは配列のように先頭から表現されます）。"
    },
    {
      "id": "tech-4-3-2-q4",
      "type": "multiple_choice",
      "question": "キュー（Queue）を使って印刷ジョブを管理しています。次の順番で印刷ジョブが送られました。\n\n①ジョブA\n②ジョブB\n③ジョブC\n\nプリンタが1つのジョブを処理した後、新しいジョブDが送られました。この時点で、次に処理されるジョブはどれですか？",
      "options": [
        "ジョブA",
        "ジョブB",
        "ジョブC",
        "ジョブD"
      ],
      "correctAnswer": 1,
      "explanation": "「ジョブB」が正しいです。キューは、先入れ先出し（FIFO: First In First Out）のデータ構造で、最初に入れたデータが最初に取り出されます。印刷ジョブの管理では、①ジョブA、B、Cが送られる → キュー: [A, B, C]、②プリンタがジョブAを処理 → dequeue → キュー: [B, C]、③ジョブDが送られる → enqueue → キュー: [B, C, D]、となります。次に処理されるジョブは、キューの先頭にあるジョブB（最初に入れられたもの）です。キューでは、常に先頭（フロント）から取り出され、末尾（リア）に追加されます。選択肢①ジョブAは既に処理されています。選択肢③ジョブCはジョブBの後に処理されます。選択肢④ジョブDは最後に追加されたため、最後に処理されます。スタック（LIFO）だと、最後に追加されたジョブDが先に処理されてしまいます（公平ではない）。"
    },
    {
      "id": "tech-4-3-2-q5",
      "type": "multiple_choice",
      "question": "2分探索木（Binary Search Tree）に、次の順番で数値を挿入します。[50, 30, 70, 20, 40]。この木を中順走査（In-order）すると、どのような順序で数値が取得されますか？",
      "options": [
        "50, 30, 20, 40, 70",
        "20, 30, 40, 50, 70",
        "70, 50, 40, 30, 20",
        "50, 70, 30, 40, 20"
      ],
      "correctAnswer": 1,
      "explanation": "「20, 30, 40, 50, 70」が正しいです。2分探索木は、各ノードの左の子孫 < そのノード < 右の子孫の性質を満たす2分木です。数値を挿入すると、①50を根に挿入、②30は50より小さいので左に挿入、③70は50より大きいので右に挿入、④20は50より小さく30より小さいので30の左に挿入、⑤40は50より小さく30より大きいので30の右に挿入、となります。木の構造は、\n```\n    50\n   /  \\\n  30   70\n /  \\\n20  40\n```\nとなります。中順走査（In-order）は、左 → 根 → 右の順で走査します。①30の左（20）→ 20を出力、②30を出力、③30の右（40）→ 40を出力、④50を出力、⑤50の右（70）→ 70を出力、となり、20, 30, 40, 50, 70（昇順）が取得されます。2分探索木を中順走査すると、常に昇順にデータが取得できます。選択肢①は前順走査（Pre-order: 根 → 左 → 右）、③は降順、④はランダムな順序です。"
    },
    {
      "id": "tech-4-3-2-q6",
      "type": "multiple_choice",
      "question": "2分探索木における検索、挿入、削除の平均計算量として正しいものはどれですか？",
      "options": [
        "O(1)",
        "O(log n)",
        "O(n)",
        "O(n²)"
      ],
      "correctAnswer": 1,
      "explanation": "「O(log n)」が正しいです。2分探索木では、検索、挿入、削除の平均計算量はO(log n)です。これは、木の高さに比例します（平衡木の場合、高さはlog nに近い）。例えば、1,000個のデータを持つ2分探索木の高さは約10（2^10 = 1,024）なので、検索は最大10回の比較で完了します。しかし、最悪の場合（データが昇順で挿入され、木が一直線になった場合）、計算量はO(n)に悪化します。例えば、[10, 20, 30, 40, 50]を挿入すると、木は\n```\n10\n  \\\n  20\n    \\\n    30\n      \\\n      40\n        \\\n        50\n```\nとなり、高さがnになります。この問題を解決するため、AVL木、赤黒木などの平衡2分探索木が使用されます。平衡木では、挿入・削除時に木のバランスを調整し、常に高さをlog nに保ちます。選択肢①O(1)はハッシュテーブルの平均計算量、③O(n)は線形探索や連結リストの計算量、④O(n²)はバブルソートなどの計算量です。"
    },
    {
      "id": "tech-4-3-2-q7",
      "type": "multiple_choice",
      "question": "ヒープ（Heap）に関する記述のうち、正しいものはどれですか？",
      "options": [
        "最大ヒープでは、親ノードの値が子ノードの値より小さい",
        "ヒープは、検索の平均計算量がO(1)である",
        "ヒープは、優先度付きキュー（Priority Queue）の実装に使用される",
        "ヒープは、中順走査すると昇順にデータが取得できる"
      ],
      "correctAnswer": 2,
      "explanation": "「ヒープは、優先度付きキュー（Priority Queue）の実装に使用される」が正しいです。ヒープは、完全2分木で、最大ヒープでは親ノード ≥ 子ノード、最小ヒープでは親ノード ≤ 子ノードの性質を満たします。ヒープは、優先度付きキュー（優先度が高いデータを先に取り出すデータ構造）の実装に使用されます。例えば、タスクスケジューリングでは、優先度が高いタスクを先に処理するために、最大ヒープを使用します。ヒープの操作は、①挿入：O(log n)、②最大値（最小値）の取り出し：O(log n)、です。選択肢①最大ヒープでは、親ノードの値が子ノードの値以上（≥）です。選択肢②ヒープの検索の平均計算量はO(n)です（ヒープは検索に最適化されていない）。選択肢④中順走査で昇順にデータが取得できるのは、2分探索木です。ヒープでは、中順走査しても昇順にはなりません（親 ≥ 子の性質だけで、左右の順序は保証されない）。"
    },
    {
      "id": "tech-4-3-2-q8",
      "type": "multiple_choice",
      "question": "ハッシュテーブルにおいて、異なるキーが同じハッシュ値になることを何と呼びますか？また、その解決方法として正しいものはどれですか？",
      "options": [
        "衝突（Collision）、解決方法：チェイン法またはオープンアドレス法",
        "オーバーフロー（Overflow）、解決方法：配列のサイズを拡大",
        "デッドロック（Deadlock）、解決方法：ロックの順序を統一",
        "スタック（Stack）、解決方法：キューに変更"
      ],
      "correctAnswer": 0,
      "explanation": "「衝突（Collision）、解決方法：チェイン法またはオープンアドレス法」が正しいです。ハッシュテーブルでは、ハッシュ関数を使用してキーをインデックス（ハッシュ値）に変換し、配列に格納します。衝突（Collision）とは、異なるキーが同じハッシュ値になることです。例えば、ハッシュ関数が「学生ID % 10」の場合、学生ID 1001と1031は両方ともハッシュ値1になります。衝突の解決方法として、①チェイン法（Chaining）：同じハッシュ値のデータを連結リストで管理（例: 配列[1] → 太郎 → 美咲）、②オープンアドレス法（Open Addressing）：別の空きスロットを探す（線形探査法、2次探査法）、があります。選択肢②オーバーフローは、配列やスタックが満杯になることです。選択肢③デッドロックは、複数のプロセスが互いにロックを待ち、進行できなくなることです。選択肢④スタックとキューは、異なるデータ構造です。"
    },
    {
      "id": "tech-4-3-2-q9",
      "type": "multiple_choice",
      "question": "グラフ（Graph）の表現方法に関する記述のうち、正しいものはどれですか？",
      "options": [
        "隣接行列は、疎なグラフ（辺が少ない）に適している",
        "隣接リストは、密なグラフ（辺が多い）に適している",
        "隣接行列は、辺の存在確認がO(1)でできる",
        "隣接リストは、メモリ使用量がO(V²)である（Vはノード数）"
      ],
      "correctAnswer": 2,
      "explanation": "「隣接行列は、辺の存在確認がO(1)でできる」が正しいです。隣接行列は、2次元配列でノード間の接続を表現します。例えば、ノードAとノードBの間に辺があるかを確認するには、行列[A][B]を見ればよく、O(1)で確認できます。隣接行列のメモリ使用量はO(V²)で、辺が多い密なグラフに適しています。一方、隣接リストは、各ノードに接続されたノードをリストで表現します。メモリ使用量はO(V+E)（Eは辺の数）で、辺が少ない疎なグラフに適しています。辺の存在確認はO(V)（最悪の場合、全てのノードを探索）です。選択肢①隣接行列は、密なグラフ（辺が多い）に適しています。選択肢②隣接リストは、疎なグラフ（辺が少ない）に適しています。選択肢④隣接リストのメモリ使用量はO(V+E)です。実際のグラフ（SNSの友人関係、Webページのリンク構造）では、辺が少ない疎なグラフが多いため、隣接リストが一般的です。"
    },
    {
      "id": "tech-4-3-2-q10",
      "type": "multiple_choice",
      "question": "次のシステムのうち、使用するデータ構造として最も適切なものはどれですか？\n\nシステム：学生IDから学生名を高速に検索したい（検索回数が非常に多い、順序は不要）",
      "options": [
        "配列",
        "2分探索木",
        "ハッシュテーブル",
        "スタック"
      ],
      "correctAnswer": 2,
      "explanation": "「ハッシュテーブル」が正しいです。学生IDから学生名を高速に検索したい場合、ハッシュテーブルが最適です。ハッシュテーブルは、キー（学生ID）と値（学生名）のペアを格納し、検索の平均計算量がO(1)です（非常に高速）。また、順序は不要なので、ハッシュテーブルの欠点（順序を持たない）は問題になりません。例えば、1,000,000人の学生IDから学生名を検索する場合、ハッシュテーブルなら1回のハッシュ関数の計算で検索できます（O(1)）。選択肢①配列は、検索にO(n)かかります（全要素を走査）。選択肢②2分探索木は、検索にO(log n)かかります（ハッシュテーブルより遅い）。ただし、2分探索木は順序が必要な場合（範囲検索、ソート）に適しています。選択肢④スタックは、LIFO処理に使用され、検索には適していません。データ構造の選択では、要件（操作の頻度、データの性質、計算量）に応じて、最適なものを選ぶことが重要です。"
    }
  ]
}
