{
  "topicId": "tech-1-2-1",
  "title": "数値表現",
  "questions": [
    {
      "id": "q-tech-1-2-1-001",
      "type": "multiple_choice",
      "question": "固定小数点数と浮動小数点数の主な違いは何ですか？",
      "options": [
        "精度の違い",
        "小数点の位置が固定か可変か",
        "使用するビット数の違い",
        "正負の表現方法の違い"
      ],
      "correctAnswer": 1,
      "explanation": "固定小数点数は、小数点の位置が常に固定されています（例：整数部8ビット、小数部8ビット）。\n浮動小数点数は、小数点の位置が可変で、仮数部と指数部で表現します。\n\n固定小数点数：表現範囲は狭いが計算が高速\n浮動小数点数：広い範囲の数値を表現できるが計算が複雑\n\n科学計算など、非常に大きな数や小さな数を扱う場合は浮動小数点数が適しています。"
    },
    {
      "id": "q-tech-1-2-1-002",
      "type": "multiple_choice",
      "question": "32ビットの浮動小数点数（IEEE754単精度）で、符号部、指数部、仮数部のビット数の組み合わせとして正しいものはどれですか？",
      "options": [
        "符号1ビット、指数8ビット、仮数23ビット",
        "符号1ビット、指数11ビット、仮数20ビット",
        "符号2ビット、指数10ビット、仮数20ビット",
        "符号1ビット、指数7ビット、仮数24ビット"
      ],
      "correctAnswer": 0,
      "explanation": "IEEE754単精度（32ビット）浮動小数点数の構成：\n・符号部：1ビット（0=正、1=負）\n・指数部：8ビット（-126～+127を表現、バイアス127）\n・仮数部：23ビット（正規化された仮数の小数部分）\n\n合計：1 + 8 + 23 = 32ビット\n\n倍精度（64ビット）の場合は、符号1ビット、指数11ビット、仮数52ビットです。"
    },
    {
      "id": "q-tech-1-2-1-003",
      "type": "multiple_choice",
      "question": "浮動小数点数の正規化とは何ですか？",
      "options": [
        "絶対値を1未満にすること",
        "仮数部の最上位桁を1にすること",
        "指数部を0にすること",
        "符号を正にすること"
      ],
      "correctAnswer": 1,
      "explanation": "正規化とは、仮数部の最上位桁（最上位ビット）を1にする操作です。\n\n例（2進数）：\n0.001101 × 2⁵ → 1.101 × 2² （正規化）\n\n正規化の利点：\n・表現の一意性（同じ数の表現が1通りに定まる）\n・精度の向上（有効桁数が最大になる）\n\nIEEE754では、正規化された数の仮数部は1.xxxの形式になり、先頭の1は暗黙的に省略されます（隠しビット）。"
    },
    {
      "id": "q-tech-1-2-1-004",
      "type": "multiple_choice",
      "question": "IEEE754形式で、指数部に「バイアス（bias）」を加える理由は何ですか？",
      "options": [
        "計算を高速化するため",
        "負の指数を表現するため",
        "精度を向上させるため",
        "メモリを節約するため"
      ],
      "correctAnswer": 1,
      "explanation": "バイアス（bias）は、負の指数を符号なし整数で表現するために使用されます。\n\nIEEE754単精度の場合：\n・指数部は8ビット（0～255）\n・バイアス値は127\n・実際の指数 = 指数部の値 - 127\n・表現範囲：-126～+127\n\n例：指数部が130の場合、実際の指数は130 - 127 = 3\n　　指数部が124の場合、実際の指数は124 - 127 = -3\n\nこれにより、2の補数を使わずに負の指数を表現できます。"
    },
    {
      "id": "q-tech-1-2-1-005",
      "type": "multiple_choice",
      "question": "10進数の0.1を2進数の浮動小数点数で正確に表現できますか？",
      "options": [
        "正確に表現できる",
        "正確に表現できない",
        "単精度では可能だが倍精度では不可能",
        "特殊な形式なら可能"
      ],
      "correctAnswer": 1,
      "explanation": "10進数の0.1は2進数では循環小数になり、有限のビット数では正確に表現できません。\n\n0.1（10進数）= 0.0001100110011...（2進数、循環）\n\nこれは、1/10が2進数で有限小数にならないためです。\n2進数で正確に表現できるのは、1/2、1/4、1/8など、2のべき乗の逆数の和で表せる数だけです。\n\nこのため、0.1 + 0.2が正確に0.3にならないといった浮動小数点演算の誤差が発生します。"
    },
    {
      "id": "q-tech-1-2-1-006",
      "type": "multiple_choice",
      "question": "16ビットの固定小数点数で、整数部8ビット、小数部8ビットの場合、表現できる最大の正の数はどれですか（符号なし）？",
      "options": ["255", "255.99609375", "256", "65535"],
      "correctAnswer": 1,
      "explanation": "16ビット符号なし固定小数点数の構成：\n・整数部：8ビット（0～255）\n・小数部：8ビット（0～255/256）\n\n最大値の計算：\n整数部が全て1：11111111（2進数）= 255\n小数部が全て1：11111111（2進数）= 255/256 ≈ 0.99609375\n\n最大値 = 255 + 255/256 = 255.99609375\n\n小数部の最小刻みは1/256 = 0.00390625です。"
    },
    {
      "id": "q-tech-1-2-1-007",
      "type": "multiple_choice",
      "question": "IEEE754形式の浮動小数点数で、全てのビットが0の場合、どの値を表しますか？",
      "options": ["0", "最小の正の数", "NaN（非数）", "未定義"],
      "correctAnswer": 0,
      "explanation": "IEEE754形式では、全ビットが0の場合は+0（正のゼロ）を表します。\n\n特殊な値の表現：\n・+0：符号0、指数0、仮数0\n・-0：符号1、指数0、仮数0（負のゼロも存在）\n・+∞：符号0、指数が全て1、仮数0\n・-∞：符号1、指数が全て1、仮数0\n・NaN：指数が全て1、仮数が非ゼロ\n\nIEEE754では+0と-0を区別しますが、比較演算では等しいとみなされます。"
    },
    {
      "id": "q-tech-1-2-1-008",
      "type": "multiple_choice",
      "question": "浮動小数点数で「仮数部」が表すものは何ですか？",
      "options": [
        "数値の大きさ（桁）",
        "数値の精度（有効数字）",
        "数値の符号",
        "数値の型"
      ],
      "correctAnswer": 1,
      "explanation": "仮数部（mantissa/significand）は、数値の精度（有効数字）を表します。\n\n浮動小数点数の構成：\n数値 = (-1)^符号 × 仮数 × 2^指数\n\n・符号部：正負を表す\n・指数部：数値の大きさ（桁、スケール）を表す\n・仮数部：数値の精度（有効桁数）を表す\n\n例：1.25 × 10³ の場合\n　　仮数部：1.25（精度を決定）\n　　指数部：3（大きさを決定）\n\n仮数部のビット数が多いほど、精度が高くなります。"
    },
    {
      "id": "q-tech-1-2-1-009",
      "type": "multiple_choice",
      "question": "IEEE754倍精度（64ビット）浮動小数点数の構成として正しいものはどれですか？",
      "options": [
        "符号1ビット、指数8ビット、仮数55ビット",
        "符号1ビット、指数11ビット、仮数52ビット",
        "符号2ビット、指数10ビット、仮数52ビット",
        "符号1ビット、指数16ビット、仮数47ビット"
      ],
      "correctAnswer": 1,
      "explanation": "IEEE754倍精度（64ビット）浮動小数点数の構成：\n・符号部：1ビット（0=正、1=負）\n・指数部：11ビット（-1022～+1023を表現、バイアス1023）\n・仮数部：52ビット（正規化された仮数の小数部分）\n\n合計：1 + 11 + 52 = 64ビット\n\n単精度と比較すると：\n・指数部が3ビット増加→表現範囲が大幅に拡大\n・仮数部が29ビット増加→精度が大幅に向上\n\n倍精度は約15～17桁の10進数の精度を持ちます。"
    },
    {
      "id": "q-tech-1-2-1-010",
      "type": "multiple_choice",
      "question": "浮動小数点数で表現できない特殊な値「NaN（Not a Number）」が発生する演算はどれですか？",
      "options": [
        "1.0 ÷ 0",
        "0 ÷ 0",
        "∞ - ∞",
        "両方ともNaNになる"
      ],
      "correctAnswer": 3,
      "explanation": "NaN（Not a Number）が発生する演算：\n・0 ÷ 0（不定形）\n・∞ - ∞（不定形）\n・∞ ÷ ∞（不定形）\n・√(-1)（負の数の平方根）\n・NaNを含む演算\n\n一方、1.0 ÷ 0は：\n・分子が正：+∞（正の無限大）\n・分子が負：-∞（負の無限大）\n\nNaNの特徴：\n・NaN == NaNは常にfalse（自分自身とも等しくない）\n・NaNを含む演算結果は常にNaN\n・isNaN()関数で判定可能"
    }
  ]
}
