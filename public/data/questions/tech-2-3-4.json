{
  "topicId": "tech-2-3-4",
  "title": "実記憶管理",
  "questions": [
    {
      "id": "tech-2-3-4-q1",
      "type": "multiple_choice",
      "question": "固定区画方式において、8GBのメモリを2GB、2GB、2GB、2GBの4つの区画に分割した場合、1.5GBのプログラムA、0.8GBのプログラムB、0.3GBのプログラムCを実行すると、無駄になるメモリ（内部フラグメンテーション）の合計は何GBですか？",
      "options": [
        "0.4GB",
        "1.4GB",
        "3.4GB",
        "4.4GB"
      ],
      "correctAnswer": 2,
      "explanation": "「3.4GB」が正しいです。固定区画方式では、各プログラムに1つの区画（2GB）を割り当てます。プログラムA（1.5GB）→ 区画1（2GB）を使用 → 無駄: 0.5GB。プログラムB（0.8GB）→ 区画2（2GB）を使用 → 無駄: 1.2GB。プログラムC（0.3GB）→ 区画3（2GB）を使用 → 無駄: 1.7GB。無駄なメモリの合計 = 0.5GB + 1.2GB + 1.7GB = 3.4GBです。これが内部フラグメンテーション（割り当てられた区画の内部で発生する無駄）です。固定区画方式の最大の欠点は、プログラムのサイズが区画サイズより小さい場合、余ったメモリが無駄になることです。選択肢①0.4GBは計算が間違っています。④4.4GBは合計を間違えています。"
    },
    {
      "id": "tech-2-3-4-q2",
      "type": "multiple_choice",
      "question": "可変区画方式において、メモリの状態が[使用中 2GB][空き 1GB][使用中 1.5GB][空き 3GB][使用中 0.5GB][空き 2GB]である場合、1.2GBのプログラムをFirst Fitアルゴリズムで割り当てると、どの空き領域に割り当てられますか？",
      "options": [
        "1GBの空き領域",
        "3GBの空き領域",
        "2GBの空き領域",
        "割り当てられない（メモリ不足）"
      ],
      "correctAnswer": 1,
      "explanation": "「3GBの空き領域」が正しいです。First Fit（最初適合）アルゴリズムは、先頭から順番に空き領域を探し、最初に見つかった「十分なサイズの空き領域」に割り当てます。プログラムのサイズは1.2GBです。先頭から順番に探すと、①1GBの空き領域 → 1.2GBより小さい（不足）、②3GBの空き領域 → 1.2GBより大きい（十分！）、となります。First Fitは、最初に見つかった十分なサイズの空き領域（3GB）に割り当てます。割り当て後、3GBの空き領域は、1.2GBが使用され、残り1.8GBになります。First Fitの利点は、探索が高速（最初に見つかった領域に割り当てる）であることです。選択肢③2GBの空き領域は、Best Fitアルゴリズムで割り当てられる領域です（サイズが最も近い）。"
    },
    {
      "id": "tech-2-3-4-q3",
      "type": "multiple_choice",
      "question": "可変区画方式において、外部フラグメンテーションが発生している場合の対策として正しいものはどれですか？",
      "options": [
        "メモリを固定区画に再分割する",
        "メモリコンパクションを実行して、空き領域を1つにまとめる",
        "プログラムをオーバーレイ方式で実行する",
        "スワッピング方式に切り替える"
      ],
      "correctAnswer": 1,
      "explanation": "「メモリコンパクションを実行して、空き領域を1つにまとめる」が正しいです。外部フラグメンテーションは、空きメモリが細かく分散し、合計では十分なメモリがあるのに連続した領域として確保できない現象です。メモリコンパクション（ガベージコレクション）は、メモリ上のプログラムを移動させて、断片化した空き領域を1つにまとめる技術です。例えば、[空き 1.5GB][空き 0.8GB][使用中 4GB][使用中 0.3GB][空き 1.4GB]という状態で、使用中のプログラムを先頭に移動させると、[使用中 4GB][使用中 0.3GB][空き 3.7GB]となり、連続した3.7GBの空き領域ができます。メモリコンパクションにより、外部フラグメンテーションを解決できます。選択肢①固定区画に再分割すると、内部フラグメンテーションが発生します。③オーバーレイ方式、④スワッピング方式は、外部フラグメンテーションの直接的な対策ではありません。"
    },
    {
      "id": "tech-2-3-4-q4",
      "type": "multiple_choice",
      "question": "Best Fitアルゴリズムの説明として正しいものはどれですか？",
      "options": [
        "先頭から順番に空き領域を探し、最初に見つかった十分なサイズの領域に割り当てる",
        "全ての空き領域を調べ、プログラムのサイズに最も近い領域に割り当てる",
        "全ての空き領域を調べ、最も大きい領域に割り当てる",
        "ランダムに空き領域を選び、割り当てる"
      ],
      "correctAnswer": 1,
      "explanation": "「全ての空き領域を調べ、プログラムのサイズに最も近い領域に割り当てる」が正しいです。Best Fit（最良適合）アルゴリズムは、全ての空き領域を調べ、プログラムのサイズに最も近い（無駄が最小になる）空き領域に割り当てます。例えば、空き領域が1GB、3GB、2GBで、プログラムのサイズが1.2GBの場合、Best Fitは2GBの領域に割り当てます（1.2GBに最も近い）。割り当て後、2GBの領域は、1.2GBが使用され、残り0.8GBになります。Best Fitの利点は、無駄が少ないことですが、欠点は、①全ての空き領域を探索するため処理時間がかかる、②小さな空き領域（0.8GB）が大量に発生し、結果的に外部フラグメンテーションが悪化することです。選択肢①はFirst Fit、③はWorst Fitの説明です。実際のOSでは、First Fitが最も一般的に使用されます。"
    },
    {
      "id": "tech-2-3-4-q5",
      "type": "multiple_choice",
      "question": "オーバーレイ方式の説明として正しいものはどれですか？",
      "options": [
        "メモリをあらかじめ固定サイズの区画に分割し、各プログラムを区画に割り当てる",
        "プログラムを複数のモジュールに分割し、必要なモジュールだけを順次メモリに読み込む",
        "プログラム全体をハードディスクに退避し、メモリを空ける",
        "プログラムを小さな単位（ページ）に分割し、必要なページだけをメモリに配置する"
      ],
      "correctAnswer": 1,
      "explanation": "「プログラムを複数のモジュールに分割し、必要なモジュールだけを順次メモリに読み込む」が正しいです。オーバーレイ方式は、プログラム全体をメモリに配置するのではなく、プログラムを複数のモジュール（部品）に分割し、実行に必要なモジュールだけをメモリに読み込みます。使い終わったモジュールは、次のモジュールで上書き（オーバーレイ）されます。例えば、10GBのプログラムを、データ入力モジュール（2GB）、計算モジュールA（3GB）、計算モジュールB（4GB）、結果出力モジュール（1GB）に分割し、順次メモリに読み込んで実行します。オーバーレイ方式により、8GBのメモリで10GBのプログラムを実行できます。選択肢①は固定区画方式、③はスワッピング方式、④は仮想記憶（ページング方式）の説明です。オーバーレイ方式は、1960年代～1980年代に広く使われましたが、現在はほとんど使われていません（仮想記憶が主流）。"
    },
    {
      "id": "tech-2-3-4-q6",
      "type": "multiple_choice",
      "question": "オーバーレイ方式の欠点として正しいものはどれですか？",
      "options": [
        "内部フラグメンテーションが発生する",
        "外部フラグメンテーションが発生する",
        "プログラマがモジュール分割を設計する必要があり、プログラムが複雑になる",
        "メモリ容量より大きなプログラムを実行できない"
      ],
      "correctAnswer": 2,
      "explanation": "「プログラマがモジュール分割を設計する必要があり、プログラムが複雑になる」が正しいです。オーバーレイ方式では、プログラマが、プログラムをどのようなモジュールに分割するか、どのモジュールをいつメモリに読み込むかを設計する必要があります。これにより、プログラムが複雑になり、開発コストが増加します。また、モジュールの切り替え（ディスクからメモリへの読み込み）に時間がかかるため、プログラム全体の実行時間が長くなります。オーバーレイ方式の利点は、メモリ容量より大きなプログラムを実行できることですが、欠点は、実装が複雑で、パフォーマンスが低いことです。現在のOSでは、仮想記憶（ページング方式）を使えば、OSが自動的にメモリとディスクを管理するため、オーバーレイ方式は不要です。選択肢①内部フラグメンテーションは固定区画方式、②外部フラグメンテーションは可変区画方式の問題です。④はオーバーレイ方式の利点と逆です。"
    },
    {
      "id": "tech-2-3-4-q7",
      "type": "multiple_choice",
      "question": "スワッピング方式において、「プログラムのデータをメモリからハードディスクに退避すること」を何と言いますか？",
      "options": [
        "スワップイン",
        "スワップアウト",
        "ページイン",
        "ページアウト"
      ],
      "correctAnswer": 1,
      "explanation": "「スワップアウト」が正しいです。スワッピング方式では、メモリが不足した場合、実行中のプログラムを一時的にハードディスク（スワップ領域）に退避し、メモリを空けます。この「メモリからハードディスクへの退避」をスワップアウト（Swap Out）と言います。逆に、退避されたプログラムのデータをハードディスクからメモリに戻すことをスワップイン（Swap In）と言います。スワッピングの流れは、①メモリが不足 → ②OSがしばらく使われていないプログラムを選択 → ③スワップアウト（HDDに退避） → ④メモリが空く → ⑤新しいプログラムをメモリに配置 → ⑥ユーザーが退避されたプログラムに切り替える → ⑦スワップイン（HDDからメモリに戻す）、となります。選択肢③ページイン、④ページアウトは、仮想記憶（ページング方式）で使われる用語です。"
    },
    {
      "id": "tech-2-3-4-q8",
      "type": "multiple_choice",
      "question": "スラッシング（Thrashing）の説明として正しいものはどれですか？",
      "options": [
        "メモリが十分にあるのに、プログラムが実行できない現象",
        "スワッピングが頻繁に発生し、システムがほとんどスワッピングの処理に時間を使い、プログラムの実行が進まなくなる現象",
        "メモリコンパクションが頻繁に実行され、システムが遅くなる現象",
        "プログラムがメモリを大量に消費し、他のプログラムが起動できなくなる現象"
      ],
      "correctAnswer": 1,
      "explanation": "「スワッピングが頻繁に発生し、システムがほとんどスワッピングの処理に時間を使い、プログラムの実行が進まなくなる現象」が正しいです。スラッシング（Thrashing）は、メモリに対して実行するプログラムが多すぎる場合に発生します。例えば、8GBのメモリで10個のプログラム（各1GB）を同時実行しようとすると、OSは常にスワッピング（プログラムをメモリとハードディスクの間で移動）を実行します。スワッピングは、ハードディスクへのアクセスが非常に遅いため（メモリの100万倍遅い）、システム全体が非常に遅くなります。スラッシングの対策は、①メモリを増設する、②同時に実行するプログラムを減らす、③仮想記憶のページングアルゴリズム（LRU）を改善する、です。選択肢①③④は、スラッシングの説明として正しくありません。スラッシングは、スワッピング方式や仮想記憶の最大の問題点です。"
    },
    {
      "id": "tech-2-3-4-q9",
      "type": "multiple_choice",
      "question": "内部フラグメンテーションと外部フラグメンテーションの違いとして正しいものはどれですか？",
      "options": [
        "内部フラグメンテーションは固定区画方式で発生し、外部フラグメンテーションは可変区画方式で発生する",
        "内部フラグメンテーションは可変区画方式で発生し、外部フラグメンテーションは固定区画方式で発生する",
        "内部フラグメンテーションと外部フラグメンテーションは同じ現象である",
        "内部フラグメンテーションはスワッピング方式で発生し、外部フラグメンテーションはオーバーレイ方式で発生する"
      ],
      "correctAnswer": 0,
      "explanation": "「内部フラグメンテーションは固定区画方式で発生し、外部フラグメンテーションは可変区画方式で発生する」が正しいです。内部フラグメンテーション（Internal Fragmentation）は、割り当てられた区画の「内部」で無駄が発生する現象です。固定区画方式では、プログラムのサイズが区画サイズより小さい場合、余ったメモリは他のプログラムに使えず、無駄になります（例: 2GBの区画に0.8GBのプログラム → 1.2GBが無駄）。外部フラグメンテーション（External Fragmentation）は、空きメモリが細かく分散し、合計では十分なメモリがあるのに連続した領域として確保できない現象です。可変区画方式では、プログラムの起動・終了が繰り返されると、メモリが断片化し、外部フラグメンテーションが発生します。対策は、内部フラグメンテーション → 可変区画方式を使用、外部フラグメンテーション → メモリコンパクションを実行、です。選択肢②③④は間違っています。"
    },
    {
      "id": "tech-2-3-4-q10",
      "type": "multiple_choice",
      "question": "次のうち、現在の一般的なOS（Windows、macOS、Linux）で主流のメモリ管理方式はどれですか？",
      "options": [
        "固定区画方式",
        "可変区画方式",
        "オーバーレイ方式",
        "仮想記憶（ページング方式）"
      ],
      "correctAnswer": 3,
      "explanation": "「仮想記憶（ページング方式）」が正しいです。現在の一般的なOS（Windows、macOS、Linux）では、仮想記憶（ページング方式）が主流です。仮想記憶は、プログラムを小さな単位（ページ、例: 4KB）に分割し、必要なページだけをメモリに配置する方式です。仮想記憶により、①物理メモリより大きなプログラムを実行できる、②メモリを効率的に使用できる、③スラッシングが発生しにくい（ページ置き換えアルゴリズムで改善）、などの利点があります。実記憶管理（固定区画方式、可変区画方式、オーバーレイ方式、スワッピング方式）は、1960年代～1990年代に使われていた技術で、現在は主流ではありません。ただし、メモリが少ない組み込みシステムやリアルタイムOSでは、可変区画方式や固定区画方式が一部使用されています。実記憶管理の知識は、仮想記憶を理解するための基礎として重要です。"
    }
  ]
}
