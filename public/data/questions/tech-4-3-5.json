{
  "topicId": "tech-4-3-5",
  "title": "アルゴリズムの計算量",
  "questions": [
    {
      "id": "tech-4-3-5-q1",
      "type": "multiple_choice",
      "question": "次のアルゴリズムの時間計算量として正しいものはどれですか？\n\n```\nfor i = 1 to n:\n    for j = 1 to n:\n        print(i, j)\n```",
      "options": [
        "O(1)",
        "O(n)",
        "O(n log n)",
        "O(n²)"
      ],
      "correctAnswer": 3,
      "explanation": "「O(n²)」が正しいです。このアルゴリズムは2重ループで構成されています。外側のループがn回、内側のループが毎回n回実行されるため、print文の実行回数は n × n = n²回です。よって、時間計算量はO(n²)（2次時間）となります。例えば、n=10の場合、print文は100回実行され、n=100の場合は10,000回実行されます。nが10倍になると、処理回数は100倍（10²倍）になります。選択肢①O(1)は定数時間（ループなし）、②O(n)は線形時間（単一ループ）、③O(n log n)は線形対数時間（マージソートなど）を表します。2重ループの場合、内側のループの回数がnに依存するため、O(n²)になります。"
    },
    {
      "id": "tech-4-3-5-q2",
      "type": "multiple_choice",
      "question": "ソート済みの配列から特定の値を探索する際、最も効率的なアルゴリズムとその時間計算量の組み合わせとして正しいものはどれですか？",
      "options": [
        "線形探索 - O(1)",
        "線形探索 - O(n)",
        "2分探索 - O(log n)",
        "2分探索 - O(n)"
      ],
      "correctAnswer": 2,
      "explanation": "「2分探索 - O(log n)」が正しいです。ソート済みの配列に対しては、2分探索（Binary Search）が最も効率的です。2分探索では、配列の中央の要素と比較し、探索値が中央より小さい場合は左半分、大きい場合は右半分を探索することで、毎回探索範囲を半分に減らします。探索範囲が1個になるまでの回数は log₂ n 回なので、時間計算量はO(log n)（対数時間）です。例えば、n=1000の配列では最悪で約10回の比較（2^10 = 1024）、n=100万の配列では約20回の比較（2^20 = 1,048,576）で探索が完了します。線形探索（Linear Search）は配列の先頭から順番に探索する方法で、時間計算量はO(n)です。ソート済みの配列には不向きです。選択肢①の線形探索O(1)は誤りで、線形探索の最良ケースはO(1)（先頭に目的の値がある場合）ですが、平均・最悪ケースはO(n)です。選択肢④の2分探索O(n)も誤りで、2分探索の時間計算量はO(log n)です。"
    },
    {
      "id": "tech-4-3-5-q3",
      "type": "multiple_choice",
      "question": "次のアルゴリズムの時間計算量として正しいものはどれですか？\n\n```\nfor i = 1 to n:\n    for j = 1 to i:\n        print(i, j)\n```",
      "options": [
        "O(n)",
        "O(n log n)",
        "O(n²)",
        "O(n³)"
      ],
      "correctAnswer": 2,
      "explanation": "「O(n²)」が正しいです。このアルゴリズムの内側のループの実行回数は、iの値によって異なります。iが1のとき1回、iが2のとき2回、iが3のとき3回...、iがnのときn回です。合計実行回数は 1 + 2 + 3 + ... + n = n(n+1)/2 = (n² + n)/2 回です。オーダ記法では、最も影響の大きい項（n²）のみを残し、定数項（n）と係数（1/2）を無視するため、時間計算量はO(n²)となります。例えば、n=10の場合、print文は55回（10×11/2）実行され、n=100の場合は5,050回（100×101/2）実行されます。nが10倍になると、処理回数は約100倍（10²倍）になります。選択肢①O(n)は線形時間（単一ループ）、②O(n log n)は線形対数時間（マージソートなど）、④O(n³)は3重ループの場合を表します。この問題のように、内側のループの回数が外側のループの変数iに依存する場合、合計はn²/2回となり、O(n²)になります。"
    },
    {
      "id": "tech-4-3-5-q4",
      "type": "multiple_choice",
      "question": "次のアルゴリズムの時間計算量として正しいものはどれですか？\n\n```\nn = 1000\nwhile n > 1:\n    n = n / 2\n    print(n)\n```",
      "options": [
        "O(1)",
        "O(log n)",
        "O(n)",
        "O(n²)"
      ],
      "correctAnswer": 1,
      "explanation": "「O(log n)」が正しいです。このアルゴリズムでは、ループごとにnの値が半分になります。初期値がn=1000の場合、ループの実行回数は、1000 → 500 → 250 → 125 → 62 → 31 → 15 → 7 → 3 → 1の10回です。一般に、nが半分になる回数k（ループ回数）は、n/(2^k) = 1 → 2^k = n → k = log₂ n と計算できます。よって、時間計算量はO(log n)（対数時間）です。例えば、n=1000では約10回（2^10 = 1024）、n=100万では約20回（2^20 = 1,048,576）のループが実行されます。nが1000倍になっても、ループ回数は約2倍にしかなりません。「毎回、値が半分になる（または2倍になる）」パターンは、O(log n)の典型例です。2分探索、完全2分木の深さ、バブルソートの最適化版などもO(log n)の要素を含みます。選択肢①O(1)は定数時間（ループなし）、③O(n)は線形時間（n回のループ）、④O(n²)は2重ループの場合を表します。"
    },
    {
      "id": "tech-4-3-5-q5",
      "type": "multiple_choice",
      "question": "バブルソート、選択ソート、挿入ソート、マージソート、クイックソート（平均）の中で、時間計算量が最も小さい（効率が良い）アルゴリズムはどれですか？",
      "options": [
        "バブルソート（O(n²)）",
        "選択ソート（O(n²)）",
        "挿入ソート（O(n²)）",
        "マージソート（O(n log n)）"
      ],
      "correctAnswer": 3,
      "explanation": "「マージソート（O(n log n)）」が正しいです。主要なソートアルゴリズムの時間計算量を比較すると、①バブルソート、選択ソート、挿入ソート：O(n²)（2次時間）、②マージソート、クイックソート（平均）、ヒープソート：O(n log n)（線形対数時間）、となります。O(n log n)はO(n²)より効率が良いため、マージソートが最も効率的です。具体例として、n=1000の配列をソートする場合、O(n²)のアルゴリズムでは約100万回（1000²）の処理が必要ですが、O(n log n)のアルゴリズムでは約10,000回（1000 × log₂ 1000 ≈ 1000 × 10）の処理で済みます。約100倍の差があります。選択肢①②③のバブルソート、選択ソート、挿入ソートはすべてO(n²)で、大規模なデータには不向きです。ただし、挿入ソートは、すでにソート済みのデータに対しては最良ケースO(n)で動作するため、ほぼソート済みのデータには適しています。また、クイックソート（平均）もO(n log n)ですが、最悪ケースはO(n²)です。マージソートは最良・平均・最悪すべてO(n log n)で安定しています。"
    },
    {
      "id": "tech-4-3-5-q6",
      "type": "multiple_choice",
      "question": "線形探索で100万件のデータから特定の値を探索する場合、最悪ケースで必要な比較回数として正しいものはどれですか？",
      "options": [
        "約20回",
        "約1,000回",
        "約10,000回",
        "約100万回"
      ],
      "correctAnswer": 3,
      "explanation": "「約100万回」が正しいです。線形探索（Linear Search）は、配列の先頭から順番に探索する方法で、時間計算量はO(n)です。最悪ケースは、目的の値が配列の最後にある場合、または配列に目的の値が存在しない場合で、全ての要素を確認する必要があります。n=100万件の場合、最悪で100万回の比較が必要です。選択肢①約20回は、2分探索の場合の比較回数です。2分探索では、毎回探索範囲を半分にするため、log₂ 1,000,000 ≈ 20回の比較で済みます。ただし、2分探索は「ソート済みの配列」が前提です。線形探索は未ソートのデータでも使用できますが、効率が悪いです。選択肢②約1,000回や③約10,000回は、どちらも線形探索の最悪ケースの比較回数としては少なすぎます。線形探索の平均ケースでは、目的の値が配列の中央付近にある場合、約n/2回（約50万回）の比較が必要です。大規模なデータを頻繁に探索する場合、事前にソート（O(n log n)）してから2分探索（O(log n)）を使う方が効率的です。"
    },
    {
      "id": "tech-4-3-5-q7",
      "type": "multiple_choice",
      "question": "次のアルゴリズムの時間計算量として正しいものはどれですか？\n\n```\nfor i = 1 to n:\n    for j = 1 to 10:  // 固定で10回\n        print(i, j)\n```",
      "options": [
        "O(1)",
        "O(n)",
        "O(n²)",
        "O(10n)"
      ],
      "correctAnswer": 1,
      "explanation": "「O(n)」が正しいです。このアルゴリズムの外側のループはn回実行され、内側のループは毎回固定で10回実行されます。よって、print文の実行回数は n × 10 = 10n 回です。オーダ記法では、係数（10）を無視するため、時間計算量はO(n)（線形時間）となります。例えば、n=100の場合、print文は1,000回（100 × 10）実行され、n=1000の場合は10,000回（1000 × 10）実行されます。nが10倍になると、処理回数も10倍になります。選択肢①O(1)は定数時間（ループなし）、③O(n²)は2重ループで内側のループもnに依存する場合（for j = 1 to n）、④O(10n)は係数を含めた表記ですが、オーダ記法では係数を無視するため、正しくはO(n)と表記します。重要なポイントは、内側のループが定数回（nに依存しない）の場合、時間計算量はO(n)になることです。内側のループがnに依存する場合（for j = 1 to n）は、O(n²)になります。"
    },
    {
      "id": "tech-4-3-5-q8",
      "type": "multiple_choice",
      "question": "クイックソートの最悪ケースの時間計算量はどれですか？また、最悪ケースが発生するのはどのような場合ですか？",
      "options": [
        "O(n log n)、ランダムなデータの場合",
        "O(n log n)、すでにソート済みのデータの場合",
        "O(n²)、すでにソート済みのデータで先頭をピボットに選ぶ場合",
        "O(n²)、ランダムなデータの場合"
      ],
      "correctAnswer": 2,
      "explanation": "「O(n²)、すでにソート済みのデータで先頭をピボットに選ぶ場合」が正しいです。クイックソートは、①ピボット（基準値）を選択、②ピボットより小さい要素を左、大きい要素を右に分割、③左右それぞれを再帰的にソート、という手順で動作します。最悪ケースは、ピボットが毎回最小値または最大値になる場合で、分割が極端に偏ります。例えば、すでにソート済みの配列[1, 2, 3, 4, 5]で、先頭（1）をピボットに選ぶと、左側は空、右側は[2, 3, 4, 5]となり、毎回1個ずつしか減りません。この場合、分割の深さはn回、各階層での処理はn, n-1, n-2, ..., 1回の比較となり、合計n(n-1)/2 ≈ n²/2回の処理が必要で、時間計算量はO(n²)になります。最悪ケースを避けるため、ピボットをランダムに選択する、または中央値を選択する改良版が使われます。選択肢①のO(n log n)、ランダムなデータは平均ケースを表します。選択肢②のO(n log n)、すでにソート済みは誤りで、ソート済みの場合は最悪ケースO(n²)になります（ピボットの選択方法による）。選択肢④のO(n²)、ランダムなデータも誤りで、ランダムなデータの場合は平均ケースO(n log n)です。"
    },
    {
      "id": "tech-4-3-5-q9",
      "type": "multiple_choice",
      "question": "挿入ソートの最良ケースの時間計算量はどれですか？また、最良ケースが発生するのはどのような場合ですか？",
      "options": [
        "O(1)、配列が1個の場合",
        "O(n)、すでにソート済みの配列の場合",
        "O(n log n)、ランダムなデータの場合",
        "O(n²)、逆順にソートされた配列の場合"
      ],
      "correctAnswer": 1,
      "explanation": "「O(n)、すでにソート済みの配列の場合」が正しいです。挿入ソート（Insertion Sort）は、配列の2番目以降の要素を、順番に「ソート済み部分」の適切な位置に挿入する方法です。すでにソート済みの配列[1, 2, 3, 4, 5]の場合、各要素は既に適切な位置にあるため、内側のwhileループ（挿入位置を探す）は実行されず、比較は1回のみで済みます。外側のループはn-1回実行されるため、時間計算量はO(n)（線形時間）となります。これは挿入ソートの最良ケースです。例えば、n=1000のソート済み配列の場合、約1,000回の処理で完了します。一方、ランダムなデータや逆順のデータの場合、平均・最悪ケースともO(n²)になります。選択肢①のO(1)、配列が1個は誤りで、配列が1個の場合はソートが不要ですが、挿入ソートの最良ケースはO(n)です。選択肢③のO(n log n)、ランダムなデータは誤りで、ランダムなデータの場合は平均ケースO(n²)です。選択肢④のO(n²)、逆順は最悪ケースを表します。挿入ソートは、すでにソート済みまたはほぼソート済みのデータに対しては高速O(n)ですが、大規模なランダムデータには不向きO(n²)です。"
    },
    {
      "id": "tech-4-3-5-q10",
      "type": "multiple_choice",
      "question": "次のうち、時間計算量が最も大きい（効率が悪い）オーダはどれですか？",
      "options": [
        "O(n log n)",
        "O(n²)",
        "O(2^n)",
        "O(n³)"
      ],
      "correctAnswer": 2,
      "explanation": "「O(2^n)」が正しいです。主要なオーダを効率の悪い順（処理が遅い順）に並べると、O(2^n) > O(n³) > O(n²) > O(n log n) > O(n) > O(log n) > O(1) となります。O(2^n)（指数時間）は、nが少し大きくなるだけで処理回数が爆発的に増加します。例えば、n=10では約1,024回、n=20では約104万回、n=30では約10億回、n=40では約1兆回の処理が必要で、n=50以上は実用的に計算不可能です。nが1増えるだけで、処理回数が約2倍になります。O(2^n)の典型例は、全探索（ビット全探索）やフィボナッチ数列（単純再帰）です。選択肢①O(n log n)は線形対数時間（マージソート、クイックソート）、②O(n²)は2次時間（バブルソート、選択ソート）、④O(n³)は3重ループの場合を表します。O(n³)も効率が悪いですが、O(2^n)ほど爆発的ではありません。例えば、n=100の場合、O(n³)では100万回（100³）の処理ですが、O(2^n)では約10^30回（2^100）の処理が必要で、宇宙の年齢より長い時間がかかります。O(n²)以下のアルゴリズムは実用的ですが、O(2^n)のアルゴリズムは、nが少し大きくなると実行不可能になります。"
    }
  ]
}
