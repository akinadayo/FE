{
  "topicId": "tech-4-3-3",
  "title": "探索アルゴリズム",
  "questions": [
    {
      "id": "tech-4-3-3-q1",
      "type": "multiple_choice",
      "question": "配列[10, 25, 3, 47, 16, 32, 8]から値16を線形探索で探す場合、比較回数として正しいものはどれですか？",
      "options": [
        "3回",
        "4回",
        "5回",
        "7回"
      ],
      "correctAnswer": 2,
      "explanation": "「5回」が正しいです。線形探索（逐次探索）は、配列の先頭から順番に目的の値と比較していく探索方法です。配列[10, 25, 3, 47, 16, 32, 8]から値16を探す場合、①インデックス0（値10）と16を比較 → 不一致、②インデックス1（値25）と16を比較 → 不一致、③インデックス2（値3）と16を比較 → 不一致、④インデックス3（値47）と16を比較 → 不一致、⑤インデックス4（値16）と16を比較 → 一致！、という流れになります。したがって、比較回数は5回です。線形探索は、データが未整列でも使用でき、最もシンプルな探索方法ですが、データ数が多いと比較回数が増えるため、効率が悪くなります。選択肢①3回、②4回、④7回は、比較回数が間違っています。"
    },
    {
      "id": "tech-4-3-3-q2",
      "type": "multiple_choice",
      "question": "整列済み配列[3, 8, 10, 16, 25, 32, 47]から値25を2分探索で探す場合、比較回数として正しいものはどれですか？",
      "options": [
        "1回",
        "2回",
        "3回",
        "4回"
      ],
      "correctAnswer": 2,
      "explanation": "「3回」が正しいです。2分探索（二分探索）は、整列済みの配列を2分割しながら探索する方法です。配列[3, 8, 10, 16, 25, 32, 47]から値25を探す場合、①探索範囲: インデックス0～6（全体）、中央のインデックス: (0 + 6) ÷ 2 = 3、中央の値: 16、16 < 25（目的の値）→ 右半分を探索、②探索範囲: インデックス4～6（右半分）、中央のインデックス: (4 + 6) ÷ 2 = 5、中央の値: 32、32 > 25（目的の値）→ 左半分を探索、③探索範囲: インデックス4～4、中央のインデックス: (4 + 4) ÷ 2 = 4、中央の値: 25、25 == 25（目的の値）→ 一致！、という流れになります。したがって、比較回数は3回です。2分探索は、整列済みのデータに対して、線形探索より圧倒的に高速ですが、データが整列されている必要があります。選択肢①1回、②2回、④4回は、比較回数が間違っています。"
    },
    {
      "id": "tech-4-3-3-q3",
      "type": "multiple_choice",
      "question": "n=512のデータから2分探索で値を探す場合、最悪の場合の比較回数として正しいものはどれですか？",
      "options": [
        "7回",
        "8回",
        "9回",
        "10回"
      ],
      "correctAnswer": 2,
      "explanation": "「9回」が正しいです。2分探索の最悪の場合の比較回数は、log₂ n回（切り上げ）です。n=512の場合、log₂ 512 = 9（2⁹ = 512）となるため、最悪の場合の比較回数は9回です。2分探索は、配列を2分割しながら探索するため、探索範囲が512 → 256 → 128 → 64 → 32 → 16 → 8 → 4 → 2 → 1、という流れで減少します。最悪の場合（見つからない、または最後に見つかる場合）、探索範囲が1になるまで探索するため、9回の比較が必要です。選択肢①7回は2¹²⁸、②8回は2²⁵⁶、④10回は2¹⁰²⁴の比較回数に対応し、n=512の場合の比較回数として間違っています。2分探索の計算量はO(log n)で、線形探索のO(n)より圧倒的に高速です。"
    },
    {
      "id": "tech-4-3-3-q4",
      "type": "multiple_choice",
      "question": "ハッシュ探索において、ハッシュ関数h(x) = x mod 10で、キー25、35、45を格納した場合、全てのキーが格納されるインデックスとして正しいものはどれですか？",
      "options": [
        "インデックス0、1、2",
        "インデックス5、6、7",
        "インデックス5（全て）",
        "インデックス2、3、4"
      ],
      "correctAnswer": 2,
      "explanation": "「インデックス5（全て）」が正しいです。ハッシュ関数h(x) = x mod 10は、キーxを10で割った余りをインデックスとして計算します。キー25、35、45をハッシュ関数に渡すと、①h(25) = 25 mod 10 = 5、②h(35) = 35 mod 10 = 5、③h(45) = 45 mod 10 = 5、となり、全てのキーがインデックス5に格納されます。これは**衝突（Collision）**と呼ばれ、異なるキーに対してハッシュ関数が同じインデックスを返す状態です。衝突が発生すると、同じ位置に複数のデータを格納できないため、①チェイン法（連鎖法）：同じインデックスに複数のデータをリストで格納、②オープンアドレス法：衝突した場合、次の空いている位置に格納、のいずれかの方法で解決します。この例では、ハッシュ関数の設計が悪く、全てのキーが同じインデックスに衝突してしまい、性能が悪化します（O(n)）。良いハッシュ関数は、キーを均等に分散させる必要があります。選択肢①②④は、計算結果が間違っています。"
    },
    {
      "id": "tech-4-3-3-q5",
      "type": "multiple_choice",
      "question": "ハッシュ探索において、ハッシュテーブルのサイズが100で、データ数が80の場合、負荷率として正しいものはどれですか？",
      "options": [
        "0.6",
        "0.7",
        "0.8",
        "1.0"
      ],
      "correctAnswer": 2,
      "explanation": "「0.8」が正しいです。ハッシュ探索における**負荷率（Load Factor）**は、データ数 ÷ ハッシュテーブルのサイズ、で計算されます。ハッシュテーブルのサイズが100で、データ数が80の場合、負荷率 = 80 ÷ 100 = 0.8となります。負荷率は、ハッシュテーブルの使用率を表し、負荷率が高いほど衝突が多発し、性能が低下します。一般的には、負荷率を0.7以下に保つことが推奨されます。負荷率が1.0を超えると、全てのデータが衝突し、最悪の場合O(n)の探索時間がかかります。負荷率が高くなったら、ハッシュテーブルのサイズを拡大し、全てのデータを再配置（リハッシュ）することで、性能を維持します。選択肢①0.6は負荷率が低すぎる、②0.7は負荷率の推奨値、④1.0は負荷率が高すぎる、という計算結果です。"
    },
    {
      "id": "tech-4-3-3-q6",
      "type": "multiple_choice",
      "question": "次の2分探索木において、値17を探索する場合の探索経路として正しいものはどれですか？\n\n       20\n      /  \\\n     10   30\n    / \\   / \\\n   5  15 25  35\n      \\\n       17",
      "options": [
        "20 → 10 → 15",
        "20 → 10 → 15 → 17",
        "20 → 30 → 25 → 17",
        "20 → 10 → 5 → 17"
      ],
      "correctAnswer": 1,
      "explanation": "「20 → 10 → 15 → 17」が正しいです。2分探索木（Binary Search Tree）では、各ノードが最大2つの子ノード（左の子、右の子）を持ち、左の子 < 親 < 右の子、という関係が成り立ちます。値17を探索する場合の流れは、①ルート（20）から開始: 17 < 20 → 左の子（10）に移動、②ノード10: 17 > 10 → 右の子（15）に移動、③ノード15: 17 > 15 → 右の子（17）に移動、④ノード17: 17 == 17 → 一致！、となります。したがって、探索経路は「20 → 10 → 15 → 17」で、比較回数は4回です。2分探索木の探索は、平均的にO(log n)の時間がかかりますが、木のバランスが悪い（一直線になる）場合、最悪O(n)になります。選択肢①は探索経路が途中で終わっている、③は右の子から探索している、④は左の子から探索している、という間違いです。"
    },
    {
      "id": "tech-4-3-3-q7",
      "type": "multiple_choice",
      "question": "深さ優先探索（DFS）において使用するデータ構造として正しいものはどれですか？",
      "options": [
        "配列",
        "スタック",
        "キュー",
        "ハッシュテーブル"
      ],
      "correctAnswer": 1,
      "explanation": "「スタック」が正しいです。深さ優先探索（DFS: Depth-First Search）は、できるだけ深く（下に）探索してから、隣の枝を探索する探索方法で、**スタック**（またはデータ構造）を使用します。DFSのアルゴリズムは、①開始ノードをスタックにプッシュ、②スタックからノードをポップし、訪問、③訪問したノードの子ノードをスタックにプッシュ（右の子、左の子の順）、④②～③を繰り返す、という流れです。スタックは後入れ先出し（LIFO: Last In First Out）のデータ構造で、最後に追加したデータを最初に取り出すため、DFSのように深く探索する処理に適しています。また、DFSは再帰関数でも実装できます（再帰のコールスタックがスタックの役割を果たす）。選択肢①配列は一般的なデータ構造、③キューは幅優先探索（BFS）で使用、④ハッシュテーブルはハッシュ探索で使用、という違いがあります。"
    },
    {
      "id": "tech-4-3-3-q8",
      "type": "multiple_choice",
      "question": "次の木において、幅優先探索（BFS）で探索した場合の訪問順序として正しいものはどれですか？\n\n       A\n      / \\\n     B   C\n    / \\   \\\n   D   E   F",
      "options": [
        "A → B → D → E → C → F",
        "A → B → C → D → E → F",
        "A → C → F → B → D → E",
        "A → D → E → B → F → C"
      ],
      "correctAnswer": 1,
      "explanation": "「A → B → C → D → E → F」が正しいです。幅優先探索（BFS: Breadth-First Search）は、同じ階層（同じ深さ）のノードを全て探索してから、次の階層を探索する探索方法で、**キュー**を使用します。BFSのアルゴリズムは、①開始ノード（A）をキューにエンキュー、②キューからノードをデキューし、訪問（A）、③訪問したノードの子ノード（B、C）をキューにエンキュー、④②～③を繰り返す、という流れです。具体的な訪問順序は、①A（第1階層）、②B、C（第2階層、Aの子）、③D、E（第3階層、Bの子）、④F（第3階層、Cの子）、となります。したがって、訪問順序は「A → B → C → D → E → F」です。BFSは、最短経路の探索（同じ階層を先に探索）に適しています。選択肢①は深さ優先探索（DFS）の訪問順序、③④は間違った訪問順序です。"
    },
    {
      "id": "tech-4-3-3-q9",
      "type": "multiple_choice",
      "question": "n=10,000のデータから、線形探索と2分探索で値を探す場合、平均比較回数の差として最も近いものはどれですか？",
      "options": [
        "約50回",
        "約500回",
        "約5,000回",
        "約10,000回"
      ],
      "correctAnswer": 2,
      "explanation": "「約5,000回」が正しいです。線形探索の平均比較回数はn/2回、2分探索の平均比較回数はlog₂ n回です。n=10,000の場合、①線形探索の平均比較回数: 10,000 ÷ 2 = 5,000回、②2分探索の平均比較回数: log₂ 10,000 ≈ 13.29 → 約13～14回、となります。したがって、平均比較回数の差は、5,000 - 14 ≈ 4,986回、となり、約5,000回が最も近い値です。2分探索は、線形探索より圧倒的に高速ですが、データが整列済みである必要があります。データの整列にはO(n log n)の時間がかかるため、探索頻度が低い場合（1回だけ探索）は、線形探索の方が効率的な場合もあります。選択肢①約50回、②約500回、④約10,000回は、平均比較回数の差として間違っています。"
    },
    {
      "id": "tech-4-3-3-q10",
      "type": "multiple_choice",
      "question": "次のシステムのうち、ハッシュ探索を使用するのに最も適しているものはどれですか？",
      "options": [
        "小規模なデータ（100件以下）を1回だけ探索する",
        "大規模なデータ（100万件）を頻繁に探索する（1秒間に1万回）が、メモリに余裕がない",
        "大規模なデータ（100万件）を頻繁に探索する（1秒間に1万回）、メモリに余裕がある",
        "整列済みのデータを1回だけ探索する"
      ],
      "correctAnswer": 2,
      "explanation": "「大規模なデータ（100万件）を頻繁に探索する（1秒間に1万回）、メモリに余裕がある」が正しいです。ハッシュ探索は、平均O(1)で探索できるため、探索頻度が超高い場合に最も適しています。大規模なデータ（100万件）を頻繁に探索する（1秒間に1万回）場合、2分探索では1回の探索にlog₂ 1,000,000 ≈ 20回の比較が必要で、1秒間に20万回の比較が必要です。ハッシュ探索では、衝突がない場合、1回の探索に1回の計算で済むため、1秒間に1万回の計算で済みます。ただし、ハッシュ探索にはハッシュテーブル（配列）が必要で、メモリを多く消費します。メモリに余裕がある場合、ハッシュ探索が最適です。選択肢①小規模なデータは線形探索で十分、②メモリに余裕がない場合は2分探索が適している、④1回だけ探索する場合は線形探索で十分、という理由で、ハッシュ探索に適していません。"
    }
  ]
}
