{
  "topicId": "tech-2-3-6",
  "title": "プログラムの性質",
  "questions": [
    {
      "id": "tech-2-3-6-q1",
      "type": "multiple_choice",
      "question": "リロケータブルプログラム（再配置可能プログラム）の説明として正しいものはどれですか？",
      "options": [
        "実行後、再度ディスクから読み込むことなく、繰り返し実行できるプログラム",
        "メモリのどの位置に配置しても正しく実行できるプログラム",
        "複数のプログラムから同時に呼び出しても正しく動作するプログラム",
        "関数が自分自身を呼び出せるプログラム"
      ],
      "correctAnswer": 1,
      "explanation": "「メモリのどの位置に配置しても正しく実行できるプログラム」が正しいです。リロケータブルプログラム（Relocatable Program）は、絶対アドレス（固定されたメモリアドレス）ではなく、相対アドレス（プログラムの先頭からの相対的な位置）を使ってメモリにアクセスします。OSがプログラムをメモリの任意の位置に配置できるため、メモリの空き領域を柔軟に利用できます。例えば、ベースレジスタにプログラムの先頭アドレスを設定し、変数Aを「BASE + 0x100」という相対アドレスで参照することで、プログラムがアドレス0x10000000に配置されても0x20000000に配置されても、正しく動作します。選択肢①は再使用可能（Reusable）、③は再入可能（Reentrant）、④は再帰的（Recursive）の説明です。"
    },
    {
      "id": "tech-2-3-6-q2",
      "type": "multiple_choice",
      "question": "リロケータブルプログラムが相対アドレスを使う方法として正しいものはどれですか？",
      "options": [
        "変数Aを「0x10000100」という絶対アドレスで参照する",
        "変数Aを「BASE + 0x100」という相対アドレスで参照し、BASEレジスタにプログラムの先頭アドレスを設定する",
        "変数Aを「スタックポインタ + 0x100」というアドレスで参照する",
        "変数Aを「ヒープ領域の先頭 + 0x100」というアドレスで参照する"
      ],
      "correctAnswer": 1,
      "explanation": "「変数Aを「BASE + 0x100」という相対アドレスで参照し、BASEレジスタにプログラムの先頭アドレスを設定する」が正しいです。リロケータブルプログラムでは、ベースレジスタ（BASEレジスタ）にプログラムの先頭アドレスを設定し、変数や命令を「BASE + オフセット」という相対アドレスで参照します。例えば、プログラムがアドレス0x10000000に配置された場合、BASEレジスタ = 0x10000000、変数Aのアドレス = 0x10000000 + 0x100 = 0x10000100となります。プログラムがアドレス0x20000000に配置された場合は、BASEレジスタ = 0x20000000、変数Aのアドレス = 0x20000000 + 0x100 = 0x20000100となり、どちらの場合も正しく変数Aを参照できます。選択肢①は絶対アドレスを使う方法で、リロケータブルではありません。選択肢③④は局所変数やヒープ変数の参照方法です。"
    },
    {
      "id": "tech-2-3-6-q3",
      "type": "multiple_choice",
      "question": "リユーザブルプログラム（再使用可能プログラム）の利点として正しいものはどれですか？",
      "options": [
        "メモリのどの位置に配置しても実行できる",
        "複数のプログラムから同時に呼び出しても正しく動作する",
        "実行後、再度ディスクから読み込むことなく繰り返し実行でき、メモリとディスクアクセスを節約できる",
        "関数が自分自身を呼び出せる"
      ],
      "correctAnswer": 2,
      "explanation": "「実行後、再度ディスクから読み込むことなく繰り返し実行でき、メモリとディスクアクセスを節約できる」が正しいです。リユーザブルプログラム（Reusable Program）は、実行中にコード部分（命令）を変更せず、データ部分だけを変更します。実行が終了すると、データ部分を初期状態に戻すことで、再度実行できます。リユーザブルプログラムの利点は、①メモリ節約：同じプログラムを複数回実行する場合、1回だけメモリに読み込めばよい、②ディスクアクセスの削減：再度読み込む必要がない、です。例えば、電卓プログラムを10回実行する場合、リユーザブルであれば1回だけメモリに読み込めばよく、メモリとディスクアクセスを節約できます。選択肢①は再配置可能（Relocatable）、②は再入可能（Reentrant）、④は再帰的（Recursive）の説明です。"
    },
    {
      "id": "tech-2-3-6-q4",
      "type": "multiple_choice",
      "question": "リユーザブルプログラムの条件として正しいものはどれですか？",
      "options": [
        "実行中にコード部分（命令）を変更してもよい",
        "実行中にコード部分（命令）を変更せず、データ部分だけを変更する",
        "実行中にコード部分とデータ部分の両方を変更する",
        "実行中にコード部分もデータ部分も変更しない"
      ],
      "correctAnswer": 1,
      "explanation": "「実行中にコード部分（命令）を変更せず、データ部分だけを変更する」が正しいです。リユーザブルプログラムは、コード部分（命令、例: LOAD R1, [BASE + 0x100]）を変更しないため、実行後もコード部分は初期状態のまま残ります。一方、データ部分（例: 変数、カウンタ）は実行中に変更されますが、実行が終了すると初期状態に戻します。これにより、プログラムを再度ディスクから読み込むことなく、繰り返し実行できます。選択肢①のように実行中にコード部分を変更すると、実行後にコード部分が初期状態でなくなり、再度実行できなくなります（自己書き換えプログラム）。選択肢③④はリユーザブルプログラムの条件を満たしません。"
    },
    {
      "id": "tech-2-3-6-q5",
      "type": "multiple_choice",
      "question": "リエントラントプログラム（再入可能プログラム）の説明として正しいものはどれですか？",
      "options": [
        "メモリのどの位置に配置しても実行できるプログラム",
        "実行後、再度読み込むことなく繰り返し実行できるプログラム",
        "複数のプログラム（スレッド）から同時に呼び出しても、各プログラムが独立したデータ領域を持つため、正しく動作するプログラム",
        "関数が自分自身を呼び出せるプログラム"
      ],
      "correctAnswer": 2,
      "explanation": "「複数のプログラム（スレッド）から同時に呼び出しても、各プログラムが独立したデータ領域を持つため、正しく動作するプログラム」が正しいです。リエントラントプログラム（Reentrant Program）は、コード部分は共有しますが、データ部分は各プログラム（スレッド）ごとに独立した領域（スタック）に配置します。これにより、複数のプログラムから同時に呼び出しても、互いに干渉せず、正しく動作します。例えば、共有ライブラリ（DLL、.so）は、複数のプログラムから同時に呼び出されるため、リエントラントである必要があります。具体例として、sqrt関数（平方根を計算する関数）がリエントラントであれば、プログラムAとプログラムBが同時にsqrt関数を呼び出しても、それぞれ独立したスタックに引数と戻り値が保存されるため、正しく動作します。選択肢①は再配置可能（Relocatable）、②は再使用可能（Reusable）、④は再帰的（Recursive）の説明です。"
    },
    {
      "id": "tech-2-3-6-q6",
      "type": "multiple_choice",
      "question": "リエントラントプログラムが複数のプログラムから同時に呼び出されても正しく動作する仕組みとして正しいものはどれですか？",
      "options": [
        "コード部分とデータ部分の両方を各プログラムごとにコピーする",
        "コード部分は共有し、データ部分は各プログラムごとに独立した領域（スタック）に配置する",
        "コード部分とデータ部分の両方を共有する",
        "コード部分は各プログラムごとにコピーし、データ部分は共有する"
      ],
      "correctAnswer": 1,
      "explanation": "「コード部分は共有し、データ部分は各プログラムごとに独立した領域（スタック）に配置する」が正しいです。リエントラントプログラムでは、コード部分（命令、例: sqrt関数のコード）は1つだけメモリに配置され、複数のプログラムで共有します。一方、データ部分（引数、戻り値、ローカル変数）は、各プログラム（スレッド）ごとに独立したスタック領域に配置します。例えば、プログラムAがsqrt(4.0)を呼び出し、プログラムBがsqrt(9.0)を呼び出した場合、コード部分（sqrt関数の命令）は共有されますが、引数4.0はプログラムAのスタックに、引数9.0はプログラムBのスタックに保存されます。このため、互いに干渉せず、プログラムAは2.0、プログラムBは3.0という正しい戻り値を得られます。選択肢①④のようにコード部分をコピーするとメモリの無駄遣いになり、選択肢③のようにデータ部分を共有すると、複数のプログラムが互いに干渉してしまいます。"
    },
    {
      "id": "tech-2-3-6-q7",
      "type": "multiple_choice",
      "question": "リカーシブプログラム（再帰的プログラム）の説明として正しいものはどれですか？",
      "options": [
        "メモリのどの位置に配置しても実行できるプログラム",
        "実行後、再度読み込むことなく繰り返し実行できるプログラム",
        "複数のプログラムから同時に呼び出しても正しく動作するプログラム",
        "関数が自分自身を呼び出せるプログラム"
      ],
      "correctAnswer": 3,
      "explanation": "「関数が自分自身を呼び出せるプログラム」が正しいです。リカーシブプログラム（Recursive Program）は、関数が自分自身を呼び出す再帰呼び出しができるプログラムです。再帰呼び出しを実現するには、関数の引数、戻り値、ローカル変数をスタックに保存する必要があります。例えば、階乗を計算する関数 factorial(n) は、factorial(n) = n × factorial(n-1) という再帰的な定義を使って実装できます。factorial(5) → factorial(4) → factorial(3) → factorial(2) → factorial(1) という順に呼び出され、各呼び出しの引数nと戻り値がスタックに保存されます。リカーシブプログラムは、階乗、フィボナッチ数列、クイックソート、二分探索木の探索など、再帰アルゴリズムの実装に必須です。選択肢①は再配置可能（Relocatable）、②は再使用可能（Reusable）、③は再入可能（Reentrant）の説明です。"
    },
    {
      "id": "tech-2-3-6-q8",
      "type": "multiple_choice",
      "question": "次のプログラムのうち、リエントラントである必要があるものはどれですか？",
      "options": [
        "1つのプログラムからのみ呼び出されるアプリケーション固有の関数",
        "複数のプログラムから同時に呼び出される共有ライブラリ（DLL、.so）の関数",
        "シングルスレッドのプログラム",
        "データベースファイル（排他ロックで保護されている）"
      ],
      "correctAnswer": 1,
      "explanation": "「複数のプログラムから同時に呼び出される共有ライブラリ（DLL、.so）の関数」が正しいです。共有ライブラリ（例: math.dll, libc.so）は、複数のプログラムから同時に呼び出されるため、リエントラント（再入可能）である必要があります。例えば、プログラムAとプログラムBが同時にsqrt関数（平方根を計算する関数）を呼び出す場合、sqrt関数のコード部分は共有されますが、データ部分（引数、戻り値）は各プログラムごとに独立したスタックに配置されるため、互いに干渉しません。また、マルチスレッド環境では、複数のスレッドから同時に呼び出される関数もリエントラントである必要があります。選択肢①③は1つのプログラムからのみ呼び出されるため、リエントラントである必要はありません。選択肢④は排他ロックで保護されているため、同時アクセスは発生しません。"
    },
    {
      "id": "tech-2-3-6-q9",
      "type": "multiple_choice",
      "question": "プログラムの性質の組み合わせとして正しいものはどれですか？",
      "options": [
        "リエントラントプログラムは必ずリユーザブルでもある",
        "リロケータブルプログラムは必ずリエントラントでもある",
        "リエントラントプログラムは必ずリロケータブルである必要はない（独立した性質）",
        "リカーシブプログラムは必ずリユーザブルでもある"
      ],
      "correctAnswer": 0,
      "explanation": "「リエントラントプログラムは必ずリユーザブルでもある」が正しいです。リエントラント（再入可能）プログラムは、実行中にコード部分を変更しないため、自動的にリユーザブル（再使用可能）でもあります。リエントラントプログラムはコード部分を共有し、データ部分だけを各プログラムごとに独立したスタックに配置するため、実行後もコード部分は初期状態のまま残り、再度実行できます。選択肢②「リロケータブルプログラムは必ずリエントラントでもある」は誤りです。リロケータブル（再配置可能）は「メモリのどの位置に配置しても実行できる」という性質で、リエントラント（複数のプログラムから同時に呼び出しても正しく動作する）とは独立した性質です。選択肢③④も誤りです。プログラムの4つの性質（リロケータブル、リユーザブル、リエントラント、リカーシブ）は、基本的に独立した性質ですが、リエントラント⊆リユーザブルという包含関係があります。"
    },
    {
      "id": "tech-2-3-6-q10",
      "type": "multiple_choice",
      "question": "現在のOSにおけるリロケーションの実現方法として正しいものはどれですか？",
      "options": [
        "プログラムは常に固定されたアドレス（例: 0x10000000～）に配置される",
        "仮想記憶を使い、プログラムは常に同じ仮想アドレス（例: 0x00000000～）から始まるように見え、リロケーションは物理アドレスレベルで自動的に行われる",
        "プログラムは常にスタック領域に配置される",
        "プログラムは常にヒープ領域に配置される"
      ],
      "correctAnswer": 1,
      "explanation": "「仮想記憶を使い、プログラムは常に同じ仮想アドレス（例: 0x00000000～）から始まるように見え、リロケーションは物理アドレスレベルで自動的に行われる」が正しいです。現在のOSでは、仮想記憶（仮想メモリ、Virtual Memory）を使うため、各プログラムは独立した仮想アドレス空間を持ち、常に同じ仮想アドレス（例: 0x00000000～）から始まるように見えます。OSとMMU（Memory Management Unit、メモリ管理ユニット）が、仮想アドレスを物理アドレスに変換します。例えば、プログラムAとプログラムBがともに仮想アドレス0x00001000を参照しても、MMUは仮想アドレス0x00001000をプログラムAでは物理アドレス0x10001000に、プログラムBでは物理アドレス0x20001000に変換します。このため、プログラム開発者はリロケーションを意識する必要がなく、OSとMMUが自動的にリロケーションを行います。選択肢①③④は誤りです。"
    }
  ]
}
