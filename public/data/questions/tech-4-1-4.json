{
  "topicId": "tech-4-1-4",
  "title": "テスト技法",
  "questions": [
    {
      "id": "tech-4-1-4-q1",
      "type": "multiple_choice",
      "question": "次のプログラムに対して、命令網羅（C0）を100%満たすために必要な最小のテストケース数はどれですか？\n\n```\n1: function checkAge(age) {\n2:     if (age >= 18) {\n3:         return \"成人\"\n4:     } else {\n5:         return \"未成年\"\n6:     }\n7: }\n```",
      "options": [
        "1つ（例: age=20）",
        "2つ（例: age=20, age=15）",
        "3つ（例: age=17, age=18, age=19）",
        "4つ（例: age=0, age=17, age=18, age=100）"
      ],
      "correctAnswer": 0,
      "explanation": "「1つ（例: age=20）」が正しいです。命令網羅（C0、ステートメントカバレッジ）は、全ての命令（文）を最低1回実行することが目標です。このプログラムには、1～6行目の6つの命令があります。テストケース age=20 を実行すると、1→2→3→7の4行が実行されます。しかし、命令網羅では「全ての行が実行される」ことが目標なので、4行目と5行目（else の中）が実行されていなくても、問題ありません。実は、このプログラムでは、age=20 のテストケース1つで、if文の真の経路（3行目）が実行され、全ての命令が実行されているため、命令網羅100%と判定されます。ただし、これは命令網羅の問題点で、if文の偽の経路（5行目）がテストされていないため、バグを見逃すリスクがあります。実際には、判定条件網羅（C1）を満たすために、age=20（真）とage=15（偽）の2つのテストケースが推奨されます。選択肢②は判定条件網羅を満たすテストケース数、③④は境界値分析を含むテストケース数です。"
    },
    {
      "id": "tech-4-1-4-q2",
      "type": "multiple_choice",
      "question": "次のプログラムに対して、判定条件網羅（C1）を100%満たすために必要な最小のテストケース数はどれですか？\n\n```\n1: function calculateDiscount(price, isMember) {\n2:     discount = 0\n3:     if (isMember && price >= 5000) {\n4:         discount = price * 0.1\n5:     }\n6:     return price - discount\n7: }\n```",
      "options": [
        "1つ（例: price=6000, isMember=true）",
        "2つ（例: price=6000 isMember=true、price=3000 isMember=false）",
        "3つ（例: price=6000 isMember=true、price=3000 isMember=true、price=6000 isMember=false）",
        "4つ（例: price=6000 isMember=true、price=6000 isMember=false、price=3000 isMember=true、price=3000 isMember=false）"
      ],
      "correctAnswer": 1,
      "explanation": "「2つ（例: price=6000 isMember=true、price=3000 isMember=false）」が正しいです。判定条件網羅（C1、ブランチカバレッジ）は、全ての判定（if文、while文など）で真と偽の両方を実行することが目標です。このプログラムでは、3行目のif文の判定「isMember && price >= 5000」が、真と偽の両方を実行される必要があります。テストケース1: price=6000, isMember=true → 判定は真（isMember=true かつ price>=5000=true → true && true = true）→ 4行目を実行。テストケース2: price=3000, isMember=false → 判定は偽（isMember=false かつ price>=5000=false → false && false = false）→ 4行目をスキップ。この2つのテストケースで、判定の真と偽の両方を実行できるため、判定条件網羅100%を達成できます。選択肢①は命令網羅を満たすテストケース数（判定の偽が実行されない）、③④は条件網羅（C2）に近いテストケース数です。条件網羅を100%満たすには、isMember と price >= 5000 の両方で真と偽を実行する必要があるため、4つのテストケースが必要です。"
    },
    {
      "id": "tech-4-1-4-q3",
      "type": "multiple_choice",
      "question": "ホワイトボックステストに関する説明として、正しいものはどれですか？",
      "options": [
        "プログラムの内部構造を知らずに、仕様書に基づいて、入力と出力が正しいかを検証するテスト技法",
        "プログラムの内部構造（ソースコード）を理解した上で、コードの全ての経路が実行されるかを検証するテスト技法",
        "複数の条件の組み合わせを表形式で整理し、全ての組み合わせに対する動作を定義するテスト技法",
        "プログラムを修正した後、修正によって既存の機能に悪影響がないかを確認するテスト技法"
      ],
      "correctAnswer": 1,
      "explanation": "「プログラムの内部構造（ソースコード）を理解した上で、コードの全ての経路が実行されるかを検証するテスト技法」が正しいです。ホワイトボックステスト（White Box Test）は、プログラムの内部構造（ソースコード）を理解した上で、コードの全ての経路が実行されるかを検証するテスト技法で、別名「構造テスト」「ガラス箱テスト」とも呼ばれます。主に単体テストで使用され、開発者（プログラマ）が実施します。ホワイトボックステストでは、カバレッジ（Coverage）という指標でテストの網羅性を測定します（命令網羅、判定条件網羅、条件網羅）。選択肢①はブラックボックステストの説明、③はデシジョンテーブル（決定表）の説明、④は回帰テスト（リグレッションテスト）の説明です。"
    },
    {
      "id": "tech-4-1-4-q4",
      "type": "multiple_choice",
      "question": "次の仕様に対して、同値分割法を適用した場合、テストケース数はいくつになりますか？\n\n【仕様】\n商品価格により送料が決定される。\n- 0～2,999円: 送料800円\n- 3,000～4,999円: 送料500円\n- 5,000円以上: 送料無料（0円）\n- 負の数: エラー（「無効な価格」と表示）",
      "options": [
        "3つ（各価格帯から代表値を1つずつ選ぶ）",
        "4つ（各価格帯から代表値を1つずつ選び、エラーケースも含める）",
        "7つ（境界値とその前後の値を選ぶ）",
        "8つ（全ての境界値を選ぶ）"
      ],
      "correctAnswer": 1,
      "explanation": "「4つ（各価格帯から代表値を1つずつ選び、エラーケースも含める）」が正しいです。同値分割法は、入力値を同じ結果になるグループ（同値クラス）に分割し、各グループから代表値を1つ選んでテストする技法です。この仕様では、有効同値クラスが3つ（①0～2,999円、②3,000～4,999円、③5,000円以上）、無効同値クラスが1つ（④負の数）あります。各クラスから代表値を1つずつ選ぶと、①1,500円（送料800円）、②4,000円（送料500円）、③10,000円（送料無料）、④-100円（エラー）の4つのテストケースになります。同値分割法では、有効同値クラスだけでなく、無効同値クラス（エラーケース）も必ずテストする必要があります。選択肢①はエラーケースを含めていない、③④は境界値分析のテストケース数です。実際のプロジェクトでは、同値分割法と境界値分析を併用します。"
    },
    {
      "id": "tech-4-1-4-q5",
      "type": "multiple_choice",
      "question": "境界値分析に関する説明として、正しいものはどれですか？",
      "options": [
        "入力値を同じ結果になるグループに分割し、各グループから代表値を1つ選んでテストする技法",
        "同値クラスの境界値（最小値、最大値、境界の前後の値）を重点的にテストする技法",
        "複数の条件の組み合わせを表形式で整理し、全ての組み合わせに対する動作を定義する技法",
        "プログラムの内部構造を理解した上で、コードの全ての経路が実行されるかを検証する技法"
      ],
      "correctAnswer": 1,
      "explanation": "「同値クラスの境界値（最小値、最大値、境界の前後の値）を重点的にテストする技法」が正しいです。境界値分析（Boundary Value Analysis）は、同値クラスの境界値（最小値、最大値、境界の前後の値）を重点的にテストする技法です。経験上、バグは境界値付近で発生しやすいため（例: 不等号の間違い、オフバイワンエラー）、境界値分析により、バグを効率的に発見できます。境界値分析では、境界値、境界値-1、境界値+1の3つの値をテストします。例えば、「0～5歳は無料、6～17歳は1,000円」という仕様の場合、境界値は0、5、6、17で、テストする値は-1、0、5、6、17、18になります。境界値分析は、同値分割法と併用するのが一般的です。選択肢①は同値分割法の説明、③はデシジョンテーブルの説明、④はホワイトボックステストの説明です。"
    },
    {
      "id": "tech-4-1-4-q6",
      "type": "multiple_choice",
      "question": "次の仕様に対して、境界値分析を適用した場合、テストする値として最も適切なものはどれですか？\n\n【仕様】\n年齢により入場料金が決定される。\n- 0～5歳: 無料（0円）\n- 6～17歳: 子供料金（1,000円）\n- 18～64歳: 大人料金（1,800円）\n- 65歳以上: シニア料金（1,200円）\n- 負の数、126歳以上: エラー",
      "options": [
        "3歳、12歳、30歳、70歳（各同値クラスの代表値）",
        "0歳、6歳、18歳、65歳（各同値クラスの最小値）",
        "-1歳、0歳、5歳、6歳、17歳、18歳、64歳、65歳、125歳、126歳（境界値とその前後）",
        "0歳、5歳、6歳、17歳、18歳、64歳、65歳、125歳（境界値のみ）"
      ],
      "correctAnswer": 2,
      "explanation": "「-1歳、0歳、5歳、6歳、17歳、18歳、64歳、65歳、125歳、126歳（境界値とその前後）」が正しいです。境界値分析では、境界値とその前後の値（境界値-1、境界値、境界値+1）を重点的にテストします。この仕様では、境界値は0、5、6、17、18、64、65、125です。境界値分析では、これらの境界値に加えて、境界の前後の値（-1、126）もテストします。これにより、境界付近のバグ（例: 「18歳が子供料金になる」「65歳が大人料金になる」「0歳がエラーになる」）を発見できます。特に、プログラムで不等号（>=、>、<=、<）を間違えた場合、境界値でバグが発生します。選択肢①は同値分割法の代表値、②は境界値のみ（前後の値を含まない）、④は境界値のみ（無効同値クラスの境界を含まない）です。実際のプロジェクトでは、同値分割法（代表値）と境界値分析（境界値とその前後）を併用します。"
    },
    {
      "id": "tech-4-1-4-q7",
      "type": "multiple_choice",
      "question": "デシジョンテーブル（決定表）に関する説明として、正しいものはどれですか？",
      "options": [
        "プログラムの内部構造を理解した上で、コードの全ての経路が実行されるかを検証する技法",
        "入力値を同じ結果になるグループに分割し、各グループから代表値を1つ選んでテストする技法",
        "複数の条件の組み合わせを表形式で整理し、全ての組み合わせに対する動作を定義する技法",
        "同値クラスの境界値を重点的にテストする技法"
      ],
      "correctAnswer": 2,
      "explanation": "「複数の条件の組み合わせを表形式で整理し、全ての組み合わせに対する動作を定義する技法」が正しいです。デシジョンテーブル（Decision Table、決定表）は、複数の条件の組み合わせを表形式で整理し、全ての組み合わせに対する動作（アクション）を定義する技法です。複雑な条件分岐がある場合、デシジョンテーブルにより、漏れや矛盾を防ぎ、全ての組み合わせを網羅的にテストできます。デシジョンテーブルは、①条件（Condition）：判定する条件（例: 会員？、5,000円以上？、速達配送？）、②アクション（Action）：条件の組み合わせに対する動作（例: 送料無料、送料500円）、③ルール（Rule）：条件とアクションの組み合わせ、の3つで構成されます。デシジョンテーブルは、複数の条件がある場合（例: 会員・非会員、配送方法、価格帯）に使用します。選択肢①はホワイトボックステストの説明、②は同値分割法の説明、④は境界値分析の説明です。"
    },
    {
      "id": "tech-4-1-4-q8",
      "type": "multiple_choice",
      "question": "結合テストにおいて、テスト対象のモジュールが呼び出す下位モジュールの代わりに使用する疑似モジュールを何と呼びますか？",
      "options": [
        "スタブ（Stub）",
        "ドライバ（Driver）",
        "モック（Mock）",
        "フィクスチャ（Fixture）"
      ],
      "correctAnswer": 0,
      "explanation": "「スタブ（Stub）」が正しいです。スタブ（Stub）は、テスト対象のモジュールが呼び出す下位モジュールの代わりに使用する疑似モジュールです。スタブは、固定値を返すだけのシンプルなモジュールで、下位モジュールの実装が完了していない場合や、下位モジュールの準備（例: データベースの準備）が不要な場合に使用します。例えば、商品検索関数が、データベースアクセスモジュール（getProducts）を呼び出す場合、単体テストでは、getProductsの代わりにスタブ（固定値を返す疑似モジュール）を使用し、商品検索関数のロジックのみをテストします。スタブを使用することで、データベースの準備が不要になり、テストを高速化できます。選択肢②ドライバは、テスト対象のモジュールを呼び出す上位モジュールの代わりに使用する疑似モジュール（テストデータを渡す）です。③モックと④フィクスチャは、テストフレームワークで使用される用語ですが、スタブとは異なります。"
    },
    {
      "id": "tech-4-1-4-q9",
      "type": "multiple_choice",
      "question": "トップダウンテストとボトムアップテストに関する説明として、正しいものはどれですか？",
      "options": [
        "トップダウンテストでは、下位モジュールから上位モジュールへ順番に結合し、ドライバを使用する",
        "トップダウンテストでは、上位モジュールから下位モジュールへ順番に結合し、スタブを使用する",
        "ボトムアップテストでは、上位モジュールから下位モジュールへ順番に結合し、スタブを使用する",
        "ボトムアップテストでは、全てのモジュールを同時に結合し、スタブとドライバの両方を使用する"
      ],
      "correctAnswer": 1,
      "explanation": "「トップダウンテストでは、上位モジュールから下位モジュールへ順番に結合し、スタブを使用する」が正しいです。トップダウンテストは、上位モジュール（UI）から下位モジュール（データベースアクセス）へ順番に結合するテスト方法です。上位モジュールから開発できるため、早期に画面を確認できます。トップダウンテストでは、スタブ（下位モジュールの代わりに固定値を返す疑似モジュール）を使用します。ボトムアップテストは、下位モジュール（データベースアクセス）から上位モジュール（UI）へ順番に結合するテスト方法です。下位モジュールから開発できるため、基盤部分の品質を早期に確保できます。ボトムアップテストでは、ドライバ（上位モジュールの代わりにテストデータを渡す疑似モジュール）を使用します。実際のプロジェクトでは、トップダウンテストとボトムアップテストを組み合わせる（サンドイッチテスト）ことが多いです。選択肢①③④は、トップダウンテストとボトムアップテストの説明が間違っています。"
    },
    {
      "id": "tech-4-1-4-q10",
      "type": "multiple_choice",
      "question": "回帰テスト（リグレッションテスト）に関する説明として、正しいものはどれですか？",
      "options": [
        "プログラムの内部構造を理解した上で、コードの全ての経路が実行されるかを検証するテスト",
        "同時アクセス数を増やし、システムが要件を満たすかを確認するテスト",
        "プログラムを修正した後、修正によって既存の機能に悪影響がないかを確認するテスト",
        "実際のユーザー（限定公開）にテストしてもらい、フィードバックを得るテスト"
      ],
      "correctAnswer": 2,
      "explanation": "「プログラムを修正した後、修正によって既存の機能に悪影響がないかを確認するテスト」が正しいです。回帰テスト（Regression Test、リグレッションテスト、退行テスト）は、プログラムを修正（バグ修正、機能追加）した後、修正によって既存の機能に悪影響がないか（デグレードが発生していないか）を確認するテストです。プログラムの一部を修正すると、予期せず別の部分に影響が出ることがあります（デグレード、退行）。回帰テストにより、修正による副作用を発見できます。回帰テストでは、過去に実施したテストケースを再実行します。回帰テストは、毎回同じテストケースを実行するため、手動で実施すると時間がかかります。そのため、テスト自動化ツール（Selenium、JUnit）を使用し、回帰テストを自動化することが推奨されます。特に、アジャイル開発やDevOpsでは、1日に複数回リリースするため、回帰テストの自動化が不可欠です。選択肢①はホワイトボックステストの説明、②は負荷テストの説明、④はβテストの説明です。"
    }
  ]
}
