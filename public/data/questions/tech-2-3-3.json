{
  "topicId": "tech-2-3-3",
  "title": "タスク管理",
  "questions": [
    {
      "id": "tech-2-3-3-q001",
      "type": "multiple_choice",
      "question": "タスク(プロセス)の説明として、最も適切なものはどれか。",
      "options": [
        "OSが管理するプログラムの実行単位",
        "ユーザが投入する処理の単位",
        "CPUが実行する1つの命令",
        "ディスクに保存されているプログラムファイル"
      ],
      "correctAnswer": 0,
      "explanation": "タスク(Task)またはプロセス(Process)は、OSが管理するプログラムの実行単位です。\n\n【タスク/プロセスの定義】\n\n**実行中のプログラム**\n- ディスク上のプログラムファイル(実行ファイル)を実行したもの\n- メモリ上に展開されたプログラム\n- 実行に必要な資源を持つ\n\n**OSの管理単位**\n- OSがスケジューリング、管理する単位\n- CPUの割り当て、メモリ管理の対象\n\n【プロセスの構成要素】\n\n**1. プログラムコード**\n- 実行する命令の列\n- テキストセグメント\n\n**2. データ**\n- プログラムが使用する変数、配列\n- データセグメント、スタック、ヒープ\n\n**3. プロセス制御ブロック(PCB)**\n- プロセスID(PID)\n- プロセス状態(実行可能、実行中、待ち)\n- プログラムカウンタ\n- レジスタの内容\n- メモリ管理情報\n- 入出力状態情報\n- アカウント情報\n\n【ジョブ、プロセス、スレッドの関係】\n\n```\nジョブ(ユーザ視点の処理単位)\n  ├─ プロセス1\n  │   ├─ スレッド1-1\n  │   └─ スレッド1-2\n  └─ プロセス2\n      └─ スレッド2-1\n```\n\n**ジョブ > プロセス > スレッド**\n\n- **ジョブ**:ユーザが依頼する処理全体\n- **プロセス**:OSが管理する実行単位\n- **スレッド**:プロセス内の実行単位(軽量プロセス)\n\n【プロセスとプログラムの違い】\n\n**プログラム**\n- ディスク上の実行ファイル\n- 静的(static)\n- 受動的(passive)\n- 例:notepad.exe\n\n**プロセス**\n- 実行中のプログラム\n- 動的(dynamic)\n- 能動的(active)\n- 例:実行中のメモ帳(PID 1234)\n\n【プロセスの特徴】\n\n**1. 独立性**\n- 各プロセスは独立したメモリ空間を持つ\n- 他のプロセスのメモリに直接アクセスできない\n- プロセス間通信(IPC)で連携\n\n**2. 並行実行**\n- 複数のプロセスを並行実行(マルチタスク)\n- CPUを高速に切り替えて実行\n\n**3. リソース所有**\n- CPU時間\n- メモリ空間\n- ファイル、デバイス\n\nプロセス(タスク)は、現代のOSにおける基本的な実行管理単位です。"
    },
    {
      "id": "tech-2-3-3-q002",
      "type": "multiple_choice",
      "question": "プロセスの3つの基本状態として、正しい組み合わせはどれか。",
      "options": [
        "実行状態、実行可能状態、待ち状態",
        "起動状態、実行状態、終了状態",
        "生成状態、実行状態、消滅状態",
        "開始状態、処理状態、完了状態"
      ],
      "correctAnswer": 0,
      "explanation": "プロセス(タスク)は、実行中に状態が遷移します。基本的な3つの状態は:\n\n【1. 実行状態(Running State)】\n- **意味**:CPUを使用して実際に実行されている状態\n- **特徴**:\n  - 命令を実行中\n  - 1つのCPUで同時に1つのプロセスのみ(シングルコアの場合)\n  - マルチコアでは、コア数分のプロセスが実行状態\n\n【2. 実行可能状態(Ready State)】\n- **意味**:実行準備が整い、CPUの割り当てを待っている状態\n- **特徴**:\n  - メモリに読み込まれている\n  - 必要な資源は確保済み\n  - CPUさえ割り当てられれば即座に実行可能\n  - レディキュー(Ready Queue)で待機\n  - ディスパッチ待ち\n\n【3. 待ち状態(Waiting State / Blocked State)】\n- **意味**:入出力完了などのイベント発生を待っている状態\n- **特徴**:\n  - I/O処理の完了待ち\n  - ユーザ入力待ち\n  - ファイルアクセス完了待ち\n  - タイマー待ち\n  - CPUを割り当てても実行できない\n  - イベント完了後、実行可能状態へ遷移\n\n【状態遷移図】\n```\n   [生成]\n      ↓\n  実行可能状態 ←─────┐\n      ↓ディスパッチ    │\n   実行状態        │プリエンプト\n      ↓           │(タイムアウト)\n      ├───────────┘\n      ↓I/O要求\n   待ち状態\n      ↓I/O完了\n  実行可能状態\n      :\n   [終了]\n```\n\n【詳細な状態遷移】\n\n**1. 生成 → 実行可能**\n- プロセス生成時\n- メモリ割り当て、PCB作成\n\n**2. 実行可能 → 実行**\n- ディスパッチ(Dispatch)\n- スケジューラがCPUを割り当て\n\n**3. 実行 → 実行可能**\n- プリエンプション(Preemption:横取り)\n- タイムクォータ(時間切れ)\n- 優先度の高いプロセス出現\n\n**4. 実行 → 待ち**\n- I/O要求(ファイル読み書き、キーボード入力待ちなど)\n- イベント待ち\n- 自発的なCPU解放\n\n**5. 待ち → 実行可能**\n- I/O完了\n- イベント発生\n- 割込み通知\n\n**6. 実行 → 終了**\n- プロセス終了\n- 異常終了\n\n【5状態モデル(拡張版)】\n\n一部のOSでは、さらに詳細に:\n\n1. **新規(New)**:プロセス生成中\n2. **実行可能(Ready)**:CPU待ち\n3. **実行(Running)**:実行中\n4. **待ち(Waiting)**:イベント待ち\n5. **終了(Terminated)**:終了処理中\n\n【重要なポイント】\n\n- 実行可能状態のプロセスは複数存在可能\n- 実行状態のプロセスは限られる(CPU数による)\n- 待ち状態のプロセスも複数存在可能\n- 状態遷移はOSが管理\n\nプロセスの状態管理は、効率的なマルチタスク実現の基盤です。"
    },
    {
      "id": "tech-2-3-3-q003",
      "type": "multiple_choice",
      "question": "ディスパッチャの役割として、最も適切なものはどれか。",
      "options": [
        "実行可能状態のプロセスに実際にCPUを割り当てる",
        "次に実行するプロセスを選択する",
        "プロセスのメモリ領域を管理する",
        "入出力装置との通信を制御する"
      ],
      "correctAnswer": 0,
      "explanation": "タスク管理における「スケジューラ」と「ディスパッチャ」は異なる役割を持ちます:\n\n【ディスパッチャ(Dispatcher)】✓正解\n\n**役割:**\n- 選択されたプロセスに実際にCPUを割り当てる\n- コンテキストスイッチ(文脈切替)を実行\n\n**具体的な処理:**\n1. 現在実行中のプロセスの状態を保存\n   - レジスタの内容\n   - プログラムカウンタ\n   - プロセス状態\n\n2. 次に実行するプロセスの状態を復元\n   - 保存されていたレジスタの内容を復元\n   - プログラムカウンタを復元\n\n3. ユーザモードへ切り替え\n\n4. プロセスの実行を再開\n\n**特徴:**\n- 高速な処理が必要\n- ハードウェアレベルの操作\n- オーバーヘッドを最小限に\n\n【スケジューラ(Scheduler)】\n\n**役割:**\n- 次に実行するプロセスを選択(決定)する\n- スケジューリングアルゴリズムに基づく判断\n\n**具体的な処理:**\n- レディキューから次のプロセスを選択\n- スケジューリングポリシーの適用:\n  - FCFS(先着順)\n  - SJF(最短ジョブ優先)\n  - ラウンドロビン\n  - 優先度スケジューリング\n\n**特徴:**\n- より高レベルの判断\n- アルゴリズムが複雑\n\n【スケジューラとディスパッチャの関係】\n\n```\n[スケジューラ]\n「次はプロセスBを実行しよう」\n      ↓ 決定\n[ディスパッチャ]\n「プロセスAを保存してプロセスBを復元、実行開始!」\n      ↓ 実行\n[プロセスB実行中]\n```\n\n【コンテキストスイッチ(Context Switch)】\n\nディスパッチャが行う文脈切替:\n\n**保存する情報**\n- プログラムカウンタ(PC)\n- 汎用レジスタ\n- スタックポインタ\n- プロセス状態\n- メモリ管理情報\n\n**切替の流れ**\n```\n1. プロセスA実行中\n   ↓\n2. 割込み発生(タイマー、I/O完了など)\n   ↓\n3. カーネルモードへ移行\n   ↓\n4. プロセスAの状態をPCBに保存 ← ディスパッチャ\n   ↓\n5. スケジューラがプロセスBを選択 ← スケジューラ\n   ↓\n6. プロセスBの状態をPCBから復元 ← ディスパッチャ\n   ↓\n7. ユーザモードへ移行\n   ↓\n8. プロセスB実行開始\n```\n\n【ディスパッチレイテンシ(Dispatch Latency)】\n\n- ディスパッチャが実際にプロセスを切り替えるのにかかる時間\n- できるだけ短い方が良い(オーバーヘッド削減)\n- 通常、マイクロ秒〜ミリ秒オーダー\n\n【選択肢の整理】\n\n- **選択肢1(ディスパッチャ)**:CPUを実際に割り当てる ✓\n- **選択肢2(スケジューラ)**:次のプロセスを選択\n- **選択肢3(メモリ管理)**:別の機能\n- **選択肢4(I/O管理)**:別の機能\n\nディスパッチャは、選択されたプロセスに実際にCPUを割り当てる実行部分を担当します。"
    },
    {
      "id": "tech-2-3-3-q004",
      "type": "multiple_choice",
      "question": "マルチプログラミングの説明として、最も適切なものはどれか。",
      "options": [
        "複数のプログラムをメモリに読み込み、CPUを切り替えながら実行することでCPU利用効率を高める",
        "1つのプログラムを複数のCPUで並列実行する",
        "複数のユーザが同時にシステムを使用する",
        "プログラムを複数の部分に分割してメモリに配置する"
      ],
      "correctAnswer": 0,
      "explanation": "マルチプログラミング(Multiprogramming)は、複数のプログラム(プロセス)を同時にメモリに読み込み、CPUを効率的に利用する技術です。\n\n【マルチプログラミングの概念】\n\n**目的:**\n- CPU利用効率の向上\n- システム資源の有効活用\n- スループットの向上\n\n**仕組み:**\n1. 複数のプログラムをメモリに同時に配置\n2. 1つのプログラムがI/O待ちになったら、別のプログラムにCPUを切り替え\n3. CPUの空き時間を削減\n\n【従来の逐次処理との比較】\n\n**逐次処理(シングルプログラミング)**\n```\nプログラムA実行 → I/O待ち(CPU idle) → 完了\n                  ↓\n               CPUが無駄\n```\n\n**マルチプログラミング**\n```\nプログラムA実行 → I/O待ち\n                   ↓\n              プログラムB実行 → I/O待ち\n                                 ↓\n                            プログラムC実行\n                                 :\nCPUが常に稼働\n```\n\n【動作例】\n\n**時刻0:**\n- プログラムA:CPU使用中\n- プログラムB:メモリ待機\n- プログラムC:メモリ待機\n\n**時刻1:**\n- プログラムA:I/O待ち状態へ\n- プログラムB:CPU使用開始 ← CPUを有効活用\n- プログラムC:メモリ待機\n\n**時刻2:**\n- プログラムA:I/O待ち継続\n- プログラムB:I/O待ち状態へ\n- プログラムC:CPU使用開始 ← CPUを有効活用\n\n【マルチプログラミングの利点】\n\n**1. CPU利用率の向上**\n- CPUのアイドル時間を削減\n- 常にどれかのプログラムがCPUを使用\n\n**2. スループットの向上**\n- 単位時間あたりの処理量が増加\n- システム全体の効率化\n\n**3. 資源の有効活用**\n- メモリ、I/Oデバイスの同時利用\n- システムリソースの並行利用\n\n【マルチプログラミングの要件】\n\n**1. メモリ管理**\n- 複数プログラムを同時にメモリ配置\n- メモリ保護機能\n- 仮想記憶の利用\n\n**2. プロセススケジューリング**\n- どのプログラムにCPUを割り当てるか決定\n- 公平性と効率性のバランス\n\n**3. 排他制御**\n- 共有資源へのアクセス制御\n- デッドロックの回避\n\n【関連用語の整理】\n\n**マルチプログラミング(Multiprogramming)**\n- 複数プログラムの並行実行\n- CPU利用効率重視\n- バッチ処理システムで使用される用語\n\n**マルチタスキング(Multitasking)**\n- マルチプログラミングとほぼ同義\n- 対話型システムで使用される用語\n- タイムシェアリングを含む概念\n\n**マルチプロセッシング(Multiprocessing)**\n- 複数のCPU(プロセッサ)を使用\n- 真の並列処理\n- 物理的に複数の処理が同時実行\n\n**タイムシェアリング(Time Sharing)**\n- CPUを細かく時分割して複数ユーザで共有\n- 対話型処理に適する\n- レスポンスタイム重視\n\nマルチプログラミングは、現代のOSの基本機能であり、システムリソースの効率的利用を実現します。"
    },
    {
      "id": "tech-2-3-3-q005",
      "type": "multiple_choice",
      "question": "割込み処理の説明として、最も適切なものはどれか。",
      "options": [
        "実行中のプログラムを一時中断し、別の処理を優先的に実行する仕組み",
        "複数のプログラムを順番に実行する仕組み",
        "メモリ不足時にディスクと入れ替える仕組み",
        "プログラムのエラーを検出する仕組み"
      ],
      "correctAnswer": 0,
      "explanation": "割込み(Interrupt:インタラプト)は、実行中のプログラムを一時中断し、緊急性の高い別の処理を優先的に実行する仕組みです。\n\n【割込みの基本概念】\n\n**目的:**\n- 緊急イベントへの即座の対応\n- 非同期イベントの処理\n- ハードウェアとの効率的な連携\n\n**動作:**\n1. 実行中のプログラムを一時停止\n2. 現在の状態(レジスタ、PC等)を保存\n3. 割込みハンドラ(割込み処理ルーチン)を実行\n4. 割込み処理完了後、元のプログラムに復帰\n\n【割込みの種類】\n\n**1. 外部割込み(ハードウェア割込み)**\n\n**I/O割込み**\n- I/O装置からの完了通知\n- 例:ディスク読み込み完了、プリンタ出力完了\n\n**タイマー割込み**\n- 一定時間経過を通知\n- タイムシェアリング、タスクスケジューリングに使用\n\n**電源異常割込み**\n- 停電、電圧低下の検出\n- 緊急シャットダウン処理\n\n**機械チェック割込み**\n- ハードウェア異常の検出\n\n**2. 内部割込み(ソフトウェア割込み、例外)**\n\n**プログラム割込み**\n- ゼロ除算\n- オーバーフロー\n- 不正命令\n- メモリアクセス違反\n\n**SVC割込み(Supervisor Call)**\n- システムコール\n- OSの機能呼び出し\n- プログラムからOSへのサービス要求\n\n【割込み処理の流れ】\n\n```\n1. プログラムA実行中\n   ↓\n2. 割込み発生(例:I/O完了)\n   ↓\n3. 現在の状態を保存\n   - プログラムカウンタ\n   - レジスタの内容\n   - プロセッサ状態\n   ↓\n4. 割込みベクタから割込みハンドラのアドレス取得\n   ↓\n5. 割込みハンドラ実行\n   - I/O完了処理\n   - データの取り込み\n   - 待ちプロセスを実行可能状態へ\n   ↓\n6. 保存した状態を復元\n   ↓\n7. プログラムAの実行を再開\n```\n\n【割込みの優先度】\n\n複数の割込みが同時発生した場合:\n\n**優先度(高→低)**\n1. 電源異常\n2. 機械チェック\n3. 外部割込み(I/O完了など)\n4. プログラム割込み(例外)\n5. SVC(システムコール)\n\n**割込み禁止・許可**\n- クリティカルな処理中は割込み禁止\n- 多重割込みの制御\n\n【割込みの利点】\n\n**1. 効率的なI/O処理**\n- ポーリング(定期的な状態確認)が不要\n- I/O完了を待つ間、CPUは他の処理を実行可能\n\n**2. リアルタイム性**\n- 緊急イベントに即座に対応\n- 外部イベントへの迅速な応答\n\n**3. タイムシェアリングの実現**\n- タイマー割込みでプロセス切り替え\n- 公平なCPU配分\n\n【ポーリングとの比較】\n\n**ポーリング方式**\n- CPUが定期的にデバイスの状態をチェック\n- CPUリソースの無駄\n- リアルタイム性が低い\n\n**割込み方式**\n- デバイスからCPUに通知\n- CPUリソースの有効活用\n- 即座の対応が可能\n\n【割込みベクタ】\n\n- 割込みの種類ごとに割込みハンドラのアドレスを格納したテーブル\n- メモリの固定アドレスに配置\n- 高速な割込み処理を実現\n\n割込み処理は、効率的なシステム運用とリアルタイム性の実現に不可欠な機構です。"
    },
    {
      "id": "tech-2-3-3-q006",
      "type": "multiple_choice",
      "question": "プリエンプティブ方式のタスクスケジューリングの説明として、最も適切なものはどれか。",
      "options": [
        "OSが強制的にタスクを切り替える方式",
        "タスクが自発的にCPUを譲る方式",
        "優先度の低いタスクから順に実行する方式",
        "すべてのタスクを同時に実行する方式"
      ],
      "correctAnswer": 0,
      "explanation": "タスクスケジューリングには、プリエンプティブ方式とノンプリエンプティブ方式があります:\n\n【プリエンプティブ方式(Preemptive Scheduling)】✓正解\n\n**定義:**\n- OSが強制的にタスクを切り替える(横取り、プリエンプション)\n- 実行中のタスクを中断させることができる\n\n**動作:**\n1. タスクA実行中\n2. タイマー割込み、または高優先度タスク出現\n3. OSがタスクAを強制的に中断\n4. タスクAを実行可能状態へ\n5. 別のタスク(タスクBまたは高優先度タスク)にCPUを割り当て\n\n**切り替えのタイミング:**\n- タイムクォータ(時間切れ):ラウンドロビン\n- 高優先度タスクの出現:優先度スケジューリング\n- I/O待ち状態への遷移\n\n**メリット:**\n- **応答性が高い**:緊急タスクに即座に対応\n- **公平性**:長時間実行タスクが独占しない\n- **対話型システムに適する**:レスポンスタイムが短い\n- **安定性**:暴走タスクを制御可能\n\n**デメリット:**\n- オーバーヘッドが大きい(頻繁なコンテキストスイッチ)\n- 実装が複雑\n\n**例:**\n- Windows、Linux、macOS(現代のOS)\n- リアルタイムOS\n\n【ノンプリエンプティブ方式(Non-preemptive Scheduling)】\n\n**定義:**\n- タスクが自発的にCPUを手放すまで実行継続\n- OSは強制的に中断できない\n- 協調的マルチタスキング(Cooperative Multitasking)\n\n**動作:**\n1. タスクA実行開始\n2. タスクAが自発的にCPU解放するまで継続\n   - I/O要求\n   - 明示的なyield(譲渡)\n   - タスク完了\n3. CPU解放後、次のタスクへ\n\n**メリット:**\n- オーバーヘッドが小さい\n- 実装がシンプル\n- コンテキストスイッチが少ない\n\n**デメリット:**\n- **応答性が低い**:長時間タスクが独占\n- **不公平**:タスクの協調が前提\n- **暴走タスクに弱い**:制御不能になる危険\n- **対話型に不向き**:レスポンスが遅い\n\n**例:**\n- 初期のWindows(3.x)、Mac OS 9以前\n- 一部の組込みシステム\n\n【比較表】\n\n| 項目 | プリエンプティブ | ノンプリエンプティブ |\n|------|------------------|----------------------|\n| CPU切替 | OSが強制 | タスクが自発的 |\n| 応答性 | 高い | 低い |\n| 公平性 | 高い | 低い(協調次第) |\n| オーバーヘッド | 大きい | 小さい |\n| 実装 | 複雑 | 簡単 |\n| 用途 | 汎用OS、RTOS | レガシーシステム |\n| 安定性 | 高い | 低い(暴走の危険) |\n\n【現代のOSでの採用】\n\n**プリエンプティブ方式が主流**\n- Windows NT以降\n- Linux、UNIX\n- macOS(OS X以降)\n- iOS、Android\n\n理由:\n- マルチタスク環境の標準\n- ユーザ体験の向上(レスポンス)\n- システムの安定性・信頼性\n\n【タイムスライス(Time Slice)】\n\nプリエンプティブ方式での各タスクへのCPU割り当て時間:\n- 典型的な値:10〜100ミリ秒\n- タイムクォータ、タイムスライスとも呼ばれる\n- 時間経過でタイマー割込み → プリエンプション\n\nプリエンプティブ方式は、現代の対話型マルチタスクOSの基本です。"
    },
    {
      "id": "tech-2-3-3-q007",
      "type": "multiple_choice",
      "question": "ラウンドロビンスケジューリングの説明として、最も適切なものはどれか。",
      "options": [
        "各タスクに一定時間(タイムクォータ)ずつCPUを割り当て、順番に実行する",
        "実行時間が短いタスクから順に実行する",
        "優先度の高いタスクから順に実行する",
        "先に到着したタスクから順に実行する"
      ],
      "correctAnswer": 0,
      "explanation": "ラウンドロビン(Round Robin:RR)スケジューリングは、タイムシェアリングシステムで使用される代表的なスケジューリングアルゴリズムです。\n\n【ラウンドロビンの基本概念】\n\n**仕組み:**\n- 各タスクに一定時間(タイムクォータ、タイムスライス)を割り当て\n- キューの順番にタスクを実行\n- タイムクォータ経過後、次のタスクへ\n- 実行が完了していないタスクはキューの最後尾へ\n\n**タイムクォータ(Time Quantum):**\n- 各タスクに割り当てる時間\n- 典型的な値:10〜100ミリ秒\n- 適切な値の設定が重要\n\n【動作例】\n\nタイムクォータ = 10ms、3つのタスク(A、B、C)\n\n```\n時刻0-10ms:  タスクA実行\n時刻10-20ms: タスクB実行\n時刻20-30ms: タスクC実行\n時刻30-40ms: タスクA実行(2回目)\n時刻40-50ms: タスクB実行(2回目)\n...\n```\n\n**実行の流れ:**\n```\nレディキュー: [A] → [B] → [C]\n               ↓\n1. タスクA実行(10ms)\n   タイムアウト → キュー最後尾へ\n   \nレディキュー: [B] → [C] → [A]\n               ↓\n2. タスクB実行(10ms)\n   タイムアウト → キュー最後尾へ\n   \nレディキュー: [C] → [A] → [B]\n               ↓\n3. タスクC実行(10ms)\n   ...\n```\n\n【ラウンドロビンの特徴】\n\n**メリット:**\n\n**1. 公平性**\n- すべてのタスクが平等にCPUを使用\n- 特定タスクの独占を防止\n\n**2. 応答性**\n- 対話型タスクに適する\n- レスポンスタイムが予測可能\n- 長時間実行タスクが他を阻害しない\n\n**3. 実装の容易さ**\n- アルゴリズムがシンプル\n- FIFOキューで実現可能\n\n**4. 飢餓(Starvation)なし**\n- すべてのタスクが必ず実行される機会を得る\n\n**デメリット:**\n\n**1. 平均ターンアラウンドタイムが長い**\n- 短いタスクも長く待たされる可能性\n- SJFより非効率\n\n**2. コンテキストスイッチのオーバーヘッド**\n- 頻繁なタスク切り替え\n- タイムクォータが短すぎると効率低下\n\n**3. タイムクォータの選択が難しい**\n- 大きすぎる:FCFSに近づく、応答性低下\n- 小さすぎる:オーバーヘッド増大\n\n【タイムクォータの影響】\n\n**大きい(例:100ms)**\n- コンテキストスイッチが少ない → オーバーヘッド小\n- 応答時間が長い\n- FCFSに近づく\n\n**小さい(例:1ms)**\n- コンテキストスイッチが多い → オーバーヘッド大\n- 応答時間が短い\n- プロセッサシェアリングに近づく\n\n**適切な値:**\n- コンテキストスイッチ時間の10〜100倍程度\n- 典型的:10〜50ms\n\n【他のスケジューリングアルゴリズムとの比較】\n\n**FCFS(First Come First Served)**\n- 到着順に実行\n- 公平だが、短いタスクが長いタスクを待つ問題(コンボイ効果)\n\n**SJF(Shortest Job First)**\n- 最短タスクから実行\n- 平均待ち時間が最小\n- 長いタスクが飢餓状態に\n\n**優先度スケジューリング**\n- 優先度順に実行\n- 重要タスクを優先\n- 低優先度タスクが飢餓状態に\n\n**ラウンドロビン**\n- タイムクォータで順番に実行\n- 公平で応答性が高い\n- 対話型システムに最適\n\n【ラウンドロビンの応用】\n\n**優先度付きラウンドロビン**\n- 複数の優先度キュー\n- 各キュー内でラウンドロビン\n- 優先度が高いキューから実行\n\n**多段フィードバックキュー**\n- 実行時間に応じてキューを移動\n- CPU使用量の多いタスクは優先度低下\n\nラウンドロビンは、対話型マルチタスクシステムで広く使用される基本的なスケジューリング方式です。"
    },
    {
      "id": "tech-2-3-3-q008",
      "type": "multiple_choice",
      "question": "スレッド(Thread)の説明として、最も適切なものはどれか。",
      "options": [
        "プロセス内の実行単位で、プロセスより軽量な並行処理を実現する",
        "プロセスと同じ意味である",
        "複数のCPUを使用する技術",
        "ディスク上のプログラムファイル"
      ],
      "correctAnswer": 0,
      "explanation": "スレッド(Thread:軽量プロセス、LWP:Light Weight Process)は、プロセス内の実行単位で、プロセスより軽量な並行処理を実現します。\n\n【スレッドの概念】\n\n**定義:**\n- プロセス内の独立した実行の流れ\n- プロセスより小さい実行単位\n- 同一プロセス内の複数スレッドはメモリ空間を共有\n\n**プロセスとスレッドの関係:**\n```\nプロセスA\n├─ スレッド1\n├─ スレッド2\n└─ スレッド3\n  ↑\n同じメモリ空間を共有\n```\n\n【プロセス vs スレッド】\n\n**プロセス**\n- 独立したメモリ空間\n- プログラムコード、データ、スタック、ヒープを個別に所有\n- プロセス間通信(IPC)が必要\n- 生成・切り替えのコストが高い\n- 堅牢(1つのプロセス異常が他に波及しにくい)\n\n**スレッド**\n- 同一プロセス内でメモリ空間を共有\n- コード、データ、ヒープは共有\n- スタックのみ個別\n- 簡単にデータ共有可能\n- 生成・切り替えのコストが低い\n- 1つのスレッド異常がプロセス全体に影響\n\n【スレッドの構成】\n\n**独立して持つもの:**\n- スレッドID\n- プログラムカウンタ(PC)\n- レジスタセット\n- スタック\n- スレッド状態\n\n**プロセス内で共有するもの:**\n- プログラムコード\n- データセクション\n- ヒープ\n- ファイルディスクリプタ\n- シグナルハンドラ\n\n【マルチスレッドの利点】\n\n**1. 応答性の向上**\n- 1つのスレッドがブロックしても他が動作\n- 例:Webブラウザで複数タブを並行処理\n\n**2. 資源の共有**\n- メモリ空間を共有\n- プロセス間通信より簡単\n- データ共有が容易\n\n**3. 経済性**\n- スレッド生成はプロセス生成より軽量\n- コンテキストスイッチが高速\n- メモリ使用量が少ない\n\n**4. マルチプロセッサの活用**\n- 複数スレッドを異なるCPUコアで並列実行\n- 真の並列処理が可能\n\n【マルチスレッドの例】\n\n**Webサーバ**\n```\nメインスレッド:接続待ち受け\n  ├─ ワーカースレッド1:クライアント1の処理\n  ├─ ワーカースレッド2:クライアント2の処理\n  └─ ワーカースレッド3:クライアント3の処理\n```\n\n**Webブラウザ**\n```\n├─ UIスレッド:画面描画、ユーザ入力\n├─ ネットワークスレッド:HTTP通信\n├─ レンダリングスレッド:HTML/CSS処理\n└─ JavaScriptスレッド:スクリプト実行\n```\n\n**ワードプロセッサ**\n```\n├─ 入力スレッド:キーボード入力\n├─ 表示スレッド:画面更新\n├─ スペルチェックスレッド:背景でチェック\n└─ 自動保存スレッド:定期的な保存\n```\n\n【スレッドの種類】\n\n**ユーザレベルスレッド**\n- ユーザ空間のライブラリで実装\n- OSはスレッドを認識しない\n- 高速だが、マルチコアを活用できない\n\n**カーネルレベルスレッド**\n- OSカーネルが管理\n- マルチコアを活用可能\n- やや低速だが機能豊富\n\n**ハイブリッド**\n- ユーザレベルとカーネルレベルの組み合わせ\n- 両方の利点を活用\n\n【スレッドの注意点】\n\n**同期の問題**\n- 共有データへの同時アクセス\n- 競合状態(Race Condition)\n- デッドロック\n→ 排他制御(mutex、セマフォ)が必要\n\n**デバッグの困難さ**\n- タイミング依存のバグ\n- 再現が難しい\n\nスレッドは、効率的な並行処理と資源共有を実現する重要な技術です。"
    },
    {
      "id": "tech-2-3-3-q009",
      "type": "multiple_choice",
      "question": "デッドロックの説明として、最も適切なものはどれか。",
      "options": [
        "複数のプロセスが互いに相手の資源解放を待ち、永久に実行できない状態",
        "プロセスが終了せずに無限ループに陥る状態",
        "メモリ不足でプロセスが実行できない状態",
        "CPUが過負荷で応答しない状態"
      ],
      "correctAnswer": 0,
      "explanation": "デッドロック(Deadlock:膠着状態、行き詰まり)は、複数のプロセス(タスク)が互いに相手が占有している資源の解放を待ち続け、永久に実行が進まない状態です。\n\n【デッドロックの例】\n\n**2つのプロセスと2つの資源**\n\n```\nプロセスA:\n1. 資源1を獲得 ✓\n2. 資源2を獲得しようとする → 待機(Bが持っているため)\n\nプロセスB:\n1. 資源2を獲得 ✓\n2. 資源1を獲得しようとする → 待機(Aが持っているため)\n\n結果:AはBを、BはAを待ち続ける → デッドロック\n```\n\n**哲学者の食事問題**\n```\n5人の哲学者が円卓に座り、隣に1本ずつフォークがある(計5本)\n食事には左右2本のフォークが必要\n\n全員が同時に左のフォークを取ると:\n→ 全員が右のフォークを待ち続ける → デッドロック\n```\n\n【デッドロック発生の4条件】\n\nデッドロックは以下の4条件がすべて成立すると発生:\n\n**1. 相互排除(Mutual Exclusion)**\n- 資源は同時に1つのプロセスにしか使用されない\n- 例:プリンタ、ファイル\n\n**2. 占有と待機(Hold and Wait)**\n- プロセスが資源を保持したまま、他の資源を待つ\n- 獲得済み資源を解放せずに次の資源を要求\n\n**3. 非横取り(No Preemption)**\n- 資源を強制的に取り上げられない\n- プロセスが自発的に解放するまで待つ必要\n\n**4. 循環待ち(Circular Wait)**\n- プロセスの資源待ちが循環している\n- A→B→C→A のような待ち状態の輪\n\n【デッドロックの対策】\n\n**1. 予防(Prevention)**\n\n4条件のいずれかを成立させない:\n\n**相互排除の否定**\n- 困難(資源の性質上、必須な場合が多い)\n\n**占有と待機の否定**\n- 必要な資源をすべて一度に獲得\n- または、資源を持っている場合は新たに要求しない\n\n**非横取りの否定**\n- 資源を強制的に取り上げる\n- プロセスの再起動が必要\n\n**循環待ちの否定**\n- 資源に順序を付ける\n- 常に小さい番号から大きい番号へ獲得\n- 最も実用的\n\n**2. 回避(Avoidance)**\n\n**銀行家のアルゴリズム**\n- 資源割り当て前に安全性をチェック\n- デッドロックの可能性がある場合は割り当てない\n- 保守的なアプローチ\n\n**3. 検出と回復(Detection and Recovery)**\n\n**検出:**\n- 定期的にデッドロック検出アルゴリズム実行\n- 資源割り当てグラフで循環を検出\n\n**回復:**\n- プロセスの強制終了(1つまたは複数)\n- 資源の横取り(プリエンプション)\n- チェックポイントからの再実行\n\n**4. 無視(Ostrich Algorithm)**\n- デッドロックを無視する\n- 発生頻度が低い場合、対策コストが見合わない\n- 発生時は手動で対処(再起動など)\n- 多くのOSが採用(UNIX、Windowsなど)\n\n【実際のシステムでの対策例】\n\n**データベース**\n- トランザクションのタイムアウト\n- デッドロック検出\n- 検出時は1つのトランザクションをロールバック\n\n**ファイルシステム**\n- ファイルロックの順序付け\n- タイムアウト機構\n\n**プログラミング**\n- ロックの順序を統一\n- タイムアウト付きロック獲得\n- try-lockパターン(獲得失敗時は保持ロックも解放)\n\n【ライブロック】\n\nデッドロックに類似した問題:\n- プロセスは動作しているが進展しない\n- 互いに譲り合って結果的に進まない\n- 例:狭い廊下で対向者と何度もよけ合う\n\nデッドロックは、マルチタスク環境での資源管理における重要な課題です。"
    },
    {
      "id": "tech-2-3-3-q010",
      "type": "multiple_choice",
      "question": "コンテキストスイッチ(文脈切替)の説明として、最も適切なものはどれか。",
      "options": [
        "実行中のプロセスの状態を保存し、別のプロセスの状態を復元してCPUを切り替える処理",
        "プロセスの優先度を変更する処理",
        "メモリとディスクの間でデータを交換する処理",
        "プログラムをコンパイルする処理"
      ],
      "correctAnswer": 0,
      "explanation": "コンテキストスイッチ(Context Switch:文脈切替、プロセス切り替え)は、CPUで実行するプロセスを切り替える際に、現在のプロセスの実行状態(コンテキスト)を保存し、次に実行するプロセスの状態を復元する処理です。\n\n【コンテキスト(Context)とは】\n\nプロセスの実行状態を表す情報:\n\n**1. CPUレジスタの内容**\n- プログラムカウンタ(PC)\n- スタックポインタ(SP)\n- 汎用レジスタ\n- フラグレジスタ\n\n**2. プロセス状態**\n- 実行可能、実行中、待ち\n\n**3. メモリ管理情報**\n- ページテーブル\n- セグメントテーブル\n- ベースレジスタ、リミットレジスタ\n\n**4. その他の情報**\n- プロセスID(PID)\n- 優先度\n- 親プロセスID\n- オープンファイルリスト\n- シグナル情報\n\n【コンテキストスイッチの流れ】\n\n```\n1. プロセスA実行中\n   ↓\n2. 割込み発生(タイマー、I/O完了など)\n   ↓\n3. カーネルモードへ移行\n   ↓\n4. プロセスAのコンテキストを保存\n   - レジスタ → PCB(プロセス制御ブロック)へ\n   - PC、SP、汎用レジスタなどすべて保存\n   ↓\n5. スケジューラがプロセスBを選択\n   ↓\n6. プロセスBのコンテキストを復元\n   - PCB → レジスタへ\n   - 保存されていた状態を復元\n   ↓\n7. ユーザモードへ移行\n   ↓\n8. プロセスB実行再開\n   (前回中断した場所から継続)\n```\n\n【コンテキストスイッチの発生タイミング】\n\n**1. タイマー割込み**\n- タイムクォータ(時間切れ)\n- ラウンドロビンスケジューリング\n\n**2. I/O要求**\n- プロセスがI/O待ちになる\n- 待ち状態へ遷移\n\n**3. 高優先度プロセスの出現**\n- プリエンプション(横取り)\n\n**4. システムコール**\n- OSの機能呼び出し\n\n**5. 割込み処理**\n- ハードウェア割込み\n\n【コンテキストスイッチのオーバーヘッド】\n\n**コスト:**\n- レジスタの保存・復元:数百〜数千クロック\n- キャッシュのフラッシュ:大きな影響\n- TLB(Translation Lookaside Buffer)のクリア\n- パイプラインのフラッシュ\n\n**所要時間:**\n- 典型的:数マイクロ秒〜数ミリ秒\n- ハードウェア、OS、プロセスサイズに依存\n\n**影響を減らす工夫:**\n- タイムクォータの適切な設定\n- スレッドの利用(プロセスより軽量)\n- ハードウェア支援(複数のレジスタセット)\n\n【プロセス切り替え vs スレッド切り替え】\n\n**プロセス切り替え**\n- メモリ空間が異なる\n- ページテーブル切り替えが必要\n- TLBフラッシュ\n- コスト:大\n\n**スレッド切り替え**\n- 同一メモリ空間\n- ページテーブル切り替え不要\n- スタックとレジスタのみ切り替え\n- コスト:小(プロセスの1/10〜1/100)\n\n【例:時間の比較】\n\n```\n通常の命令実行:        1ナノ秒\nL1キャッシュアクセス:  1ナノ秒\nL2キャッシュアクセス:  10ナノ秒\nメインメモリアクセス:  100ナノ秒\nコンテキストスイッチ:  1〜10マイクロ秒\n                      (1,000〜10,000ナノ秒)\nディスクI/O:           10ミリ秒\n                      (10,000,000ナノ秒)\n```\n\n【コンテキストスイッチの監視】\n\nLinux/UNIXコマンド:\n```bash\n# コンテキストスイッチ数の確認\nvmstat 1\n\n# プロセスごとのスイッチ数\npidstat -w 1\n```\n\n**指標:**\n- cs(context switches):秒あたりのスイッチ数\n- 数千〜数万/秒:通常\n- 数十万/秒:高負荷、要調査\n\nコンテキストスイッチは、マルチタスクの実現に不可欠ですが、オーバーヘッドを考慮した設計が重要です。"
    }
  ]
}
