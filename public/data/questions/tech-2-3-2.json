{
  "topicId": "tech-2-3-2",
  "title": "ジョブ管理",
  "questions": [
    {
      "id": "tech-2-3-2-q001",
      "type": "multiple_choice",
      "question": "ジョブの説明として、最も適切なものはどれか。",
      "options": [
        "ユーザがコンピュータに依頼する一連の処理のまとまり",
        "CPUが実行する最小単位の命令",
        "メモリに格納されているデータ",
        "ネットワークで送受信されるパケット"
      ],
      "correctAnswer": 0,
      "explanation": "ジョブ(Job)は、ユーザがコンピュータに依頼する処理の単位で、1つまたは複数のプログラムの実行から構成される一連の作業のまとまりです。\n\n【ジョブの概念】\n\n**定義:**\n- ユーザの視点からの処理単位\n- 入力から出力までの一連の処理\n- 複数のプログラム(ステップ)の集合\n\n**例:**\n- 給与計算ジョブ:\n  1. マスタファイル読み込み\n  2. 給与計算プログラム実行\n  3. 結果ファイル出力\n  4. 帳票印刷\n\n【ジョブとプロセス/タスクの違い】\n\n**ジョブ(Job)**\n- ユーザからの依頼単位\n- 高レベルの処理単位\n- 複数のプログラムを含む\n- バッチ処理で使用される用語\n\n**プロセス/タスク(Process/Task)**\n- OSが管理する実行単位\n- 低レベルの処理単位\n- 1つのプログラムの実行\n- メモリ空間、リソースを持つ\n\n【階層構造】\n```\nジョブ(給与計算)\n  ├─ プロセス1(データ読み込み)\n  ├─ プロセス2(計算処理)\n  └─ プロセス3(結果出力)\n```\n\n【ジョブの種類】\n\n**バッチジョブ**\n- 非対話型処理\n- まとめて実行\n- 夜間処理など\n\n**対話型ジョブ**\n- リアルタイム処理\n- ユーザとの対話\n- オンライン処理\n\n【ジョブ制御言語(JCL)】\n- ジョブの実行手順を記述\n- メインフレームで使用\n- 例:IBM z/OSのJCL\n\nジョブは、特にバッチ処理システムやメインフレームで重要な概念です。"
    },
    {
      "id": "tech-2-3-2-q002",
      "type": "multiple_choice",
      "question": "ジョブ管理の主な役割として、適切でないものはどれか。",
      "options": [
        "ジョブの投入と受付",
        "ジョブの実行順序の決定",
        "ジョブの実行結果の出力",
        "プログラムのコンパイル"
      ],
      "correctAnswer": 3,
      "explanation": "ジョブ管理(Job Management)は、OSがジョブを効率的に処理するための機能です。\n\n【ジョブ管理の主な役割】\n\n**1. ジョブの投入と受付(選択肢1)✓**\n- ユーザからのジョブ投入を受け付ける\n- ジョブ情報(優先度、必要資源など)の登録\n- ジョブキューへの格納\n\n**2. ジョブスケジューリング(選択肢2)✓**\n- ジョブの実行順序の決定\n- 優先度による制御\n- 資源の割り当て計画\n- ジョブキューの管理\n\n**3. ジョブの実行制御**\n- ジョブの起動\n- 実行中の監視\n- 異常終了時の処理\n\n**4. 結果の出力(選択肢3)✓**\n- 実行結果のファイル出力\n- 印刷出力\n- ログの記録\n- ユーザへの通知\n\n**5. 資源の管理**\n- CPU、メモリ、ファイルの割り当て\n- 実行終了後の資源解放\n\n【プログラムのコンパイル(選択肢4)✗】\n- これはアプリケーション(コンパイラ)の機能\n- ジョブ管理の役割ではない\n- ジョブ管理は「コンパイラを実行するジョブ」を管理するが、コンパイル自体は行わない\n\n【ジョブ管理の流れ】\n```\n1. ジョブ投入\n   ↓\n2. ジョブキューに登録\n   ↓\n3. スケジューリング(実行順序決定)\n   ↓\n4. 資源割り当て\n   ↓\n5. ジョブ実行\n   ↓\n6. 結果出力\n   ↓\n7. 資源解放\n```\n\n【ジョブステップの管理】\n- ジョブ内の各ステップの実行制御\n- ステップ間のデータ受け渡し\n- エラー時のステップスキップ\n\nジョブ管理は、システム資源を効率的に利用し、複数のジョブを円滑に処理するための重要な機能です。"
    },
    {
      "id": "tech-2-3-2-q003",
      "type": "multiple_choice",
      "question": "ジョブスケジューリングの説明として、最も適切なものはどれか。",
      "options": [
        "複数のジョブの実行順序を決定する機能",
        "メモリの割り当てを管理する機能",
        "ファイルシステムを管理する機能",
        "ネットワーク通信を制御する機能"
      ],
      "correctAnswer": 0,
      "explanation": "ジョブスケジューリング(Job Scheduling)は、複数のジョブが投入された際に、それらをどの順序で実行するかを決定する機能です。\n\n【ジョブスケジューリングの目的】\n\n**1. システム資源の有効活用**\n- CPUの稼働率向上\n- I/O装置の効率的利用\n- メモリの効率的使用\n\n**2. ジョブの効率的処理**\n- ターンアラウンドタイムの短縮\n- スループットの向上\n- 待ち時間の削減\n\n**3. 公平性の確保**\n- すべてのジョブに実行機会を提供\n- 特定ジョブの独占防止\n\n【主なスケジューリング方式】\n\n**1. FCFS(First Come First Served:到着順)**\n- 投入された順に実行\n- 単純で公平\n- 短いジョブが長いジョブを待つ問題\n\n**2. SJF(Shortest Job First:最短ジョブ優先)**\n- 実行時間が短いジョブから実行\n- 平均待ち時間が最小\n- 長いジョブが待たされる(飢餓状態)\n\n**3. 優先度スケジューリング**\n- ジョブに優先度を設定\n- 高優先度ジョブから実行\n- 緊急処理に対応可能\n- 低優先度ジョブの飢餓に注意\n\n**4. ラウンドロビン**\n- 各ジョブに一定時間を割り当て\n- 時間切れで次のジョブへ\n- 対話型処理に適する\n- タイムシェアリングで使用\n\n**5. 多段キュー**\n- ジョブを複数のキューに分類\n- キューごとに優先度設定\n- 例:システムジョブ > ユーザジョブ\n\n【ジョブスケジューリングの考慮事項】\n\n- **ジョブの種類**:バッチ/対話型\n- **優先度**:重要度、締切\n- **実行時間**:短時間/長時間\n- **必要資源**:CPU依存型/I/O依存型\n- **到着時刻**:投入順序\n\n【スケジューリングの階層】\n\n**長期スケジューリング(ジョブスケジューリング)**\n- どのジョブを実行するか決定\n- ジョブキューからレディキューへ\n\n**短期スケジューリング(CPUスケジューリング)**\n- どのプロセスにCPUを割り当てるか\n- タスクスケジューリング\n\n効果的なジョブスケジューリングは、システム全体の性能を大きく左右します。"
    },
    {
      "id": "tech-2-3-2-q004",
      "type": "multiple_choice",
      "question": "スプーリング(Spooling)の説明として、最も適切なものはどれか。",
      "options": [
        "低速な入出力装置とCPUの速度差を緩和するため、データを一時的にディスクに格納する技術",
        "メモリとディスクの間でデータを交換する技術",
        "複数のプログラムを同時に実行する技術",
        "ネットワーク経由でファイルを転送する技術"
      ],
      "correctAnswer": 0,
      "explanation": "スプーリング(Spooling:Simultaneous Peripheral Operation On-Line)は、低速な入出力装置(特にプリンタ)とCPUの速度差を緩和するため、データを一時的に高速なディスク装置に格納し、後でまとめて出力する技術です。\n\n【スプーリングの目的】\n\n**速度差の解消**\n- CPU:非常に高速(GHz)\n- プリンタ:非常に低速(数ページ/分)\n- この速度差により、CPUがプリンタ待ちで停止してしまう\n- スプーリングで、CPUはディスクへの書き込み後すぐに次の処理へ\n\n【スプーリングの仕組み】\n\n**1. 印刷データの生成**\n```\nアプリケーション\n   ↓ 印刷指示\nOS\n   ↓ データをディスクの「スプール領域」に保存\nディスク(スプールファイル)\n```\n\n**2. バックグラウンドで印刷**\n```\nスプーラ(常駐プログラム)\n   ↓ スプール領域から順次読み出し\nプリンタ\n   ↓ 実際の印刷\n出力完了\n```\n\n【動作の流れ】\n1. アプリケーションが印刷データをスプール領域(ディスク)に出力\n2. CPUは即座に次の処理に移る\n3. スプーラ(常駐プログラム)がバックグラウンドでスプール領域を監視\n4. スプーラがデータを読み出してプリンタに送信\n5. 印刷完了後、スプールファイルを削除\n\n【メリット】\n\n**1. CPU利用効率の向上**\n- CPUがプリンタ待ちで停止しない\n- 他の処理を並行実行可能\n\n**2. 複数ジョブの並行処理**\n- 複数のアプリケーションからの印刷を受け付け\n- スプール領域に順次格納\n- 順番に印刷\n\n**3. ユーザの待ち時間短縮**\n- 印刷完了を待たずに次の作業が可能\n\n【スプーリングの適用例】\n\n**プリンタスプール**\n- 最も一般的な用途\n- Windows:印刷キュー\n- UNIX/Linux:lp、CUPS\n\n**その他の適用**\n- カードリーダー(歴史的)\n- プロッタ\n- バッチ処理の入力\n\n【スワッピングとの違い】\n\n**スプーリング**\n- 入出力データの一時保存\n- ディスク ⇔ 周辺機器(プリンタなど)\n- 目的:I/O装置との速度差緩和\n\n**スワッピング**\n- プロセス全体の一時退避\n- メモリ ⇔ ディスク\n- 目的:メモリ不足の解消\n\nスプーリングは、システムの並行性を高め、資源の有効活用を実現する重要な技術です。"
    },
    {
      "id": "tech-2-3-2-q005",
      "type": "multiple_choice",
      "question": "ジョブキューの説明として、最も適切なものはどれか。",
      "options": [
        "実行待ちのジョブが格納される待ち行列",
        "実行中のジョブのリスト",
        "完了したジョブの履歴",
        "エラーが発生したジョブの記録"
      ],
      "correctAnswer": 0,
      "explanation": "ジョブキュー(Job Queue)は、投入されたジョブが実行を待つための待ち行列(キュー)です。\n\n【キュー(Queue)とは】\n- 先入れ先出し(FIFO:First In First Out)のデータ構造\n- 最初に入れたデータが最初に取り出される\n- 行列、待ち行列とも呼ばれる\n\n【ジョブキューの役割】\n\n**1. ジョブの一時保管**\n- 投入されたジョブを順番に格納\n- システムが処理可能になるまで待機\n\n**2. 実行順序の管理**\n- FCFS(先着順)の場合、投入順に実行\n- 優先度付きキューでは、優先度順に実行\n\n**3. 負荷の平準化**\n- 同時に大量のジョブが投入されても対応\n- 順次処理することで負荷を分散\n\n【ジョブ処理の流れ】\n```\n1. ジョブ投入\n   ↓\n2. ジョブキューに登録(待機)\n   ↓\n3. スケジューラが実行順序を決定\n   ↓\n4. システム資源が利用可能になる\n   ↓\n5. ジョブキューから取り出し\n   ↓\n6. ジョブ実行\n   ↓\n7. 完了(出力キューへ)\n```\n\n【関連する他のキュー】\n\n**レディキュー(Ready Queue)**\n- CPU実行待ちのプロセスのキュー\n- メモリに読み込まれ、実行可能な状態\n- タスクスケジューリングで使用\n\n**出力キュー(Output Queue)**\n- 実行完了したジョブの出力待ちキュー\n- スプーリングで使用(印刷キューなど)\n\n**デバイスキュー**\n- 特定のデバイス(ディスク、プリンタなど)の使用待ちキュー\n\n【ジョブの状態遷移】\n```\n投入 → ジョブキュー(待機中)\n         ↓\n      レディキュー(実行可能)\n         ↓\n      実行中\n         ↓\n      完了 → 出力キュー\n```\n\n【キューの種類】\n\n**単一キュー**\n- すべてのジョブを1つのキューで管理\n- シンプルだが柔軟性に欠ける\n\n**多段キュー**\n- 優先度やジョブ種類ごとに複数のキュー\n- 例:システムジョブキュー、対話型ジョブキュー、バッチジョブキュー\n- 柔軟なスケジューリングが可能\n\nジョブキューは、効率的なジョブ管理の基本となるデータ構造です。"
    },
    {
      "id": "tech-2-3-2-q006",
      "type": "multiple_choice",
      "question": "バッチ処理の説明として、最も適切なものはどれか。",
      "options": [
        "一定期間や一定量のデータをまとめて一括処理する方式",
        "ユーザからの要求に即座に応答する方式",
        "複数のユーザが同時にシステムを利用する方式",
        "データを1件ずつリアルタイムに処理する方式"
      ],
      "correctAnswer": 0,
      "explanation": "バッチ処理(Batch Processing)は、一定期間または一定量のデータをまとめて、一括で処理する方式です。\n\n【バッチ処理の特徴】\n\n**1. 非対話型処理**\n- ユーザとの対話なし\n- 処理中の介入不要\n- 事前に処理手順を定義\n\n**2. まとめて処理**\n- データを蓄積してから一括処理\n- 夜間や休日など、システムが空いている時間に実行\n- 大量データの効率的処理\n\n**3. 実行時間の予測可能性**\n- 処理量が明確\n- スケジュール化が容易\n\n【バッチ処理の例】\n\n**業務システム**\n- 月次給与計算\n- 日次売上集計\n- 月末締め処理\n- 顧客への請求書発行\n\n**システム管理**\n- データベースバックアップ\n- ログファイルの集計・削除\n- システムメンテナンス\n- レポート生成\n\n**データ処理**\n- 大量データの変換\n- データウェアハウスへのETL\n- 統計処理\n\n【バッチ処理の利点】\n\n**1. 効率性**\n- システムリソースの集中利用\n- 高いスループット\n- コスト削減\n\n**2. 確実性**\n- エラー処理の統一化\n- リカバリが容易\n- 処理の再実行が可能\n\n**3. 運用の容易さ**\n- 無人運転が可能\n- スケジュール実行\n- 自動化が容易\n\n【バッチ処理の欠点】\n\n- リアルタイム性がない\n- 処理完了まで時間がかかる\n- 処理中のデータ参照・更新ができない\n\n【対話型処理との比較】\n\n**バッチ処理**\n- 非対話型、まとめて処理\n- ターンアラウンドタイム重視\n- 例:給与計算、月次集計\n\n**対話型処理(オンライン処理)**\n- ユーザとの対話\n- レスポンスタイム重視\n- リアルタイム処理\n- 例:銀行ATM、航空券予約、ECサイト\n\n【バッチ処理の実行方式】\n\n**時間トリガー**\n- 毎日23時に実行\n- 毎月末日に実行\n\n**イベントトリガー**\n- データが一定量蓄積されたら実行\n- 前処理完了後に実行\n\n**手動実行**\n- 管理者が必要に応じて実行\n\nバッチ処理は、大量データの効率的な処理に適しており、業務システムで広く使用されています。"
    },
    {
      "id": "tech-2-3-2-q007",
      "type": "multiple_choice",
      "question": "リアルタイム処理の説明として、最も適切なものはどれか。",
      "options": [
        "データが発生したらすぐに処理し、即座に応答する方式",
        "一定期間データを蓄積してから一括処理する方式",
        "夜間など決まった時間に処理を実行する方式",
        "複数のユーザでデータを共有する方式"
      ],
      "correctAnswer": 0,
      "explanation": "リアルタイム処理(Real-time Processing)は、データが発生したら即座に処理し、リアルタイム(実時間)で応答を返す処理方式です。\n\n【リアルタイム処理の特徴】\n\n**1. 即時性**\n- データ発生と同時に処理\n- 遅延が許されない\n- 高速な応答が必須\n\n**2. 対話型**\n- ユーザとの対話的な処理\n- 入力→処理→出力が即座\n\n**3. 時間制約**\n- デッドライン(締切時間)が存在\n- 一定時間内に処理完了が必要\n\n【リアルタイム処理の種類】\n\n**ハードリアルタイム**\n- デッドラインを絶対に守る必要\n- 遅延は致命的\n- 例:\n  - 航空機制御システム\n  - 自動車のエンジン制御\n  - 医療機器(人工心臓)\n  - 産業用ロボット制御\n\n**ソフトリアルタイム**\n- デッドライン遅延は許容される\n- 品質低下するが致命的ではない\n- 例:\n  - 銀行ATM\n  - 航空券予約システム\n  - オンラインゲーム\n  - 動画ストリーミング\n\n【リアルタイム処理の例】\n\n**金融システム**\n- ATM取引\n- 株式取引システム\n- クレジットカード決済\n\n**交通システム**\n- 航空管制システム\n- 鉄道運行管理\n- カーナビゲーション\n\n**通信システム**\n- 電話交換システム\n- ビデオ会議\n- オンラインチャット\n\n**制御システム**\n- プロセス制御\n- ロボット制御\n- 組込みシステム\n\n【バッチ処理との比較】\n\n**リアルタイム処理**\n- 即座に処理・応答\n- レスポンスタイム重視\n- 1件ずつ処理\n- データは常に最新\n- システム負荷が分散\n\n**バッチ処理**\n- まとめて一括処理\n- スループット重視\n- 大量データを効率的処理\n- 処理時点のデータ\n- 特定時間に負荷集中\n\n【リアルタイム処理の要件】\n\n**1. 高速性**\n- 高速なハードウェア\n- 最適化されたプログラム\n- 効率的なアルゴリズム\n\n**2. 信頼性**\n- システム障害が許されない\n- 冗長構成\n- 高可用性\n\n**3. 応答性**\n- レスポンスタイムの保証\n- リアルタイムOS\n- 優先度制御\n\n現代の業務システムの多くは、リアルタイム処理とバッチ処理を組み合わせて使用しています。"
    },
    {
      "id": "tech-2-3-2-q008",
      "type": "multiple_choice",
      "question": "ジョブの優先度制御に関する説明として、適切でないものはどれか。",
      "options": [
        "優先度の高いジョブから順に実行する",
        "緊急性の高い処理を優先的に実行できる",
        "すべてのジョブが必ず同じ時間内に実行される",
        "低優先度のジョブが長時間待たされる可能性がある"
      ],
      "correctAnswer": 2,
      "explanation": "ジョブの優先度制御(Priority Control)は、各ジョブに優先度を設定し、優先度の高いジョブから順に実行するスケジューリング方式です。\n\n【優先度制御の仕組み】\n\n**優先度の設定**\n- 各ジョブに優先度(プライオリティ)を割り当て\n- 数値で表現(例:1〜10、1が最高優先)\n- 優先度の決定要因:\n  - ジョブの重要性\n  - 緊急性\n  - 実行時間\n  - ユーザの権限\n  - 締切時刻\n\n**スケジューリング**\n- 優先度の高いジョブを優先的に実行\n- 同じ優先度内では先着順(FCFS)など\n\n【優先度制御の利点(選択肢1,2)✓】\n\n**1. 重要ジョブの優先実行(選択肢1)**\n- 高優先度ジョブが先に実行される\n- システムジョブ > ユーザジョブ\n\n**2. 緊急対応(選択肢2)**\n- 緊急性の高い処理を即座に実行\n- 締切のある処理を確実に完了\n\n**3. 資源の効率的利用**\n- 短時間ジョブに高優先度を設定することで平均待ち時間短縮\n\n【優先度制御の問題点】\n\n**1. 低優先度ジョブの飢餓(Starvation)(選択肢4)✓**\n- 低優先度ジョブが長時間待たされる\n- 最悪の場合、永久に実行されない\n- 高優先度ジョブが次々投入されると、低優先度は待ち続ける\n\n**2. 公平性の欠如(選択肢3)✗**\n- すべてのジョブが同じ時間内に実行されるわけではない\n- 優先度による差別化が目的\n- 実行時間は優先度とジョブの性質に依存\n\n【飢餓状態の解決策】\n\n**エージング(Aging)**\n- 待ち時間が長くなると優先度を徐々に上げる\n- 最終的にはすべてのジョブが実行される\n- 例:10分待つごとに優先度+1\n\n**最低保証時間の設定**\n- 一定時間内に必ず実行する仕組み\n\n**優先度の動的調整**\n- システム状態に応じて優先度を変更\n\n【優先度の例】\n\n**システム優先度**\n1. 最高:システムクリティカル(OS、緊急保守)\n2. 高:対話型処理(ユーザ待ち)\n3. 中:通常バッチ処理\n4. 低:バックグラウンド処理(バックアップ、統計など)\n\n選択肢3「すべてのジョブが必ず同じ時間内に実行される」は誤りです。優先度制御では、優先度による差別化が行われるため、実行時間は異なります。"
    },
    {
      "id": "tech-2-3-2-q009",
      "type": "multiple_choice",
      "question": "ジョブステップの説明として、最も適切なものはどれか。",
      "options": [
        "ジョブを構成する個々のプログラムまたは処理の単位",
        "ジョブの実行優先度",
        "ジョブが使用するメモリ容量",
        "ジョブの実行時間"
      ],
      "correctAnswer": 0,
      "explanation": "ジョブステップ(Job Step)は、ジョブを構成する個々のプログラムまたは処理の単位です。1つのジョブは、複数のジョブステップから構成されることがあります。\n\n【ジョブとジョブステップの関係】\n\n**ジョブ**\n- ユーザが依頼する処理全体\n- 複数のステップを含む\n- 入力から出力までの一連の作業\n\n**ジョブステップ**\n- ジョブを構成する個々の処理単位\n- 1つのプログラムの実行\n- 順次実行される\n\n【例:給与計算ジョブ】\n```\nジョブ:給与計算\n├─ ステップ1:社員マスタ読み込み\n├─ ステップ2:勤怠データ読み込み\n├─ ステップ3:給与計算プログラム実行\n├─ ステップ4:結果ファイル作成\n└─ ステップ5:給与明細印刷\n```\n\n【ジョブステップの特徴】\n\n**1. 独立した処理単位**\n- 各ステップは個別のプログラム\n- 入力、処理、出力が明確\n\n**2. 順次実行**\n- ステップは定義された順序で実行\n- 前のステップが完了してから次へ\n\n**3. ステップ間のデータ受け渡し**\n- 前ステップの出力が次ステップの入力\n- 一時ファイルやデータセットで連携\n\n**4. 条件分岐**\n- ステップの実行結果で次の動作を決定\n- 正常終了、異常終了による分岐\n\n【ジョブステップの制御】\n\n**正常終了時**\n- 次のステップに進む\n- 最終ステップ完了でジョブ終了\n\n**異常終了時**\n- ジョブ全体を中止\n- または特定のステップをスキップ\n- エラー処理ステップへ分岐\n\n**条件分岐の例**\n```\nステップ1:ファイル存在チェック\n  成功 → ステップ2:通常処理\n  失敗 → ステップ3:エラー処理\n```\n\n【JCL(Job Control Language)での記述】\nメインフレームでは、JCLでジョブステップを定義:\n```\n//JOB1   JOB  ...\n//STEP1  EXEC PGM=PROG1    ←ステップ1\n//STEP2  EXEC PGM=PROG2    ←ステップ2\n//STEP3  EXEC PGM=PROG3    ←ステップ3\n```\n\n【ジョブステップの利点】\n\n**1. 処理の構造化**\n- 複雑な処理を小さな単位に分割\n- 理解しやすく、保守しやすい\n\n**2. 再利用性**\n- ステップ単位でプログラムを再利用\n- 複数のジョブで共通ステップを利用\n\n**3. エラー処理**\n- 問題が発生したステップを特定しやすい\n- ステップ単位で再実行可能\n\n**4. 並列実行の可能性**\n- 依存関係のないステップは並列実行可能\n\nジョブステップは、大規模なバッチ処理を効率的に管理するための重要な概念です。"
    },
    {
      "id": "tech-2-3-2-q010",
      "type": "multiple_choice",
      "question": "ジョブ管理において、ジョブの異常終了時の処理として適切でないものはどれか。",
      "options": [
        "エラーログを記録する",
        "管理者に通知する",
        "ジョブを自動的に最初から再実行する",
        "後続のジョブステップをスキップする"
      ],
      "correctAnswer": 2,
      "explanation": "ジョブの異常終了時には、適切なエラー処理とリカバリが必要です。各選択肢を検討します:\n\n【適切な異常終了時の処理】\n\n**1. エラーログの記録(選択肢1)✓**\n- 異常終了の原因を記録\n- ログ情報:\n  - ジョブ名、ステップ名\n  - 異常終了コード\n  - 発生日時\n  - エラーメッセージ\n- トラブルシューティングに必須\n- 監査証跡としても重要\n→ 必須の処理\n\n**2. 管理者への通知(選択肢2)✓**\n- メール、アラート、SNMPトラップなどで通知\n- 迅速な対応が可能\n- 重要ジョブの場合は即座に通知\n- 通知内容:\n  - ジョブ名\n  - 異常終了の詳細\n  - 影響範囲\n→ 適切な処理\n\n**3. 自動再実行(選択肢3)✗**\n- **問題点**:\n  - 異常終了の原因が解決されていない\n  - 同じエラーが繰り返される可能性\n  - データ破壊や二重処理のリスク\n  - 無限ループの危険性\n- **適切な対応**:\n  - 原因を調査・解決してから再実行\n  - 自動再実行は慎重に設計が必要\n  - 再実行回数の上限設定\n  - 一時的なエラー(ネットワーク断など)のみ自動再実行\n→ 無条件の自動再実行は不適切\n\n**4. 後続ステップのスキップ(選択肢4)✓**\n- 異常終了したステップ以降を中止\n- データの不整合を防ぐ\n- 被害の拡大防止\n- JCLでの制御例:\n  - COND(条件コード)による制御\n  - IF/THEN/ELSE構文\n→ 適切な処理\n\n【適切な異常終了処理フロー】\n```\n1. 異常検出\n   ↓\n2. エラーログ記録\n   ↓\n3. ジョブ停止(後続ステップ中止)\n   ↓\n4. 管理者通知\n   ↓\n5. 管理者が原因調査\n   ↓\n6. 問題修正\n   ↓\n7. 手動または承認後に再実行\n```\n\n【自動再実行が許される場合】\n\n**条件付き自動再実行**\n- 一時的なエラーのみ(ネットワーク断、リソース一時不足)\n- 再実行回数の上限あり(例:最大3回)\n- 再実行間隔を設ける(例:5分後)\n- べき等性が保証されている処理\n- ログに再実行の記録\n\n【例】\n```\nIF エラーコード = ネットワークタイムアウト THEN\n  再実行回数 < 3 の場合のみ\n    5分待機後に再実行\n  ELSE\n    管理者通知\nELSE\n  即座に停止、管理者通知\nEND IF\n```\n\n選択肢3「ジョブを自動的に最初から再実行する」は、原因調査なしの無条件再実行であり、不適切です。"
    }
  ]
}
