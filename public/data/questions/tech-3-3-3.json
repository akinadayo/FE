{
  "topicId": "tech-3-3-3",
  "title": "データ操作",
  "questions": [
    {
      "id": "tech-3-3-3-q1",
      "type": "multiple_choice",
      "question": "以下のSQL文の実行結果として、最も適切なものはどれか。\n\nSELECT 氏名, 給与 FROM 社員表 WHERE 部署ID = 10;\n\n【社員表】\n社員ID | 氏名 | 部署ID | 給与\n1 | 佐藤 | 10 | 300000\n2 | 田中 | 10 | 350000\n3 | 鈴木 | 20 | 400000",
      "options": [
        "全ての社員（佐藤、田中、鈴木）の氏名と給与を取得",
        "部署ID=10の社員（佐藤、田中）の氏名と給与のみを取得",
        "部署ID=10の社員（佐藤、田中）の全列（社員ID、氏名、部署ID、給与）を取得",
        "エラーが発生する"
      ],
      "correctAnswer": 1,
      "explanation": "「部署ID=10の社員（佐藤、田中）の氏名と給与のみを取得」が正しいです。このSQL文は、①SELECT 氏名, 給与：氏名と給与の列のみを射影（Projection）、②WHERE 部署ID = 10：部署ID=10の行のみを選択（Selection）、という2つの操作を組み合わせています。結果は、佐藤（300000）、田中（350000）の2行で、社員IDと部署IDは含まれません。鈴木（部署ID=20）は条件に合わないため除外されます。選択肢1は「WHERE部署ID = 10」の条件を無視しているため誤り、選択肢3は「SELECT 氏名, 給与」で列を射影しているため全列ではなく誤り、選択肢4はSQL文は正しいためエラーは発生せず誤りです。"
    },
    {
      "id": "tech-3-3-3-q2",
      "type": "multiple_choice",
      "question": "以下のSQL文の実行結果として、最も適切なものはどれか。\n\nSELECT 部署ID, COUNT(*) AS 社員数\nFROM 社員表\nGROUP BY 部署ID;\n\n【社員表】\n1, 佐藤, 10, 300000\n2, 田中, 10, 350000\n3, 鈴木, 20, 400000\n4, 高橋, 20, 320000\n5, 山田, 30, 280000",
      "options": [
        "部署ID | 社員数\n10 | 5\n20 | 5\n30 | 5",
        "部署ID | 社員数\n10 | 2\n20 | 2\n30 | 1",
        "部署ID | 社員数\n10 | 1",
        "社員数\n5"
      ],
      "correctAnswer": 1,
      "explanation": "「部署ID=10が2人、部署ID=20が2人、部署ID=30が1人」が正しいです。GROUP BY 部署IDにより、部署IDごとにグループ化され、COUNT(*)で各グループの行数（社員数）をカウントします。具体的には、①部署ID=10のグループ：佐藤、田中の2人、②部署ID=20のグループ：鈴木、高橋の2人、③部署ID=30のグループ：山田の1人、となります。選択肢1は全て5人になっているため誤り（GROUP BYでグループごとにカウントするため、各グループの人数は異なる）、選択肢3は部署ID=10のみで他の部署が含まれていないため誤り、選択肢4は部署IDが表示されず全社員数（5人）のみになっているため誤りです（GROUP BYを使用しているため、部署IDも表示される）。"
    },
    {
      "id": "tech-3-3-3-q3",
      "type": "multiple_choice",
      "question": "WHEREとHAVINGの違いとして、最も適切なものはどれか。",
      "options": [
        "WHEREはグループ化後にグループを絞り込み、HAVINGはグループ化前に行を絞り込む",
        "WHEREはグループ化前に行を絞り込み、HAVINGはグループ化後にグループを絞り込む",
        "WHEREとHAVINGは同じ機能で、どちらを使っても結果は同じ",
        "WHEREは集計関数を使え、HAVINGは集計関数を使えない"
      ],
      "correctAnswer": 1,
      "explanation": "「WHEREはグループ化前に行を絞り込み、HAVINGはグループ化後にグループを絞り込む」が正しいです。SELECT文の実行順序は、①FROM → ②WHERE（行を絞り込む） → ③GROUP BY（グループ化） → ④HAVING（グループを絞り込む） → ⑤SELECT → ⑥ORDER BY、です。例えば、「WHERE 給与 >= 300000」は給与300000以上の行のみをグループ化対象とし、「HAVING AVG(給与) >= 300000」は全行をグループ化した後、平均給与300000以上のグループのみを抽出します。また、WHEREでは集計関数（AVG、SUMなど）を使えませんが、HAVINGでは集計関数を使えます。選択肢1は逆なので誤り、選択肢3は結果が異なる場合があるため誤り、選択肢4も逆なので誤りです。"
    },
    {
      "id": "tech-3-3-3-q4",
      "type": "multiple_choice",
      "question": "以下のSQL文を実行した後の社員表の状態として、最も適切なものはどれか。\n\nUPDATE 社員表 SET 給与 = 給与 * 1.1 WHERE 部署ID = 10;\n\n【実行前の社員表】\n1, 佐藤, 10, 300000\n2, 田中, 10, 350000\n3, 鈴木, 20, 400000",
      "options": [
        "全社員の給与が1.1倍になる（佐藤330000、田中385000、鈴木440000）",
        "部署ID=10の社員（佐藤、田中）の給与のみ1.1倍になる（佐藤330000、田中385000、鈴木400000）",
        "佐藤の給与のみ1.1倍になる（佐藤330000、田中350000、鈴木400000）",
        "エラーが発生し、給与は変更されない"
      ],
      "correctAnswer": 1,
      "explanation": "「部署ID=10の社員（佐藤、田中）の給与のみ1.1倍になる」が正しいです。UPDATE文は、WHERE句で指定した条件に合う行のみを更新します。この場合、WHERE 部署ID = 10 により、部署ID=10の社員（佐藤、田中）のみが対象となり、給与が1.1倍になります。具体的には、佐藤：300000 × 1.1 = 330000、田中：350000 × 1.1 = 385000、鈴木（部署ID=20）：400000（変更なし）、となります。選択肢1はWHERE句を無視して全行を更新しているため誤り（WHERE句がない場合はこの結果になる）、選択肢3は佐藤のみとなっているため誤り（田中も部署ID=10のため更新される）、選択肢4はSQL文は正しいためエラーは発生せず誤りです。UPDATE文を実行する前は、必ずSELECT文で対象行を確認することが重要です。"
    },
    {
      "id": "tech-3-3-3-q5",
      "type": "multiple_choice",
      "question": "以下のSQL文を実行した後の社員表の状態として、最も適切なものはどれか。\n\nDELETE FROM 社員表 WHERE 氏名 = '山田';\n\n【実行前の社員表】\n1, 佐藤, 10, 300000\n2, 田中, 10, 350000\n3, 鈴木, 20, 400000\n5, 山田, 30, 280000",
      "options": [
        "全社員が削除され、社員表が空になる",
        "山田の行のみが削除され、佐藤、田中、鈴木の3行が残る",
        "山田の給与のみが削除され、山田の他の列（氏名、部署ID）は残る",
        "社員表自体が削除される"
      ],
      "correctAnswer": 1,
      "explanation": "「山田の行のみが削除され、佐藤、田中、鈴木の3行が残る」が正しいです。DELETE文は、WHERE句で指定した条件に合う行を削除します。この場合、WHERE 氏名 = '山田' により、山田の行のみが削除され、他の社員（佐藤、田中、鈴木）は残ります。選択肢1は WHERE句を省略した場合（DELETE FROM 社員表;）の結果で誤り、選択肢3は DELETE文は行全体を削除するため誤り（列の一部だけを削除することはできない。列の値をNULLにする場合は UPDATE文を使う）、選択肢4は DROP TABLE 社員表; の結果で誤りです。DELETE FROMはデータのみを削除し表の構造は残りますが、DROP TABLEは表自体を削除します。DELETE文を実行する前も、SELECT * FROM 社員表 WHERE 氏名 = '山田'; で対象行を確認することが重要です。"
    },
    {
      "id": "tech-3-3-3-q6",
      "type": "multiple_choice",
      "question": "以下のSQL文の実行結果として、最も適切なものはどれか。\n\nSELECT 社員表.氏名, 部署表.部署名\nFROM 社員表\nINNER JOIN 部署表 ON 社員表.部署ID = 部署表.部署ID;\n\n【社員表】\n1, 佐藤, 10, 300000\n2, 田中, 10, 350000\n4, 高橋, 99, 320000\n\n【部署表】\n10, 営業部\n20, 経理部",
      "options": [
        "佐藤（営業部）、田中（営業部）、高橋（NULL）の3行を取得",
        "佐藤（営業部）、田中（営業部）の2行を取得（高橋は除外）",
        "佐藤（営業部）、田中（営業部）、高橋（99）、NULL（経理部）の4行を取得",
        "エラーが発生する"
      ],
      "correctAnswer": 1,
      "explanation": "「佐藤（営業部）、田中（営業部）の2行を取得（高橋は除外）」が正しいです。INNER JOIN（内部結合）は、両方の表に一致するデータがある行のみを取得します。この場合、①佐藤（部署ID=10）：部署表に部署ID=10（営業部）が存在するため、結合される、②田中（部署ID=10）：同様に結合される、③高橋（部署ID=99）：部署表に部署ID=99が存在しないため、除外される、となります。選択肢1は LEFT OUTER JOIN の結果で誤り（左外部結合の場合、高橋も含まれ部署名はNULL）、選択肢3は RIGHT OUTER JOIN + 追加の行があるため誤り、選択肢4は SQL文は正しいためエラーは発生せず誤りです。INNER JOINは「両方に存在するデータのみ」を取得し、LEFT/RIGHT OUTER JOINは「一方に存在すればもう一方がなくてもNULLで取得」する点が違いです。"
    },
    {
      "id": "tech-3-3-3-q7",
      "type": "multiple_choice",
      "question": "以下のSQL文の実行結果として、最も適切なものはどれか。\n\nSELECT 部署ID, AVG(給与) AS 平均給与\nFROM 社員表\nGROUP BY 部署ID\nHAVING AVG(給与) >= 330000;\n\n【社員表】\n1, 佐藤, 10, 300000\n2, 田中, 10, 350000\n3, 鈴木, 20, 400000\n4, 高橋, 20, 320000\n5, 山田, 30, 280000",
      "options": [
        "部署ID | 平均給与\n10 | 325000\n20 | 360000\n30 | 280000",
        "部署ID | 平均給与\n10 | 325000\n20 | 360000",
        "部署ID | 平均給与\n20 | 360000",
        "平均給与\n330000"
      ],
      "correctAnswer": 2,
      "explanation": "「部署ID=20（平均給与360000）のみ」が正しいです。処理の流れは、①GROUP BY 部署ID で部署ごとにグループ化、②AVG(給与) で各グループの平均給与を計算（部署ID=10: (300000+350000)÷2=325000、部署ID=20: (400000+320000)÷2=360000、部署ID=30: 280000÷1=280000）、③HAVING AVG(給与) >= 330000 で平均給与330000以上のグループのみ抽出、となります。HAVING句の条件チェック：①部署ID=10: 325000 >= 330000? → NO（除外）、②部署ID=20: 360000 >= 330000? → YES（残る）、③部署ID=30: 280000 >= 330000? → NO（除外）。結果は、部署ID=20（360000）のみが残ります。選択肢1はHAVING句を無視しているため誤り、選択肢2は部署ID=10（325000 < 330000）が含まれているため誤り、選択肢4は部署IDが表示されず誤りです。HAVINGは GROUP BY後のグループを絞り込む句で、集計関数（AVG、SUMなど）を使えます。"
    },
    {
      "id": "tech-3-3-3-q8",
      "type": "multiple_choice",
      "question": "ORDER BY句の説明として、最も適切なものはどれか。",
      "options": [
        "ORDER BY 給与 ASC は、給与の高い順（降順）に並べ替える",
        "ORDER BY 給与 DESC は、給与の高い順（降順）に並べ替える",
        "ORDER BYは、WHERE句の前に記述する必要がある",
        "ORDER BYは、GROUP BY句と同時に使用できない"
      ],
      "correctAnswer": 1,
      "explanation": "「ORDER BY 給与 DESC は、給与の高い順（降順）に並べ替える」が正しいです。ORDER BYは、検索結果を並べ替える句で、ASC（昇順、低→高、デフォルト）とDESC（降順、高→低）を指定できます。例えば、ORDER BY 給与 DESC は、給与が400000, 350000, 320000, ... のように高い順に並べ替えます。選択肢1は ASC（昇順）が低→高の順なので誤り、選択肢3は ORDER BYは SELECT文の最後に記述するため誤り（正しい順序：FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY）、選択肢4は ORDER BYと GROUP BYは同時に使用可能なので誤りです（例：SELECT 部署ID, AVG(給与) FROM 社員表 GROUP BY 部署ID ORDER BY AVG(給与) DESC; で部署ごとの平均給与を高い順に表示できる）。"
    },
    {
      "id": "tech-3-3-3-q9",
      "type": "multiple_choice",
      "question": "LEFT OUTER JOINの説明として、最も適切なものはどれか。",
      "options": [
        "両方の表に一致するデータがある行のみを取得する",
        "左側の表の全行を取得し、右側の表に一致するデータがない場合はNULLを表示する",
        "右側の表の全行を取得し、左側の表に一致するデータがない場合はNULLを表示する",
        "両方の表の全行を取得し、一致するデータがない場合は両側ともNULLを表示する"
      ],
      "correctAnswer": 1,
      "explanation": "「左側の表の全行を取得し、右側の表に一致するデータがない場合はNULLを表示する」が正しいです。例えば、社員表 LEFT OUTER JOIN 部署表 の場合、全社員を表示し、部署が確定している社員は部署名を表示、部署が確定していない社員（部署ID=99など、部署表に存在しない）は部署名をNULLで表示します。これにより、「部署未配属の社員も含めて全社員を表示したい」という要件を満たせます。選択肢1は INNER JOIN の説明で誤り、選択肢3は RIGHT OUTER JOIN の説明で誤り、選択肢4は FULL OUTER JOIN の説明で誤りです（FULL OUTER JOINは、左右両方の表の全行を取得し、一致しない場合は両側ともNULLを表示）。LEFT/RIGHT OUTER JOINの使い分けは、どちらの表を基準（全行を取得）にするかによります。"
    },
    {
      "id": "tech-3-3-3-q10",
      "type": "multiple_choice",
      "question": "以下のSQL文の実行結果として、最も適切なものはどれか。\n\nSELECT * FROM 社員表 WHERE 氏名 LIKE '田%';",
      "options": [
        "氏名に「田」という文字が含まれる全ての社員を取得（田中、佐藤田郎、山田など）",
        "氏名が「田」で始まる社員のみを取得（田中、田村など）",
        "氏名が「田」で終わる社員のみを取得（山田、佐藤田など）",
        "氏名が「田」と完全に一致する社員のみを取得"
      ],
      "correctAnswer": 1,
      "explanation": "「氏名が『田』で始まる社員のみを取得（田中、田村など）」が正しいです。LIKE演算子は部分一致検索を行い、%は「任意の文字列（0文字以上）」を意味します。'田%' は「田で始まり、その後に任意の文字列が続く」という意味で、田中、田村、田辺などが該当します。その他のLIKEパターンは、①'%田'：田で終わる（山田、佐藤田など）、②'%田%'：田を含む（田中、山田、佐藤田郎など）、③'田_'：田 + 任意の1文字（田中、田村は不一致、田辺は一致）、④'田'：完全一致（= '田' と同じ）、です。選択肢1は '%田%' の結果で誤り、選択肢3は '%田' の結果で誤り、選択肢4は '田' の結果で誤りです。LIKEは部分一致検索で便利ですが、インデックスが効きにくくなる場合があるため、大量データでは性能に注意が必要です。"
    }
  ]
}
