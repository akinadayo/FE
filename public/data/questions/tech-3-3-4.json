{
  "topicId": "tech-3-3-4",
  "title": "トランザクション処理",
  "questions": [
    {
      "id": "tech-3-3-4-q1",
      "type": "multiple_choice",
      "question": "銀行のATMで、Aさんの口座（残高50,000円）からBさんの口座へ10,000円を振り込む処理中に、Bさんの口座番号が存在しないエラーが発生しました。この場合、ACID特性のうち、どの特性によってAさんの口座が元の50,000円に戻りますか？",
      "options": [
        "一貫性（Consistency）：振込前後で総残高が変わらない",
        "原子性（Atomicity）：全て成功または全て失敗するため、引き落としも取り消される",
        "独立性（Isolation）：他のトランザクションの影響を受けない",
        "永続性（Durability）：コミット後のデータは永続的に保存される"
      ],
      "correctAnswer": 1,
      "explanation": "「原子性（Atomicity）：全て成功または全て失敗するため、引き落としも取り消される」が正しいです。原子性とは、トランザクション内の全ての操作が「全て成功」または「全て失敗」のどちらかであり、途中の状態は存在しない性質です。この例では、①Aさんから引き落とし（成功）、②Bさんへ入金（失敗、口座番号が存在しない）、という2つの操作が1つのトランザクションとして扱われます。②が失敗したため、原子性により①も取り消され（ロールバック）、Aさんの残高は元の50,000円に戻ります。もし原子性がなければ、Aさんから10,000円だけ引き落とされ、Bさんには入金されないため、10,000円が消失してしまいます。一貫性は「振込前後で総残高が変わらない」ことを保証しますが、この問題では「Aさんの残高が元に戻る理由」を問われているため、原子性が正解です。"
    },
    {
      "id": "tech-3-3-4-q2",
      "type": "multiple_choice",
      "question": "ECサイトで、商品Aの在庫が10個あります。ユーザー1とユーザー2が同時に5個ずつ購入しようとしています。在庫の不整合を防ぐために、どのロックを使うべきですか？",
      "options": [
        "在庫を読み取る時は共有ロック、更新する時は専有ロックを使う",
        "在庫を読み取る時も更新する時も共有ロックを使う",
        "在庫を読み取る時も更新する時も専有ロックを使う",
        "ロックは使わず、データベースの自動調整に任せる"
      ],
      "correctAnswer": 2,
      "explanation": "「在庫を読み取る時も更新する時も専有ロックを使う」が正しいです。この問題では、在庫を読み取った後に更新する処理（Read-Modify-Write）が必要です。もし「読み取る時は共有ロック」を使うと、ユーザー1とユーザー2が同時に在庫10個を読み取り（両方とも共有ロックを取得可能）、その後、ユーザー1が10-5=5個に更新、ユーザー2が10-5=5個に更新、という処理が発生し、本来0個のはずが5個になってしまいます（在庫の不整合）。これを防ぐには、在庫を読み取る時点で専有ロックを取得し、他のトランザクションが在庫を読み取ることも更新することも禁止する必要があります。具体的には、ユーザー1が専有ロックを取得→在庫10個を読み取る→5個に更新→ロック解放、その後、ユーザー2が専有ロックを取得→在庫5個を読み取る→0個に更新→ロック解放、という順序で処理され、正しく在庫が0個になります。"
    },
    {
      "id": "tech-3-3-4-q3",
      "type": "multiple_choice",
      "question": "トランザクションAが商品ID=1をロック中で商品ID=2を待ち、トランザクションBが商品ID=2をロック中で商品ID=1を待っています。この状態を何と呼びますか？また、最も効果的な対策はどれですか？",
      "options": [
        "デッドロック。全てのトランザクションで「商品IDの小さい順にロックを取得する」というルールを統一する（デッドロック回避）",
        "ライブロック。タイムアウトを設定し、30秒経過後に一方をロールバックする",
        "競合状態。デッドロック検出を実装し、発生したら一方をロールバックする",
        "スターベーション。ロックの粒度を細かく（行レベル）して並行性を高める"
      ],
      "correctAnswer": 0,
      "explanation": "「デッドロック。全てのトランザクションで『商品IDの小さい順にロックを取得する』というルールを統一する（デッドロック回避）」が正しいです。この状態はデッドロック（Deadlock）と呼ばれ、複数のトランザクションが互いにロックを待ち合って、永久に処理が進まなくなる状態です。デッドロック対策には、①デッドロック検出（発生したら一方をロールバック）、②デッドロック回避（発生しないように設計）、③タイムアウト（一定時間待ってもロック取得できなければロールバック）、の3つがあります。最も効果的な対策は②デッドロック回避で、具体的には「全てのトランザクションで商品IDの小さい順にロックを取得する」というルールを統一します。このルールにより、AもBも商品ID=1→商品ID=2の順にロックを取得するため、先にロックを取得した方（例：A）が両方のロックを取得し、後の方（B）は待機するだけで、デッドロックが発生しません。デッドロック検出やタイムアウトは「発生後に対処」する手法ですが、デッドロック回避は「発生を防ぐ」手法であり、より効果的です。"
    },
    {
      "id": "tech-3-3-4-q4",
      "type": "multiple_choice",
      "question": "次のトランザクション処理のうち、COMMITではなくROLLBACKを実行すべきケースはどれですか？",
      "options": [
        "商品の在庫を10個から5個に更新する処理が成功した場合",
        "ユーザーの登録情報を更新する処理が全て成功した場合",
        "銀行振込で、A口座からの引き落としは成功したが、B口座への入金で「残高上限を超える」エラーが発生した場合",
        "注文データを挿入し、在庫を減らす処理が両方とも成功した場合"
      ],
      "correctAnswer": 2,
      "explanation": "「銀行振込で、A口座からの引き落としは成功したが、B口座への入金で『残高上限を超える』エラーが発生した場合」が正しいです。ROLLBACKは、トランザクションの変更を取り消し、トランザクション開始前の状態に戻す操作です。この例では、①A口座から引き落とし（成功）、②B口座へ入金（失敗、残高上限を超える）、という2つの操作が1つのトランザクションとして扱われます。②が失敗したため、原子性（全て成功または全て失敗）を保つために、①も取り消す必要があります。ROLLBACKを実行することで、A口座の残高が元に戻り、振込処理全体が取り消されます。もしCOMMITを実行すると、A口座から引き落としだけが確定し、B口座には入金されないため、お金が消失してしまいます。選択肢1、2、4は、全ての処理が成功しているため、COMMITを実行してデータベースに変更を永続的に反映させるべきです。"
    },
    {
      "id": "tech-3-3-4-q5",
      "type": "multiple_choice",
      "question": "時刻0にチェックポイントを取得しました。その後、時刻1にトランザクション1（T1）がコミット、時刻2にトランザクション2（T2）が開始し、時刻3にシステム障害が発生しました（T2はコミット前）。リカバリ処理として正しいものはどれですか？",
      "options": [
        "T1のみロールフォワードし、T2は何もしない",
        "T1のみロールバックし、T2は何もしない",
        "T1をロールフォワードし、T2をロールバックする",
        "T1とT2の両方をロールバックする"
      ],
      "correctAnswer": 2,
      "explanation": "「T1をロールフォワードし、T2をロールバックする」が正しいです。リカバリ処理では、①ロールフォワード（Roll Forward）：チェックポイント後のログを再生し、コミット済みトランザクションを復元、②ロールバック（Roll Back）：未コミットトランザクションを取り消し、の2つを実行します。この例では、T1はコミット済み（時刻1）、T2は未コミット（時刻2開始、時刻3障害発生でコミット前）です。したがって、T1の変更はロールフォワードで復元し（コミット済みのため、障害発生後も変更を反映させる）、T2の変更はロールバックで取り消します（未コミットのため、トランザクション開始前の状態に戻す）。もしT1をロールフォワードしなければ、コミット済みのデータが失われてしまい、永続性（Durability）が保たれません。もしT2をロールバックしなければ、未コミットの中途半端なデータが残ってしまい、原子性（Atomicity）が保たれません。両方を実行することで、ACID特性を満たすリカバリが可能になります。"
    },
    {
      "id": "tech-3-3-4-q6",
      "type": "multiple_choice",
      "question": "チェックポイントを定期的に取得する主な目的は何ですか？",
      "options": [
        "トランザクションの実行速度を向上させるため",
        "デッドロックの発生を防ぐため",
        "システム障害発生時のリカバリ時間を短縮するため",
        "データベースのストレージ容量を削減するため"
      ],
      "correctAnswer": 2,
      "explanation": "「システム障害発生時のリカバリ時間を短縮するため」が正しいです。チェックポイント（Checkpoint）とは、トランザクションログを定期的にデータベースに反映させる仕組みです。チェックポイントを取得することで、それ以前のトランザクションはリカバリ不要になります。例えば、時刻0からトランザクションが実行され、時刻50にチェックポイントを取得し、時刻100に障害が発生した場合、チェックポイントがなければ時刻0からのログを全て再生する必要がありますが、チェックポイントがあれば時刻50からのログのみ再生すれば良いため、リカバリ時間が大幅に短縮されます。選択肢1の「実行速度を向上」は、チェックポイントの主目的ではありません（むしろ、チェックポイント取得時に若干の処理負荷がかかります）。選択肢2の「デッドロックの発生を防ぐ」は、ロック順序統一などの手法で実現します。選択肢4の「ストレージ容量を削減」は、チェックポイント後にログをクリアすることで若干達成できますが、主目的は「リカバリ時間短縮」です。"
    },
    {
      "id": "tech-3-3-4-q7",
      "type": "multiple_choice",
      "question": "2相コミット（2PC）で、日本の銀行（DB1）からアメリカの銀行（DB2）へ送金する際、フェーズ1（準備フェーズ）でDB1が「YES（コミット可能）」、DB2が「NO（口座が存在しない）」と回答しました。次に実行されるのはどれですか？",
      "options": [
        "DB1のみコミット、DB2はロールバック",
        "DB1とDB2の両方をコミット",
        "DB1とDB2の両方をロールバック",
        "DB1をロールバック、DB2はコミット"
      ],
      "correctAnswer": 2,
      "explanation": "「DB1とDB2の両方をロールバック」が正しいです。2相コミット（Two-Phase Commit、2PC）は、分散データベースで複数のサーバーにまたがるトランザクションを、全てのサーバーで一貫してコミットまたはロールバックするためのプロトコルです。フェーズ1（準備フェーズ）で全サーバーに「コミット可能か？」を問い合わせ、全員が「YES」ならフェーズ2（コミットフェーズ）で全サーバーに「コミット実行」を指示しますが、1つでも「NO」なら全サーバーでロールバックします。この例では、DB2が「NO（口座が存在しない）」と回答したため、DB1が「YES」と回答していても、両方のデータベースでロールバックを実行します。これにより、「日本の銀行からは引き落とされたが、アメリカの銀行には入金されない」という不整合を防ぎます。2相コミットの重要なポイントは、「全員が成功」または「全員が失敗」のどちらかであり、一部のサーバーだけがコミットすることはありません。"
    },
    {
      "id": "tech-3-3-4-q8",
      "type": "multiple_choice",
      "question": "次の処理のうち、排他制御（ロック）が必要ないものはどれですか？",
      "options": [
        "複数のユーザーが同時に商品一覧を閲覧するだけで、更新はしない",
        "複数のユーザーが同時に在庫数を更新する",
        "複数のユーザーが同時に同じ商品を注文し、在庫を減らす",
        "複数のユーザーが同時に口座残高を更新する"
      ],
      "correctAnswer": 0,
      "explanation": "「複数のユーザーが同時に商品一覧を閲覧するだけで、更新はしない」が正しいです。排他制御（ロック）は、複数のトランザクションが同時に同じデータを更新する際、データの整合性を保つための仕組みです。データを「読み取るだけ（更新しない）」であれば、複数のユーザーが同時に読み取っても整合性は壊れないため、ロックは必要ありません（ただし、データベースによっては、読み取り中のデータが他のトランザクションによって更新されないように共有ロックを取得する場合もあります）。選択肢2、3、4は、いずれも「更新」が含まれるため、排他制御が必要です。例えば、選択肢2の「在庫数を更新」では、ユーザー1とユーザー2が同時に在庫10個を読み取り、ユーザー1が5個に更新、ユーザー2が5個に更新すると、本来0個のはずが5個になってしまいます。これを防ぐには、在庫を読み取る時点で専有ロックを取得し、他のトランザクションが在庫を読み取ることも更新することも禁止する必要があります。"
    },
    {
      "id": "tech-3-3-4-q9",
      "type": "multiple_choice",
      "question": "ロールフォワード（Roll Forward）とロールバック（Roll Back）の違いとして正しいものはどれですか？",
      "options": [
        "ロールフォワードは未コミットトランザクションを復元、ロールバックはコミット済みトランザクションを取り消し",
        "ロールフォワードはコミット済みトランザクションを復元、ロールバックは未コミットトランザクションを取り消し",
        "ロールフォワードとロールバックは同じ意味で、どちらも未コミットトランザクションを取り消し",
        "ロールフォワードとロールバックは同じ意味で、どちらもコミット済みトランザクションを復元"
      ],
      "correctAnswer": 1,
      "explanation": "「ロールフォワードはコミット済みトランザクションを復元、ロールバックは未コミットトランザクションを取り消し」が正しいです。リカバリ処理では、システム障害発生時に、①ロールフォワード（Roll Forward）：チェックポイント後のログを再生し、コミット済みトランザクションを復元、②ロールバック（Roll Back）：ログを逆再生して未コミットトランザクションを取り消し、の2つを実行します。例えば、チェックポイント後にトランザクション1（T1）がコミット、トランザクション2（T2）が開始し、T2がコミット前に障害が発生した場合、T1の変更はロールフォワードで復元し（コミット済みのため、障害発生後も変更を反映させる）、T2の変更はロールバックで取り消します（未コミットのため、トランザクション開始前の状態に戻す）。ロールフォワードは「前に進む（コミット済みデータを復元）」、ロールバックは「後ろに戻る（未コミットデータを取り消し）」というイメージです。システム障害時は両方を実行することで、ACID特性を満たすリカバリが可能になります。"
    },
    {
      "id": "tech-3-3-4-q10",
      "type": "multiple_choice",
      "question": "ロックの粒度（範囲）を「行レベル」から「表レベル」に変更した場合、どのような影響がありますか？",
      "options": [
        "並行性が向上し、複数のトランザクションが同時に実行できるようになる",
        "並行性が低下し、複数のトランザクションが同時に実行しにくくなる",
        "デッドロックが発生しやすくなる",
        "リカバリ時間が長くなる"
      ],
      "correctAnswer": 1,
      "explanation": "「並行性が低下し、複数のトランザクションが同時に実行しにくくなる」が正しいです。ロックの粒度（範囲）には、①行レベルロック（1行のみロック）、②ページレベルロック（複数行を含むページ単位）、③表レベルロック（表全体をロック）、があります。粒度が細かい（行レベル）ほど並行性が高く、粒度が粗い（表レベル）ほど並行性が低下します。例えば、行レベルロックでは、ユーザー1が商品ID=1を更新中、ユーザー2は商品ID=2を更新できます（異なる行なので同時実行可能）。しかし、表レベルロックでは、ユーザー1が商品表全体をロックするため、ユーザー2は商品ID=2を更新できず、ユーザー1が終わるまで待機する必要があります（並行性が低下）。一方、表レベルロックは管理が簡単で、ロックの数が少なく、オーバーヘッドが小さいという利点があります。選択肢3の「デッドロックが発生しやすくなる」は誤りです（むしろ、粒度が粗いほどロックの数が少なく、デッドロックが発生しにくくなります）。選択肢4の「リカバリ時間が長くなる」は、ロックの粒度とは無関係です。"
    }
  ]
}
