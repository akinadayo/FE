{
  "topicId": "tech-4-2-1",
  "title": "モジュール設計",
  "questions": [
    {
      "id": "tech-4-2-1-q1",
      "type": "multiple_choice",
      "question": "モジュール分割の目的として、最も適切でないものはどれか。",
      "options": [
        "複雑さの軽減：大きなプログラムを小さな部品に分割し、理解しやすくする",
        "開発効率の向上：複数人で並行開発できる",
        "プログラムの実行速度を必ず10倍以上に向上させる",
        "保守性の向上：バグ修正や機能追加時に、該当モジュールだけを修正すれば良い"
      ],
      "correctAnswer": 2,
      "explanation": "「プログラムの実行速度を必ず10倍以上に向上させる」は誤りです。モジュール分割の目的は、複雑さの軽減、開発効率の向上、再利用性の向上、保守性の向上、テストの容易化であり、実行速度の向上は主目的ではありません。むしろ、モジュール間の呼び出しオーバーヘッドにより、わずかに速度が低下する場合もあります。ただし、開発効率の向上や保守性の向上により、結果的にバグが減り、最適化の時間が取れるため、品質の高いプログラムを作れるというメリットはあります。モジュール設計は、実行速度よりも開発効率と保守性を重視します。"
    },
    {
      "id": "tech-4-2-1-q2",
      "type": "multiple_choice",
      "question": "良いモジュール設計の基本原則として、最も適切なものはどれか。",
      "options": [
        "高凝集度・高結合度",
        "低凝集度・低結合度",
        "高凝集度・低結合度",
        "低凝集度・高結合度"
      ],
      "correctAnswer": 2,
      "explanation": "良いモジュール設計の基本原則は「高凝集度・低結合度」です。高凝集度（High Cohesion）は、モジュール内の要素が密接に関連し、単一の明確な役割を持つことを意味します。低結合度（Low Coupling）は、モジュール間の依存関係が少なく、独立性が高いことを意味します。これにより、各モジュールが独立性を持ち、変更の影響が局所化され、保守性が向上します。例えば、機能的凝集（単一の明確な機能）のモジュールをデータ結合（引数のみでやり取り）で連携させることが理想です。"
    },
    {
      "id": "tech-4-2-1-q3",
      "type": "multiple_choice",
      "question": "STS分割（Source-Transform-Sink）の説明として、最も適切なものはどれか。",
      "options": [
        "トランザクション（処理単位）ごとにモジュールを分割する技法",
        "データの流れに着目し、入力（Source）、変換（Transform）、出力（Sink）の3つのモジュールに分割する技法",
        "共通して使う機能を抽出して共通モジュールとする技法",
        "モジュールの独立性を高めるため、グローバル変数を多用する技法"
      ],
      "correctAnswer": 1,
      "explanation": "STS分割（Source-Transform-Sink）は、データの流れに着目し、①入力（Source）：データを取得する、②変換（Transform）：データを加工・処理する、③出力（Sink）：結果を出力する、の3つのモジュールに分割する技法です。例えば、給与計算システムでは、①勤務データファイル（CSV）を読み込む（入力モジュール）、②給与を計算する（変換モジュール）、③給与明細をPDFで出力する（出力モジュール）、と分割します。選択肢1はTR分割、選択肢3は共通機能分割、選択肢4は誤り（グローバル変数の多用は結合度を高め、望ましくない）です。STS分割は、データ処理システムやバッチ処理に適しています。"
    },
    {
      "id": "tech-4-2-1-q4",
      "type": "multiple_choice",
      "question": "TR分割（Transaction分割）の説明として、最も適切なものはどれか。",
      "options": [
        "データの流れに着目し、入力、変換、出力の3つのモジュールに分割する技法",
        "トランザクション（処理単位）ごとにモジュールを分割する技法で、オンラインシステムやWebアプリに適している",
        "モジュールの凝集度を低くして、複数の無関係な処理を1つのモジュールにまとめる技法",
        "すべてのモジュールでグローバル変数を共有する技法"
      ],
      "correctAnswer": 1,
      "explanation": "TR分割（Transaction分割）は、トランザクション（処理単位）ごとにモジュールを分割する技法で、オンラインシステムやWebアプリに適しています。例えば、ECサイトでは、①ユーザー登録モジュール（入力チェック、パスワード暗号化、DB登録）、②商品購入モジュール（在庫チェック、注文データ作成、在庫減少、決済処理）、③注文キャンセルモジュール（キャンセル可否チェック、注文削除、在庫復元、返金処理）、とトランザクションごとに分割します。各トランザクションが独立しており、例えば決済方法の変更は商品購入モジュールだけ修正すれば良いというメリットがあります。選択肢1はSTS分割、選択肢3と4は誤りです。"
    },
    {
      "id": "tech-4-2-1-q5",
      "type": "multiple_choice",
      "question": "結合度の種類の中で、最も望ましい（結合度が低い）ものはどれか。",
      "options": [
        "内容結合：他モジュールの内部を直接参照・変更",
        "外部結合：外部変数（グローバル変数）を共有",
        "データ結合：引数（パラメータ）のみでデータをやり取り",
        "共通結合：共通領域（グローバルメモリ）を共有"
      ],
      "correctAnswer": 2,
      "explanation": "結合度の中で最も望ましい（結合度が低い）のは「データ結合」です。データ結合は、モジュール間のやり取りを引数（パラメータ）のみに限定し、必要最小限のデータだけを渡します。これにより、モジュールの独立性が高まり、変更の影響が局所化されます。例：add(a, b)という関数は、引数a, bを受け取り、結果を返すだけで、グローバル変数を使いません。逆に、内容結合、共通結合、外部結合は結合度が強く、避けるべきです。グローバル変数を多用すると、どこでどの変数が変更されたか追跡困難になり、バグの温床となります。"
    },
    {
      "id": "tech-4-2-1-q6",
      "type": "multiple_choice",
      "question": "凝集度の種類の中で、最も望ましい（凝集度が高い）ものはどれか。",
      "options": [
        "偶発的凝集：無関係な処理を寄せ集め",
        "論理的凝集：論理的に似た複数の処理を1つにまとめる",
        "機能的凝集：単一の明確な機能を実行",
        "時間的凝集：実行タイミングで関連する複数の処理"
      ],
      "correctAnswer": 2,
      "explanation": "凝集度の中で最も望ましい（凝集度が高い）のは「機能的凝集」です。機能的凝集は、モジュールが単一の明確な機能だけを実行します。例：calculateTax(price)という関数は、価格から消費税を計算するだけの単一機能です。これにより、モジュールの役割が明確で、理解しやすく、再利用しやすくなります。機能的凝集のモジュールは、「単一責任の原則（Single Responsibility Principle）」に従っており、1つのモジュールは1つの責任（機能）のみを持つべきです。逆に、偶発的凝集、論理的凝集は凝集度が低く、避けるべきです。例えば、「なんでもやる関数」は、複数の無関係な処理を含むため、理解困難で、変更時に予期しない副作用が発生しやすくなります。"
    },
    {
      "id": "tech-4-2-1-q7",
      "type": "multiple_choice",
      "question": "グローバル変数を多用したモジュール設計の問題点として、最も適切でないものはどれか。",
      "options": [
        "どこでどの変数が変更されたか追跡困難になる",
        "複数のモジュールが同じグローバル変数を変更すると、バグの原因が特定しにくい",
        "並行処理でグローバル変数が予期しない値になる可能性（競合状態）がある",
        "プログラムのメモリ使用量が必ず10倍以上に増加する"
      ],
      "correctAnswer": 3,
      "explanation": "「プログラムのメモリ使用量が必ず10倍以上に増加する」は誤りです。グローバル変数を多用しても、メモリ使用量が必ず大幅に増加するわけではありません。グローバル変数の問題点は、①どこで変更されたか追跡困難、②複数モジュールが変更すると副作用のリスク大、③並行処理で競合状態が発生、④テストが困難、⑤結合度が強くなり保守性が低下、などです。これは外部結合（結合度が強い）になり、モジュールの独立性が低下します。良い設計では、グローバル変数を避け、データ結合（引数と戻り値でやり取り）に変更すべきです。"
    },
    {
      "id": "tech-4-2-1-q8",
      "type": "multiple_choice",
      "question": "単一責任の原則（Single Responsibility Principle）の説明として、最も適切なものはどれか。",
      "options": [
        "1つのモジュールは複数の責任（機能）を持ち、変更する理由も複数あるべき",
        "1つのモジュールは1つの責任（機能）のみを持つべきで、変更する理由も1つだけであるべき",
        "すべてのモジュールでグローバル変数を共有すべき",
        "モジュール分割は行わず、1つの大きなプログラムとして開発すべき"
      ],
      "correctAnswer": 1,
      "explanation": "単一責任の原則（Single Responsibility Principle）は、「1つのモジュールは1つの責任（機能）のみを持つべきで、変更する理由も1つだけであるべき」という原則です。例：registerUser()はユーザー登録のみを行い、税計算や売上集計は行いません。これにより、①モジュールの役割が明確、②独立性が高まる、③変更の影響が局所化、④再利用しやすい、⑤テストしやすい、などのメリットがあります。これは機能的凝集（単一の明確な機能）に対応しており、良いモジュール設計の基本です。逆に、1つのモジュールで複数の無関係な処理を行うと、偶発的凝集（凝集度が低い）になり、保守性が低下します。"
    },
    {
      "id": "tech-4-2-1-q9",
      "type": "multiple_choice",
      "question": "以下のコードの結合度と凝集度の評価として、最も適切なものはどれか。\n\nint total = 0;  // グローバル変数\nvoid addPrice(int price) { total += price; }\nvoid showTotal() { printf(\"%d円\", total); }",
      "options": [
        "データ結合（結合度が低い）、機能的凝集（凝集度が高い）で、良い設計",
        "外部結合（結合度が強い）、機能的凝集（凝集度が高い）で、結合度を改善すべき",
        "データ結合（結合度が低い）、偶発的凝集（凝集度が低い）で、凝集度を改善すべき",
        "外部結合（結合度が強い）、偶発的凝集（凝集度が低い）で、両方改善すべき"
      ],
      "correctAnswer": 1,
      "explanation": "このコードは「外部結合（結合度が強い）、機能的凝集（凝集度が高い）」です。グローバル変数totalを使用しているため、外部結合（結合度が強い）になっています。これは避けるべき設計で、データ結合（引数と戻り値でやり取り）に変更すべきです。一方、各関数（addPrice、showTotal）は単一の明確な機能を実行しているため、機能的凝集（凝集度が高い）です。改善策は、int addPrice(int total, int price) { return total + price; } のように、グローバル変数を排除し、引数と戻り値でやり取りするデータ結合に変更することです。これにより、①変更箇所が明確、②関数が独立し再利用しやすい、③テストが容易、④並行処理でも安全、になります。"
    },
    {
      "id": "tech-4-2-1-q10",
      "type": "multiple_choice",
      "question": "モジュール設計の評価基準として、最も適切でないものはどれか。",
      "options": [
        "独立性：他のモジュールへの依存が少なく、単独でテスト可能か",
        "理解しやすさ：モジュールの役割が明確で、コードを読めばすぐに理解できるか",
        "モジュールのコード行数：すべてのモジュールが必ず1000行以上であるべき",
        "再利用しやすさ：他のプロジェクトでもそのまま使えるか"
      ],
      "correctAnswer": 2,
      "explanation": "「モジュールのコード行数：すべてのモジュールが必ず1000行以上であるべき」は誤りです。モジュールサイズは、大きすぎず小さすぎないことが重要で、一般的には50～200行程度（1画面で見渡せる範囲）が目安です。1000行以上のモジュールは大きすぎて理解困難になり、複数の責任を持つ可能性が高く、凝集度が低下します。正しいモジュール設計の評価基準は、①独立性（単独でテスト可能か）、②理解しやすさ（役割が明確か）、③変更しやすさ（該当モジュールだけ修正すれば良いか）、④再利用しやすさ（他プロジェクトでも使えるか）、⑤テストしやすさ（単体テストで動作確認できるか）、などです。適切なサイズのモジュールは、単一責任の原則に従い、機能的凝集を実現します。"
    }
  ]
}
