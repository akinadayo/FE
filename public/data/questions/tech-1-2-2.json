{
  "topicId": "tech-1-2-2",
  "title": "誤差",
  "questions": [
    {
      "id": "q-tech-1-2-2-001",
      "type": "multiple_choice",
      "question": "桁あふれ誤差（オーバーフロー）が発生する原因はどれですか？",
      "options": [
        "計算結果が表現可能な範囲を超えた",
        "有効桁数が不足した",
        "小数点以下を切り捨てた",
        "絶対値の大きな数から小さな数を引いた"
      ],
      "correctAnswer": 0,
      "explanation": "桁あふれ誤差（オーバーフロー）は、計算結果が表現可能な範囲を超えた場合に発生します。\n\n例（8ビット符号なし整数の場合）：\n・表現範囲：0～255\n・200 + 100 = 300（実際の値）\n・しかし、255を超えるため桁あふれが発生\n・結果が不正確になる（例：44になる）\n\n浮動小数点数でも、指数部の範囲を超えると桁あふれが発生し、∞（無限大）やエラーになります。\n\n対策：より大きなデータ型を使用する、範囲チェックを行う。"
    },
    {
      "id": "q-tech-1-2-2-002",
      "type": "multiple_choice",
      "question": "次の演算のうち、「情報落ち」が発生する可能性が最も高いのはどれですか？",
      "options": [
        "1000000 + 1",
        "1000000 + 0.0001",
        "10 × 100",
        "100 - 50"
      ],
      "correctAnswer": 1,
      "explanation": "情報落ちは、絶対値が大きく異なる数値を加減算した際、小さい方の数値の情報が失われる現象です。\n\n1000000 + 0.0001の場合：\n浮動小数点数の仮数部の有効桁数が限られているため、0.0001の情報が失われ、結果が1000000のままになる可能性があります。\n\n例（有効桁数7桁の場合）：\n1000000 + 0.0001 = 1000000（0.0001が無視される）\n\n対策：\n・小さい数から順に加算する\n・同じ桁数の数値同士で計算する\n・より高精度のデータ型を使用する"
    },
    {
      "id": "q-tech-1-2-2-003",
      "type": "multiple_choice",
      "question": "「桁落ち」が発生しやすい演算はどれですか？",
      "options": [
        "大きな数同士の加算",
        "ほぼ等しい2つの数の減算",
        "小さな数同士の乗算",
        "整数同士の除算"
      ],
      "correctAnswer": 1,
      "explanation": "桁落ちは、ほぼ等しい2つの数値の減算で発生し、有効桁数が大幅に減少する現象です。\n\n例：\n1.234567 - 1.234512 = 0.000055\n\n元の数値は7桁の精度がありましたが、結果は2桁の有効数字しか持ちません。\n上位の桁が相殺され、下位の桁（誤差を含む可能性が高い部分）だけが残るため、精度が著しく低下します。\n\n対策：\n・数式を変形して減算を避ける\n・例：√(x+1) - √x = 1/(√(x+1) + √x) のように変形"
    },
    {
      "id": "q-tech-1-2-2-004",
      "type": "multiple_choice",
      "question": "「打切り誤差」が発生する原因はどれですか？",
      "options": [
        "データ型の範囲を超えた",
        "無限級数や反復計算を途中で打ち切った",
        "小数点以下を切り捨てた",
        "大きな数と小さな数を加算した"
      ],
      "correctAnswer": 1,
      "explanation": "打切り誤差（truncation error）は、本来無限に続く計算を有限回で打ち切ることで発生する誤差です。\n\n発生例：\n1. 無限級数の近似\n   e^x = 1 + x + x²/2! + x³/3! + ...\n   →有限項で打ち切る\n\n2. 反復計算の途中終了\n   ニュートン法などで十分な精度に達する前に終了\n\n3. 微分・積分の数値計算\n   差分や区分求積法で刻み幅を有限に設定\n\n対策：\n・反復回数を増やす\n・収束判定条件を適切に設定する\n・より精度の高いアルゴリズムを使用する"
    },
    {
      "id": "q-tech-1-2-2-005",
      "type": "multiple_choice",
      "question": "「丸め誤差」が発生する主な原因はどれですか？",
      "options": [
        "計算途中でオーバーフローした",
        "有限桁数で数値を表現するため端数処理した",
        "計算を途中で打ち切った",
        "絶対値の差が大きい数を計算した"
      ],
      "correctAnswer": 1,
      "explanation": "丸め誤差（rounding error）は、有限桁数で数値を表現する際、表現できない部分を丸める（四捨五入、切り捨て、切り上げ）ことで発生します。\n\n例：\n・1/3 = 0.333333...を小数点以下6桁で表現\n  →0.333333（丸め誤差が発生）\n\n・浮動小数点数での0.1の表現\n  →2進数で正確に表現できず、近似値を使用\n\n丸め誤差の累積：\n多数の演算を繰り返すと、小さな丸め誤差が累積して大きな誤差になる可能性があります。\n\n対策：\n・より高精度のデータ型を使用\n・丸めモード（最近接偶数への丸めなど）を適切に選択"
    },
    {
      "id": "q-tech-1-2-2-006",
      "type": "multiple_choice",
      "question": "次の誤差のうち、計算の順序を工夫することで軽減できる可能性が最も高いのはどれですか？",
      "options": ["桁あふれ誤差", "情報落ち", "打切り誤差", "丸め誤差"],
      "correctAnswer": 1,
      "explanation": "情報落ちは、計算の順序を工夫することで軽減できます。\n\n改善例：\n悪い例：1000000 + 0.1 + 0.1 + 0.1 + ...\n  →小さな値が失われやすい\n\n良い例：0.1 + 0.1 + 0.1 + ... + 1000000\n  →小さな値を先に加算してから大きな値を加算\n\nまたは：(0.1 + 0.1 + ...) + 1000000\n  →小さな値をまとめてから大きな値と計算\n\nカハン（Kahan）の加算アルゴリズムなど、情報落ちを軽減する特殊なアルゴリズムも存在します。\n\n桁あふれ誤差や打切り誤差は、計算順序ではなく、データ型や反復回数の調整が必要です。"
    },
    {
      "id": "q-tech-1-2-2-007",
      "type": "multiple_choice",
      "question": "浮動小数点数で 10^20 + 1 - 10^20 を計算したとき、理論上は1になるべきですが、実際には0になる可能性があります。これは何という誤差ですか？",
      "options": ["桁あふれ誤差", "情報落ち", "桁落ち", "打切り誤差"],
      "correctAnswer": 1,
      "explanation": "これは情報落ちの典型的な例です。\n\n計算過程：\n1. 10^20 + 1を計算\n   →浮動小数点数の精度が不足し、1の情報が失われる\n   →結果は10^20のまま\n\n2. 10^20 - 10^20を計算\n   →結果は0\n\n理論値：10^20 + 1 - 10^20 = 1\n実際の結果：0（情報落ちにより）\n\n計算順序を変更すれば改善できます：\n(10^20 - 10^20) + 1 = 0 + 1 = 1\n\nまたは結合法則を利用：\n1 + (10^20 - 10^20) = 1 + 0 = 1\n\nこのように、情報落ちは演算順序の工夫で軽減可能です。"
    },
    {
      "id": "q-tech-1-2-2-008",
      "type": "multiple_choice",
      "question": "アンダーフロー（桁下がり誤差）が発生するのはどのような場合ですか？",
      "options": [
        "計算結果が大きすぎて表現できない",
        "計算結果が小さすぎて表現できない",
        "有効桁数が不足した",
        "無限ループが発生した"
      ],
      "correctAnswer": 1,
      "explanation": "アンダーフロー（underflow）は、計算結果の絶対値が小さすぎて、浮動小数点数で表現できる最小値を下回った場合に発生します。\n\n例：\n・非常に小さな正の数同士の乗算\n・10^-200 × 10^-200 = 10^-400\n  →多くの浮動小数点形式では表現不可能\n\n結果：\n・多くのシステムでは0として扱われる\n・または特殊な値（denormalized number）になる\n\nオーバーフローとアンダーフローの違い：\n・オーバーフロー：絶対値が大きすぎる（例：10^400）\n・アンダーフロー：絶対値が小さすぎる（例：10^-400）"
    },
    {
      "id": "q-tech-1-2-2-009",
      "type": "multiple_choice",
      "question": "次の計算式のうち、桁落ちを避けるための式変形として適切なものはどれですか？元の式：(√(x²+1) - x) ただし、xは大きな正の数",
      "options": [
        "x - √(x²+1)",
        "1 / (√(x²+1) + x)",
        "√(x²+1) / x",
        "(x² + 1 - x²) / √(x²+1)"
      ],
      "correctAnswer": 1,
      "explanation": "元の式：√(x²+1) - x でxが大きいとき、桁落ちが発生します。\n\n理由：\n・x = 10000のとき\n・√(10000² + 1) ≈ 10000.00005\n・10000.00005 - 10000 = 0.00005\n・上位桁が相殺され、精度が低下\n\n式変形（分子の有理化）：\n√(x²+1) - x\n= (√(x²+1) - x) × (√(x²+1) + x) / (√(x²+1) + x)\n= (x²+1 - x²) / (√(x²+1) + x)\n= 1 / (√(x²+1) + x)\n\n変形後の式では減算がなくなり、桁落ちを回避できます。\nこの手法は「分子の有理化」として知られています。"
    },
    {
      "id": "q-tech-1-2-2-010",
      "type": "multiple_choice",
      "question": "浮動小数点演算で誤差が累積しにくい計算方法はどれですか？",
      "options": [
        "大きな数から小さな数へ順に加算",
        "小さな数から大きな数へ順に加算",
        "ランダムな順序で加算",
        "順序は誤差に影響しない"
      ],
      "correctAnswer": 1,
      "explanation": "小さな数から大きな数へ順に加算する方が、誤差の累積を軽減できます。\n\n理由：\n悪い例（大きい順）：\n1000 + 0.1 + 0.1 + 0.1 + ...\n→0.1が情報落ちで失われやすい\n\n良い例（小さい順）：\n0.1 + 0.1 + 0.1 + ... → 10（小さな値をまとめる）\n10 + 1000 = 1010（大きな値と加算）\n\n具体例：\n1000個の0.1を1000に加算する場合\n・大きい順：結果が1000付近になり、0.1の多くが失われる\n・小さい順：100（=1000×0.1）を作ってから1000と加算\n\nこの原理を利用したアルゴリズムとして、カハンの加算アルゴリズムがあります。"
    }
  ]
}
