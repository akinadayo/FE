{
  "topicId": "tech-3-3-1",
  "title": "データベース方式",
  "questions": [
    {
      "id": "tech-3-3-1-q1",
      "type": "multiple_choice",
      "question": "ファイルシステムとデータベースの比較として、最も適切でないものはどれか。",
      "options": [
        "ファイルシステムは各アプリが個別にデータファイルを持つため、データの重複が発生しやすい",
        "データベースはDBMSがデータを一元管理するため、データの整合性が保たれやすい",
        "ファイルシステムは導入・運用コストが低いが、データベースは導入・運用コストが高い",
        "ファイルシステムはデータ共有が容易で、データベースはデータ共有が困難"
      ],
      "correctAnswer": 3,
      "explanation": "「ファイルシステムはデータ共有が容易で、データベースはデータ共有が困難」は誤りです。実際には逆で、ファイルシステムは各アプリが個別ファイルを持つためデータ共有が困難ですが、データベースはDBMSが一元管理するためデータ共有が容易です。例えば、営業部と経理部が顧客情報を共有する場合、ファイルシステムでは別々のファイルを持つため整合性が取れませんが、データベースでは同じ顧客表を参照するため常に最新の情報を共有できます。その他の選択肢は正しく、ファイルシステムはデータ重複が発生しやすい、データベースは整合性が保たれやすい、ファイルシステムはコストが低いがデータベースはコストが高い、という特徴があります。"
    },
    {
      "id": "tech-3-3-1-q2",
      "type": "multiple_choice",
      "question": "DBMS（データベース管理システム）の主な機能として、最も適切でないものはどれか。",
      "options": [
        "DDL（Data Definition Language）によるデータ定義：CREATE TABLE、ALTER TABLE、DROP TABLEなどの表の作成・変更・削除",
        "DML（Data Manipulation Language）によるデータ操作：SELECT、INSERT、UPDATE、DELETEなどのデータの検索・挿入・更新・削除",
        "DCL（Data Control Language）によるデータ制御：GRANT、REVOKEなどの権限管理、COMMIT、ROLLBACKなどのトランザクション管理",
        "プログラムのコンパイルとデバッグ：Javaやpythonなどのプログラム言語のコンパイルとデバッグを自動で行う"
      ],
      "correctAnswer": 3,
      "explanation": "「プログラムのコンパイルとデバッグ」はDBMSの機能ではありません。これはIDE（統合開発環境）の機能です。DBMSの主な機能は、①DDL（データ定義言語）によるデータ定義（表の作成・変更・削除）、②DML（データ操作言語）によるデータ操作（検索・挿入・更新・削除）、③DCL（データ制御言語）によるデータ制御（権限管理、トランザクション管理）です。例えば、Oracle Database、MySQL、PostgreSQL、SQL ServerなどのDBMSは、SQL文を受け取り、データベースの作成・操作・管理を行いますが、プログラム言語のコンパイルやデバッグは行いません。"
    },
    {
      "id": "tech-3-3-1-q3",
      "type": "multiple_choice",
      "question": "社員表（社員ID、氏名、所属部署ID、入社日）で、社員IDを主キーとする場合、主キーの制約として正しいものはどれか。",
      "options": [
        "社員ID=101が既に存在する場合、新たに社員ID=101を登録すると上書きされる",
        "社員ID=101が既に存在する場合、新たに社員ID=101を登録しようとするとDBMSがエラーを返す",
        "社員IDにNULL（空値）を設定できる",
        "社員IDは任意の項目であり、設定しなくても良い"
      ],
      "correctAnswer": 1,
      "explanation": "主キーには一意性制約があり、「社員ID=101が既に存在する場合、新たに社員ID=101を登録しようとするとDBMSがエラーを返す」が正しいです。主キーは各行を一意に識別するため、同じ値を複数行に登録できません（一意性制約）。例えば、社員ID=101が既に存在する場合、INSERT INTO 社員表 VALUES (101, '田中', 10, '2024-04-01') を実行すると、DBMSは「主キー制約違反」のエラーを返し、登録を拒否します。また、主キーは非NULL制約（NULL値を許容しない）と不変性（一度設定したら変更しない）という特性も持ちます。選択肢1の「上書き」、選択肢3の「NULL設定可能」、選択肢4の「任意」は誤りです。"
    },
    {
      "id": "tech-3-3-1-q4",
      "type": "multiple_choice",
      "question": "社員表（社員ID、氏名、所属部署ID、入社日）と部署表（部署ID、部署名）があり、社員表の所属部署IDが部署表の部署IDを参照する外部キーである場合、参照整合性制約の説明として正しいものはどれか。",
      "options": [
        "部署表に存在しない部署ID=999を、社員表の所属部署IDに登録できる",
        "部署表に存在しない部署ID=999を、社員表の所属部署IDに登録しようとするとDBMSがエラーを返す",
        "社員表の所属部署IDはNULLを許容しない（非NULL制約）",
        "部署表の部署IDを削除すると、社員表の所属部署IDも自動的に削除される"
      ],
      "correctAnswer": 1,
      "explanation": "参照整合性制約により、「部署表に存在しない部署ID=999を、社員表の所属部署IDに登録しようとするとDBMSがエラーを返す」が正しいです。外部キーは他の表の主キーを参照するため、「存在しない値」を参照できません。例えば、部署表に部署ID=10（営業部）、部署ID=20（経理部）のみが存在する場合、社員表に所属部署ID=999を登録しようとすると、DBMSは「参照整合性制約違反」のエラーを返し、登録を拒否します。選択肢1の「登録できる」は誤り、選択肢3の「NULLを許容しない」は一般的には誤り（外部キーはNULLを許容することが多い）、選択肢4の「自動削除」は CASCADE オプション設定時のみ有効で、デフォルトでは誤りです。参照整合性制約により、データベース全体の整合性が保たれます。"
    },
    {
      "id": "tech-3-3-1-q5",
      "type": "multiple_choice",
      "question": "3層スキーマアーキテクチャの説明として、最も適切でないものはどれか。",
      "options": [
        "外部スキーマ：各ユーザー・アプリケーションごとの見え方で、営業部は顧客情報のみ閲覧、経理部は売上情報のみ閲覧など、ビューで定義する",
        "概念スキーマ：データベース全体の論理的構造で、全ての表、列、主キー、外部キー、制約などを定義する",
        "内部スキーマ：データの物理的な格納方法で、ファイル構造、インデックス、ストレージの配置などを定義する",
        "3層スキーマアーキテクチャを採用すると、データ独立性が失われ、アプリケーション変更時にデータベース全体を変更する必要がある"
      ],
      "correctAnswer": 3,
      "explanation": "「3層スキーマアーキテクチャを採用すると、データ独立性が失われる」は誤りです。実際には逆で、3層スキーマアーキテクチャはデータ独立性を実現するための仕組みです。データ独立性には、①論理的独立性（概念スキーマを変更しても外部スキーマに影響しない。例：新しい表を追加しても既存アプリは変更不要）、②物理的独立性（内部スキーマを変更しても概念スキーマに影響しない。例：HDDからSSDに変更してもアプリは変更不要）、の2種類があります。3層スキーマアーキテクチャにより、各層が独立し、一部の変更が他の層に影響を与えないため、保守性が向上します。その他の選択肢は正しく、外部スキーマはユーザービュー、概念スキーマは論理構造、内部スキーマは物理構造を定義します。"
    },
    {
      "id": "tech-3-3-1-q6",
      "type": "multiple_choice",
      "question": "トランザクションのACID特性の説明として、最も適切でないものはどれか。",
      "options": [
        "原子性（Atomicity）：トランザクション内の全ての処理が成功するか、全て失敗するかのいずれかで、途中の状態は存在しない",
        "一貫性（Consistency）：トランザクション実行前後でデータベースの整合性が保たれる（例：振込前後で総残高は変わらない）",
        "独立性（Isolation）：複数のトランザクションが同時実行されても、互いに影響を与えない（例：並行実行時も他のトランザクションの途中結果を見ない）",
        "永続性（Durability）：コミット後のデータは、システム障害が発生しても自動的に削除される"
      ],
      "correctAnswer": 3,
      "explanation": "「永続性：コミット後のデータは、システム障害が発生しても自動的に削除される」は誤りです。永続性（Durability）の正しい説明は、「コミット後のデータは、システム障害が発生しても永続的に保存される」です。例えば、振込トランザクションがコミットされた後、停電やシステムクラッシュが発生しても、データベースは再起動時にコミット済みの変更を復元し、データを失いません。ACID特性は、①原子性（全て成功 or 全て失敗）、②一貫性（整合性を保つ）、③独立性（他トランザクションの影響を受けない）、④永続性（コミット後は永続的に保存）、の4つで、データベースの信頼性を保証します。その他の選択肢は正しく、トランザクション管理の基本原則を表しています。"
    },
    {
      "id": "tech-3-3-1-q7",
      "type": "multiple_choice",
      "question": "銀行振込のトランザクション処理で、「Aさんの口座から10,000円を引き落とし、Bさんの口座に10,000円を振り込む」という処理を行う場合、トランザクションの実行結果として正しいものはどれか。ただし、Aさんの口座残高が5,000円しかない場合を考える。",
      "options": [
        "Aさんの口座から10,000円を引き落とし（残高-5,000円）、Bさんの口座に10,000円を振り込む（両方実行）",
        "Aさんの口座から5,000円のみ引き落とし、Bさんの口座に5,000円のみ振り込む（一部実行）",
        "残高不足エラーが発生し、ROLLBACK（ロールバック）により、Aさん・Bさんともに残高は変更されない（全て失敗）",
        "Aさんの口座のみ引き落とし、Bさんの口座は変更されない（一方のみ実行）"
      ],
      "correctAnswer": 2,
      "explanation": "トランザクションの原子性（Atomicity）により、「残高不足エラーが発生し、ROLLBACK（ロールバック）により、Aさん・Bさんともに残高は変更されない（全て失敗）」が正しいです。トランザクションは「全て成功 or 全て失敗」のいずれかであり、途中の状態は存在しません。この例では、①Aさんの口座から10,000円引き落とし（残高チェックで5,000円しかないためエラー）、②エラー発生により、ROLLBACK（ロールバック）を実行し、トランザクション開始前の状態に戻す、③Aさん・Bさんともに残高は変更されない、という流れになります。選択肢1の「残高マイナス」、選択肢2の「一部実行」、選択肢4の「一方のみ実行」は、トランザクションの原子性に違反するため誤りです。原子性により、データベースの整合性が保たれます。"
    },
    {
      "id": "tech-3-3-1-q8",
      "type": "multiple_choice",
      "question": "DDL（Data Definition Language）、DML（Data Manipulation Language）、DCL（Data Control Language）の分類として、最も適切でないものはどれか。",
      "options": [
        "CREATE TABLE、ALTER TABLE、DROP TABLEはDDL（データ定義言語）に分類される",
        "SELECT、INSERT、UPDATE、DELETEはDML（データ操作言語）に分類される",
        "GRANT、REVOKEはDCL（データ制御言語）に分類される",
        "COMMIT、ROLLBACKはDDL（データ定義言語）に分類される"
      ],
      "correctAnswer": 3,
      "explanation": "「COMMIT、ROLLBACKはDDL（データ定義言語）に分類される」は誤りです。COMMIT、ROLLBACKはDCL（データ制御言語、Data Control Language）に分類されます。DDL、DML、DCLの正しい分類は、①DDL（データ定義言語）：CREATE（表作成）、ALTER（表変更）、DROP（表削除）など、データベースの構造を定義する命令、②DML（データ操作言語）：SELECT（検索）、INSERT（挿入）、UPDATE（更新）、DELETE（削除）など、データを操作する命令、③DCL（データ制御言語）：GRANT（権限付与）、REVOKE（権限剥奪）、COMMIT（トランザクション確定）、ROLLBACK（トランザクション取り消し）など、データベースの制御を行う命令、です。その他の選択肢は正しく、SQLはDDL、DML、DCLの3つに分類されます。"
    },
    {
      "id": "tech-3-3-1-q9",
      "type": "multiple_choice",
      "question": "参照整合性制約の削除時・更新時のオプションの説明として、最も適切でないものはどれか。",
      "options": [
        "RESTRICT（制限）：参照されている行は削除・更新できず、エラーを返す。例：部署ID=10に所属する社員が存在する場合、部署ID=10を削除できない",
        "CASCADE（連鎖）：参照元も一緒に削除・更新する。例：部署ID=10を削除すると、所属部署ID=10の全社員も自動的に削除される",
        "SET NULL：参照元の外部キーをNULLに設定する。例：部署ID=10を削除すると、所属部署ID=10の社員の所属部署IDがNULLに変更される",
        "DELETE ALL：参照元・参照先の両方を完全に削除する。例：部署ID=10を削除すると、部署表と社員表の全データが削除される"
      ],
      "correctAnswer": 3,
      "explanation": "「DELETE ALL：参照元・参照先の両方を完全に削除する」は誤りです。DELETE ALLという参照整合性制約のオプションは存在しません。正しい参照整合性制約の削除時・更新時のオプションは、①RESTRICT（制限）：参照されている行は削除・更新不可（エラー）、②CASCADE（連鎖）：参照元も一緒に削除・更新、③SET NULL：参照元の外部キーをNULLに設定、の3つです。例えば、社員表（所属部署ID：外部キー）と部署表（部署ID：主キー）がある場合、ON DELETE CASCADEを設定すると、部署ID=10を削除した際に所属部署ID=10の全社員も自動削除されます。逆に、ON DELETE RESTRICTを設定すると、所属社員が存在する場合は部署を削除できません。参照整合性制約により、データベースの整合性が保たれます。"
    },
    {
      "id": "tech-3-3-1-q10",
      "type": "multiple_choice",
      "question": "データベース方式の利点として、最も適切でないものはどれか。",
      "options": [
        "データの一元管理により、データの重複を排除し、整合性を保つことができる",
        "主キー・外部キー制約、トランザクション管理により、データ整合性を保証できる",
        "複数のユーザーやアプリケーションが同時にデータにアクセスでき、データ共有が容易である",
        "導入・運用コストがファイルシステムより低く、小規模システムでも必ず採用すべき"
      ],
      "correctAnswer": 3,
      "explanation": "「導入・運用コストがファイルシステムより低く、小規模システムでも必ず採用すべき」は誤りです。データベースの導入・運用コストはファイルシステムより高く、DBMS製品のライセンス費用、サーバーの運用・保守費用、専門知識を持つ人材の確保などが必要です。小規模システム（例：個人の日記アプリ、単純なログ記録）では、ファイルシステムの方が適している場合もあります。データベース方式の主な利点は、①データの一元管理（重複排除、整合性保持）、②データ整合性の保証（主キー・外部キー制約、トランザクション管理）、③データ共有の容易化（複数ユーザー・アプリが同時アクセス）、④データ独立性（アプリとデータ構造の分離）、⑤セキュリティ（アクセス制御、暗号化）、などです。システムの規模や要件に応じて、ファイルシステムとデータベースを使い分けることが重要です。"
    }
  ]
}
