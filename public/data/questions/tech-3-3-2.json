{
  "topicId": "tech-3-3-2",
  "title": "データベース設計",
  "questions": [
    {
      "id": "tech-3-3-2-q1",
      "type": "multiple_choice",
      "question": "正規化の目的として、最も適切でないものはどれか。",
      "options": [
        "データの重複を排除し、同じデータを複数箇所に保存しないようにする",
        "更新異常を防ぎ、データ更新時の不整合を防止する",
        "プログラムの実行速度を必ず10倍以上に向上させる",
        "削除異常を防ぎ、データ削除時の意図しない情報損失を防止する"
      ],
      "correctAnswer": 2,
      "explanation": "「プログラムの実行速度を必ず10倍以上に向上させる」は誤りです。正規化の目的は実行速度の向上ではなく、データの品質向上です。正規化の正しい目的は、①データの重複排除（同じデータを複数箇所に保存しない）、②更新異常の防止（データ更新時の不整合を防ぐ）、③挿入異常の防止（新規データ登録時の問題を防ぐ）、④削除異常の防止（データ削除時の意図しない情報損失を防ぐ）です。むしろ、正規化により表が分割されると、結合（JOIN）が必要になり、実行速度がわずかに低下する場合もあります。ただし、データの整合性が保たれ、保守性が向上するため、長期的にはシステムの品質が向上します。"
    },
    {
      "id": "tech-3-3-2-q2",
      "type": "multiple_choice",
      "question": "以下の受講表で、佐藤の学科を「情報」から「AI」に変更する場合、どのような問題が発生するか。\n\n学生ID | 学生名 | 学科 | 受講科目\n101 | 佐藤 | 情報 | 数学\n101 | 佐藤 | 情報 | 英語\n101 | 佐藤 | 情報 | プログラミング",
      "options": [
        "挿入異常：新しい学科「AI」を登録できない",
        "削除異常：佐藤の学生情報が消える",
        "更新異常：3行全てを更新する必要があり、一部だけ更新すると学科が「情報」と「AI」に分裂する",
        "正規化されているため、問題は発生しない"
      ],
      "correctAnswer": 2,
      "explanation": "「更新異常」が発生します。この表は第1正規形ですが、学生名と学科が重複しています（佐藤と情報が3回ずつ出現）。佐藤の学科を「AI」に変更する場合、①理想的には3行全てを更新する必要がありますが、②もし3行のうち1行だけ「AI」に更新してしまうと、学科が「情報」（2行）と「AI」（1行）に分裂し、データの不整合が発生します。これが更新異常です。この問題を解決するには、第2正規形に変換し、学生表（学生ID, 学生名, 学科）と受講表（学生ID, 受講科目）に分割する必要があります。分割後は、学生表の1行のみ更新すれば良く、更新異常が解消されます。選択肢1の挿入異常、選択肢2の削除異常は、この状況では発生しません。"
    },
    {
      "id": "tech-3-3-2-q3",
      "type": "multiple_choice",
      "question": "関数従属の記法 A → B の意味として、最も適切なものはどれか。",
      "options": [
        "AとBは同じ値を持つ",
        "Aの値が決まれば、Bの値が一意に決まる",
        "Bの値が決まれば、Aの値が一意に決まる",
        "AとBは無関係である"
      ],
      "correctAnswer": 1,
      "explanation": "関数従属の記法 A → B は、「Aの値が決まれば、Bの値が一意に決まる」という意味です。これは「AがBを関数的に決定する」または「BはAに関数従属する」と読みます。例えば、社員ID → 氏名 の場合、社員ID=101 が決まれば、氏名は「佐藤太郎」と一意に決まります（社員ID=101 の人が複数の氏名を持つことはありません）。逆に、選択肢3の「Bの値が決まれば、Aの値が一意に決まる」は B → A であり、A → B とは逆の関係です。例えば、氏名 → 社員ID の場合、氏名「佐藤太郎」が決まっても、社員IDは複数の可能性があるため（同姓同名の社員がいる可能性）、これは関数従属ではありません。関数従属の理解は、正規化の基礎となる重要な概念です。"
    },
    {
      "id": "tech-3-3-2-q4",
      "type": "multiple_choice",
      "question": "第1正規形（1NF）の説明として、最も適切でないものはどれか。",
      "options": [
        "反復グループがない（受講科目1, 2, 3のような列の繰り返しが存在しない）",
        "各セルが分割不可能な値（原子値）であり、1つのセルに複数の値を格納しない",
        "主キーが定義されている（各行を一意に識別できる列または列の組み合わせが存在する）",
        "部分関数従属と推移的関数従属を持たない"
      ],
      "correctAnswer": 3,
      "explanation": "「部分関数従属と推移的関数従属を持たない」は第1正規形の条件ではありません。これは第2正規形（部分関数従属を持たない）と第3正規形（推移的関数従属を持たない）の条件です。第1正規形（1NF）の正しい定義は、①反復グループがない（列の繰り返しが存在しない）、②各セルが分割不可能な値（原子値、Atomic Value）であり、1つのセルに複数の値を格納しない（例：受講科目列に「数学, 英語, プログラミング」のようなカンマ区切りを入れない）、③主キーが定義されている（各行を一意に識別できる列または列の組み合わせが存在する）、の3つです。第1正規形は正規化の第一段階で、反復グループを排除し、主キーを定義することで、データ構造を整理します。"
    },
    {
      "id": "tech-3-3-2-q5",
      "type": "multiple_choice",
      "question": "以下の受講表で、部分関数従属が発生している列はどれか。\n\n主キー：（学生ID, 受講科目）\n学生ID | 学生名 | 学科 | 受講科目\n101 | 佐藤 | 情報 | 数学",
      "options": [
        "学生IDと受講科目（主キーのため部分関数従属ではない）",
        "学生名と学科（学生IDだけで決まるため部分関数従属）",
        "受講科目（主キーの一部のため部分関数従属ではない）",
        "部分関数従属は発生していない"
      ],
      "correctAnswer": 1,
      "explanation": "「学生名と学科」が部分関数従属です。この表の主キーは（学生ID, 受講科目）の複合キーですが、①学生名は学生IDだけで決まります（学生ID → 学生名）、②学科も学生IDだけで決まります（学生ID → 学科）。主キーの一部（学生ID）だけで決まる列が存在するため、これが部分関数従属です。部分関数従属があると、学生名と学科が重複し（佐藤と情報が複数行に出現）、更新異常が発生します。この問題を解決するには、第2正規形に変換し、学生表（学生ID, 学生名, 学科）と受講表（学生ID, 受講科目）に分割する必要があります。分割後は、学生名と学科は学生表に1回のみ格納され、重複が解消されます。選択肢1の「学生IDと受講科目」は主キー自体のため部分関数従属ではなく、選択肢3の「受講科目」は主キーの一部ですが他の列を決定しないため部分関数従属ではありません。"
    },
    {
      "id": "tech-3-3-2-q6",
      "type": "multiple_choice",
      "question": "第2正規形（2NF）への変換方法として、最も適切なものはどれか。",
      "options": [
        "反復グループを排除し、1つのセルに1つの値のみを格納する",
        "主キーの一部に従属する列を別表に分離し、元の表には主キー全体に従属する列のみ残す",
        "非キー列に従属する列を別表に分離し、元の表には主キーに直接従属する列のみ残す",
        "E-R図を描き、実体と関連を整理する"
      ],
      "correctAnswer": 1,
      "explanation": "第2正規形（2NF）への変換方法は、「主キーの一部に従属する列を別表に分離し、元の表には主キー全体に従属する列のみ残す」です。例えば、受講表（学生ID, 学生名, 学科, 受講科目）で主キーが（学生ID, 受講科目）の場合、学生名と学科は学生IDだけで決まる（部分関数従属）ため、これらを別表（学生表）に分離します。分離後は、①学生表（学生ID, 学生名, 学科）：学生ID → （学生名, 学科）、②受講表（学生ID, 受講科目）：（学生ID, 受講科目）のみ、となり、部分関数従属が解消されます。選択肢1は第1正規形への変換方法、選択肢3は第3正規形への変換方法、選択肢4はE-R図の作成方法です。第2正規形への変換により、学生名と学科の重複が解消され、更新異常、挿入異常、削除異常が防止されます。"
    },
    {
      "id": "tech-3-3-2-q7",
      "type": "multiple_choice",
      "question": "推移的関数従属の説明として、最も適切なものはどれか。",
      "options": [
        "主キーの一部だけで他の列が決まる関係",
        "A → B かつ B → C のとき、A → C が成り立つ関係で、非キー列が他の非キー列を決定する",
        "1つのセルに複数の値を格納する関係",
        "主キーが複合キーである関係"
      ],
      "correctAnswer": 1,
      "explanation": "推移的関数従属は、「A → B かつ B → C のとき、A → C が成り立つ関係で、非キー列が他の非キー列を決定する」です。例えば、社員表（社員ID, 氏名, 部署ID, 部署名）で、①社員ID → 部署ID（完全関数従属）、②部署ID → 部署名（非キー列 → 非キー列：推移的関数従属）、のとき、社員ID → 部署名 が推移的に成り立ちます。これにより、部署名が重複し（営業部が複数行に出現）、更新異常が発生します（営業部の名称変更時、複数行を更新する必要がある）。この問題を解決するには、第3正規形に変換し、社員表（社員ID, 氏名, 部署ID）と部署表（部署ID, 部署名）に分割する必要があります。選択肢1は部分関数従属の説明、選択肢3は第1正規形の違反、選択肢4は複合キーの説明です。推移的関数従属を排除することで、第3正規形が達成されます。"
    },
    {
      "id": "tech-3-3-2-q8",
      "type": "multiple_choice",
      "question": "第3正規形（3NF）の説明として、最も適切なものはどれか。",
      "options": [
        "反復グループがなく、原子値のみを持ち、主キーが定義されている",
        "第1正規形であり、かつ部分関数従属を持たない",
        "第2正規形であり、かつ推移的関数従属を持たない（主キー以外の列が他の非キー列を決定しない）",
        "E-R図から関係モデル（表）に変換された形"
      ],
      "correctAnswer": 2,
      "explanation": "第3正規形（3NF）は、「第2正規形であり、かつ推移的関数従属を持たない（主キー以外の列が他の非キー列を決定しない）」です。つまり、非キー列が他の非キー列を決定する関係が存在しない形です。例えば、社員表（社員ID, 氏名, 部署ID, 部署名）で、部署ID → 部署名（非キー列 → 非キー列）という推移的関数従属が存在する場合、これを社員表（社員ID, 氏名, 部署ID）と部署表（部署ID, 部署名）に分割することで、第3正規形になります。第3正規形に変換することで、部署名の重複が解消され、更新異常が防止されます。選択肢1は第1正規形、選択肢2は第2正規形、選択肢4はE-R図の説明です。基本情報技術者試験では、第3正規形までの理解が重要です（第4正規形、第5正規形は試験範囲外）。"
    },
    {
      "id": "tech-3-3-2-q9",
      "type": "multiple_choice",
      "question": "E-R図のカーディナリティ（多重度）で、学生と科目の関係が「1人の学生は複数の科目を受講でき、1つの科目は複数の学生が受講する」場合、カーディナリティと表への変換方法として最も適切なものはどれか。",
      "options": [
        "1対1（1:1）で、どちらか一方の表に外部キーを追加する",
        "1対多（1:M）で、多側（学生表）に外部キー（科目ID）を追加する",
        "多対多（M:N）で、中間表（受講表）を作成し、学生IDと科目IDの両方への外部キーを持つ",
        "多対多（M:N）で、学生表と科目表を統合して1つの表にする"
      ],
      "correctAnswer": 2,
      "explanation": "カーディナリティは「多対多（M:N）」で、表への変換方法は「中間表（受講表）を作成し、学生IDと科目IDの両方への外部キーを持つ」です。1人の学生は複数の科目を受講でき（1:M）、かつ1つの科目は複数の学生が受講する（M:1）ため、これは多対多（M:N）の関係です。多対多の関係は、直接表現できないため、中間表（連関エンティティ）を作成します。具体的には、①学生表（学生ID, 学生名, 学科）、②科目表（科目ID, 科目名, 単位数）、③受講表（学生ID, 科目ID, 成績）を作成し、受講表の主キーは（学生ID, 科目ID）の複合キーとなります。受講表は、学生表への外部キー（学生ID）と科目表への外部キー（科目ID）を持ちます。選択肢1の1対1、選択肢2の1対多は、この関係には該当しません。選択肢4の「統合して1つの表」は誤りで、多対多の関係では中間表が必要です。"
    },
    {
      "id": "tech-3-3-2-q10",
      "type": "multiple_choice",
      "question": "データベース設計の流れとして、最も適切なものはどれか。",
      "options": [
        "①実装（DDL） → ②E-R図作成 → ③正規化 → ④要件定義 → ⑤物理設計",
        "①要件定義 → ②概念設計（E-R図） → ③論理設計（正規化） → ④物理設計 → ⑤実装（DDL）",
        "①正規化 → ②E-R図作成 → ③実装（DDL） → ④要件定義 → ⑤物理設計",
        "①E-R図作成 → ②実装（DDL） → ③要件定義 → ④正規化 → ⑤物理設計"
      ],
      "correctAnswer": 1,
      "explanation": "データベース設計の正しい流れは、「①要件定義 → ②概念設計（E-R図） → ③論理設計（正規化） → ④物理設計 → ⑤実装（DDL）」です。具体的には、①要件定義：どんなデータを管理するか決める（例：大学の受講管理システムで、学生、科目、受講の情報を管理）、②概念設計：E-R図を描き、実体（学生、科目）と関連（受講する）を整理、③論理設計：E-R図を関係モデル（表）に変換し、正規化（1NF → 2NF → 3NF）を実施して、学生表、科目表、受講表を作成、④物理設計：インデックス、ストレージ、パフォーマンスを考慮した設計（例：学生IDにインデックスを作成）、⑤実装：DDL（CREATE TABLE）でデータベースを構築、という流れです。この順序を守ることで、要件を満たし、品質の高いデータベースを設計できます。その他の選択肢は順序が誤っており、正しい設計手順ではありません。"
    }
  ]
}
