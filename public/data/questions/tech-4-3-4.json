{
  "topicId": "tech-4-3-4",
  "title": "整列アルゴリズム",
  "questions": [
    {
      "id": "tech-4-3-4-q1",
      "type": "multiple_choice",
      "question": "配列[5, 2, 8, 1, 9]をバブルソートで昇順に整列する場合、1回目のパス（最初の走査）が終了した時点での配列の状態として正しいものはどれですか?",
      "options": [
        "[2, 5, 1, 8, 9]",
        "[2, 5, 8, 1, 9]",
        "[1, 2, 5, 8, 9]",
        "[2, 1, 5, 8, 9]"
      ],
      "correctAnswer": 0,
      "explanation": "「[2, 5, 1, 8, 9]」が正しいです。バブルソート（基本交換法）は、隣接する2つの要素を比較し、順序が逆ならば交換する処理を繰り返します。1回目のパスでは、最大値が配列の末尾に「浮上」します。\n\n【1回目のパスの詳細】\n①[5, 2, 8, 1, 9] → 5と2を比較 → 5 > 2なので交換 → [2, 5, 8, 1, 9]\n②[2, 5, 8, 1, 9] → 5と8を比較 → 5 < 8なので交換なし → [2, 5, 8, 1, 9]\n③[2, 5, 8, 1, 9] → 8と1を比較 → 8 > 1なので交換 → [2, 5, 1, 8, 9]\n④[2, 5, 1, 8, 9] → 8と9を比較 → 8 < 9なので交換なし → [2, 5, 1, 8, 9]\n\n1回目のパス終了時点で、最大値9が末尾に確定し、配列は[2, 5, 1, 8, 9]になります。選択肢②は2回目のパス終了後、③は整列完了後、④は存在しない配列です。バブルソートは、n個の要素の場合、最大n-1回のパスで整列が完了します。"
    },
    {
      "id": "tech-4-3-4-q2",
      "type": "multiple_choice",
      "question": "選択ソート（基本選択法）とバブルソートを比較した場合、選択ソートの利点として正しいものはどれですか?",
      "options": [
        "計算量がO(n log n)と高速である",
        "安定ソート（同じ値の順序が保たれる）である",
        "交換回数がバブルソートより少ない",
        "既に整列済みのデータに対して最速である"
      ],
      "correctAnswer": 2,
      "explanation": "「交換回数がバブルソートより少ない」が正しいです。選択ソート（基本選択法）は、未整列部分から最小値を選択し、整列済み部分の末尾に移動する処理を繰り返すアルゴリズムです。選択ソートの特徴は、交換回数が最大でn-1回（要素数n）と少ないことです。一方、バブルソートは最悪ケースで n(n-1)/2 回の交換が発生します。\n\n【具体例: [5, 2, 8, 1, 9]を整列】\n選択ソート: 交換回数2回（5と1を交換、8と2を交換）\nバブルソート: 交換回数4回（5と2、8と1、5と1、2と1を交換）\n\n選択肢①は誤りです。選択ソートの計算量はO(n²)です。②は誤りです。選択ソートは不安定ソート（同じ値の順序が保たれない場合がある）です。④は誤りです。既に整列済みのデータに対して最速なのは挿入ソート（O(n)）です。選択ソートは既に整列済みでもO(n²)の計算量です。選択ソートは、メモリ書き込みコストが高い環境（例: フラッシュメモリ）で、交換回数を最小化したい場合に有利です。"
    },
    {
      "id": "tech-4-3-4-q3",
      "type": "multiple_choice",
      "question": "挿入ソート（基本挿入法）が最も効率的に動作するデータの特徴として正しいものはどれですか?",
      "options": [
        "完全にランダムなデータ",
        "逆順に整列されたデータ",
        "ほぼ整列済みのデータ",
        "全ての要素が同じ値のデータ"
      ],
      "correctAnswer": 2,
      "explanation": "「ほぼ整列済みのデータ」が正しいです。挿入ソート（基本挿入法）は、未整列部分の先頭要素を、整列済み部分の適切な位置に挿入する処理を繰り返すアルゴリズムです。挿入ソートの最良ケースは、データが既に整列済み（またはほぼ整列済み）の場合で、計算量がO(n)になります。\n\n【最良ケース: [1, 2, 3, 4, 5]】\n各要素を挿入する際、比較が1回だけで済む\n→ 合計n-1回の比較 → O(n)\n\n【最悪ケース: [5, 4, 3, 2, 1]（逆順）】\n各要素を挿入する際、整列済み部分の全要素をシフト\n→ 合計 1 + 2 + 3 + ... + (n-1) = n(n-1)/2回のシフト → O(n²)\n\n選択肢①④は平均ケース（O(n²)）、②は最悪ケース（O(n²)）です。挿入ソートは、ほぼ整列済みのデータに対して、クイックソートやマージソートよりも高速に動作する場合があります。実際、Pythonの標準ライブラリ（Timsort）やC++の標準ライブラリ（イントロソート）は、小規模データやほぼ整列済みのデータに対して挿入ソートを使用します。"
    },
    {
      "id": "tech-4-3-4-q4",
      "type": "multiple_choice",
      "question": "クイックソートにおいて、ピボットとして配列の先頭要素を常に選択する場合、最悪ケースの計算量O(n²)になるデータの特徴として正しいものはどれですか?",
      "options": [
        "完全にランダムなデータ",
        "既に昇順または降順に整列されたデータ",
        "全ての要素が同じ値のデータ",
        "配列の中央値がピボットとして選ばれるデータ"
      ],
      "correctAnswer": 1,
      "explanation": "「既に昇順または降順に整列されたデータ」が正しいです。クイックソートは、配列から基準値（ピボット）を選び、ピボットより小さい要素を左、大きい要素を右に分割し、再帰的に整列する分割統治法のアルゴリズムです。ピボットとして先頭要素を常に選択する場合、既に整列済みのデータでは分割が極端に偏り、最悪ケースO(n²)になります。\n\n【最悪ケースの具体例: [1, 2, 3, 4, 5]】\n①ピボット1で分割 → 左[]、右[2, 3, 4, 5]（片側のみ分割）\n②ピボット2で分割 → 左[]、右[3, 4, 5]\n③ピボット3で分割 → 左[]、右[4, 5]\n④ピボット4で分割 → 左[]、右[5]\n→ 分割の深さがnになり、各層でn回の比較 → O(n²)\n\n選択肢①は平均ケース（O(n log n)）です。③も最悪ケースになる場合がありますが、実装によります（全て同じ値の場合、ピボットと等しい要素の扱いが重要）。④は最良ケース（O(n log n)）です。最悪ケースを回避するために、①ピボット選択を工夫（中央値、ランダム）、②最悪ケースでヒープソートに切り替える（イントロソート）、などの対策が取られます。"
    },
    {
      "id": "tech-4-3-4-q5",
      "type": "multiple_choice",
      "question": "マージソートの特徴として誤っているものはどれですか?",
      "options": [
        "最良・平均・最悪の全てのケースで計算量がO(n log n)である",
        "安定ソート（同じ値の順序が保たれる）である",
        "追加メモリがO(1)で空間効率が良い",
        "分割統治法（Divide and Conquer）を使用している"
      ],
      "correctAnswer": 2,
      "explanation": "「追加メモリがO(1)で空間効率が良い」が誤りです。マージソートは、配列を2つに分割し、それぞれを再帰的に整列した後、2つの整列済み配列を併合（マージ）する分割統治法のアルゴリズムです。マージソートの空間計算量はO(n)で、整列用の追加配列（作業用配列）が必要です。\n\n【マージソートの空間計算量】\nマージ処理で、2つの整列済み配列を併合する際、n個の要素を格納する追加配列が必要\n→ 空間計算量: O(n)\n\n選択肢①は正しいです。マージソートは、最良・平均・最悪の全てのケースで計算量がO(n log n)を保証します。②は正しいです。マージソートは安定ソート（同じ値の順序が保たれる）です。④は正しいです。マージソートは分割統治法を使用しています。\n\nマージソートの利点は、①常にO(n log n)の計算量（最悪ケースでも高速）、②安定ソート、③並列化が容易、などです。欠点は、①追加メモリO(n)が必要、②小規模データではオーバーヘッドが大きい、などです。Pythonの標準ソート（Timsort）は、マージソートと挿入ソートを組み合わせたハイブリッドアルゴリズムです。"
    },
    {
      "id": "tech-4-3-4-q6",
      "type": "multiple_choice",
      "question": "次の整列アルゴリズムのうち、安定ソート（同じ値を持つ要素の元の順序が保たれる）であるものはどれですか?",
      "options": [
        "選択ソート",
        "クイックソート",
        "ヒープソート",
        "マージソート"
      ],
      "correctAnswer": 3,
      "explanation": "「マージソート」が正しいです。安定ソートとは、同じ値を持つ要素の元の順序が保たれるソートアルゴリズムです。マージソートは、2つの整列済み配列をマージする際、同じ値の要素は左側の配列を優先することで、元の順序を保つことができます。\n\n【安定性の具体例】\n学生データ: [(1年, 80点, 太郎), (2年, 90点, 花子), (1年, 80点, 次郎)]\n\n①学年でソート（安定） → [(1年, 80点, 太郎), (1年, 80点, 次郎), (2年, 90点, 花子)]\n②成績でソート（安定） → [(1年, 80点, 太郎), (1年, 80点, 次郎), (2年, 90点, 花子)]\n→ 太郎と次郎の順序が保たれる（同じ80点でも元の順序を維持）\n\n【各アルゴリズムの安定性】\n安定ソート: バブルソート、挿入ソート、マージソート\n不安定ソート: 選択ソート、クイックソート、ヒープソート\n\n選択肢①選択ソートは不安定です（最小値を選択して交換する際、同じ値の順序が入れ替わる場合がある）。②クイックソートは不安定です（分割処理で同じ値の順序が入れ替わる場合がある）。③ヒープソートは不安定です（ヒープの再構築で同じ値の順序が入れ替わる場合がある）。安定ソートは、複数キーによる整列（まず名前でソート、次に年齢でソート）やデータベースのソートで重要です。"
    },
    {
      "id": "tech-4-3-4-q7",
      "type": "multiple_choice",
      "question": "ヒープソートの特徴として正しいものはどれですか?",
      "options": [
        "最悪ケースの計算量がO(n²)である",
        "追加メモリがO(n)必要である",
        "安定ソート（同じ値の順序が保たれる）である",
        "追加メモリがO(1)で、最悪ケースでもO(n log n)を保証する"
      ],
      "correctAnswer": 3,
      "explanation": "「追加メモリがO(1)で、最悪ケースでもO(n log n)を保証する」が正しいです。ヒープソートは、ヒープ（完全2分木の一種）を使用した整列アルゴリズムです。まず配列をヒープ構造に変換（ヒープ化）し、ヒープの根（最大値または最小値）を取り出して配列の末尾に配置する処理を繰り返します。\n\n【ヒープソートの特徴】\n①計算量: 常にO(n log n)（最良・平均・最悪の全てのケース）\n  - ヒープ化: O(n)\n  - 各要素を取り出す: O(log n) × n = O(n log n)\n  - 合計: O(n log n)\n\n②空間計算量: O(1)（インプレースソート、追加メモリ不要）\n  - 配列をヒープ構造として扱うため、追加配列が不要\n\n③安定性: 不安定（同じ値の順序が保たれない場合がある）\n\n選択肢①は誤りです。ヒープソートの最悪ケースの計算量はO(n log n)です。②は誤りです。ヒープソートは追加メモリO(1)（インプレースソート）です。③は誤りです。ヒープソートは不安定ソートです。ヒープソートは、メモリ制約が厳しい環境（組み込みシステムなど）や、最悪ケースでもO(n log n)を保証したい場合（リアルタイムシステムなど）に適しています。C++ std::sortの実装（イントロソート）では、クイックソートの再帰が深くなった場合、ヒープソートに切り替えることで最悪ケースO(n²)を回避しています。"
    },
    {
      "id": "tech-4-3-4-q8",
      "type": "multiple_choice",
      "question": "次の整列アルゴリズムのうち、平均計算量がO(n log n)で、追加メモリがO(1)（インプレースソート）であるものはどれですか?",
      "options": [
        "マージソート",
        "クイックソート",
        "挿入ソート",
        "バブルソート"
      ],
      "correctAnswer": 1,
      "explanation": "「クイックソート」が正しいです。クイックソートは、配列から基準値（ピボット）を選び、ピボットより小さい要素を左、大きい要素を右に分割し、再帰的に整列する分割統治法のアルゴリズムです。平均計算量がO(n log n)で、追加メモリがO(log n)（再帰スタックのみ）と、空間効率が良好です。\n\n【クイックソートの特徴】\n①平均計算量: O(n log n)\n  - 分割の深さ: log n（平均的に左右が同じサイズに分割）\n  - 各層での比較回数: n\n  - 合計: O(n log n)\n\n②空間計算量: O(log n)（再帰スタックのみ）\n  - 追加配列は不要（インプレースソート）\n  - 再帰スタックの深さ: 平均log n\n\n③最悪ケース: O(n²)（既に整列済み、または逆順の場合）\n\n選択肢①マージソートは、平均計算量O(n log n)ですが、追加メモリO(n)が必要です。③挿入ソートと④バブルソートは、平均計算量O(n²)です。クイックソートは、実用的に最も使われるソートアルゴリズムの1つで、C言語のqsort()、Javaの配列ソート（プリミティブ型）、Rustの不安定ソートなどで採用されています。ただし、最悪ケースO(n²)を回避するために、ピボット選択を工夫したり、イントロソート（クイックソート + ヒープソート）を使用したりする実装もあります。"
    },
    {
      "id": "tech-4-3-4-q9",
      "type": "multiple_choice",
      "question": "次の状況のうち、マージソートを選択するのが最も適切なものはどれですか?",
      "options": [
        "メモリ容量が限られた組み込みシステムで、大規模データを整列したい",
        "複数キーによる整列（まず名前でソート、次に年齢でソート）を行いたい",
        "平均的に最速のソートアルゴリズムを使用したい",
        "既に整列済みのデータを高速に整列したい"
      ],
      "correctAnswer": 1,
      "explanation": "「複数キーによる整列（まず名前でソート、次に年齢でソート）を行いたい」が正しいです。マージソートは安定ソート（同じ値を持つ要素の元の順序が保たれる）なので、複数キーによる整列に適しています。\n\n【複数キーによる整列の具体例】\n学生データ: [(1年, 80点, 太郎), (2年, 90点, 花子), (1年, 80点, 次郎)]\n\n①まず学年でソート（安定ソート）\n→ [(1年, 80点, 太郎), (1年, 80点, 次郎), (2年, 90点, 花子)]\n\n②次に成績でソート（安定ソート）\n→ [(1年, 80点, 太郎), (1年, 80点, 次郎), (2年, 90点, 花子)]\n→ 太郎と次郎の順序が保たれる（同じ80点でも、学年でソートした順序を維持）\n\nもし不安定ソート（クイックソート、ヒープソートなど）を使うと、太郎と次郎の順序が入れ替わる可能性があります。\n\n選択肢①は、ヒープソート（追加メモリO(1)）が適しています。マージソートは追加メモリO(n)が必要なので、メモリ容量が限られた環境には不向きです。③は、クイックソート（平均的に最速）が適しています。④は、挿入ソート（既に整列済みならO(n)）が適しています。マージソートは、Pythonの標準ソート（Timsort）、Javaのコレクションソート（安定ソート）、大規模データの外部ソート（ディスク使用）などで採用されています。"
    },
    {
      "id": "tech-4-3-4-q10",
      "type": "multiple_choice",
      "question": "C++の標準ライブラリのstd::sort()で採用されているイントロソート（Introsort）の仕組みとして正しいものはどれですか?",
      "options": [
        "常にクイックソートを使用し、最悪ケースでもO(n log n)を保証する",
        "クイックソート、ヒープソート、挿入ソートを組み合わせたハイブリッドアルゴリズム",
        "マージソートと挿入ソートを組み合わせたハイブリッドアルゴリズム",
        "常にヒープソートを使用し、安定ソートを保証する"
      ],
      "correctAnswer": 1,
      "explanation": "「クイックソート、ヒープソート、挿入ソートを組み合わせたハイブリッドアルゴリズム」が正しいです。イントロソート（Introsort）は、クイックソートの利点（平均的に高速）と、ヒープソートの利点（最悪ケースO(n log n)を保証）、挿入ソートの利点（小規模データに高速）を組み合わせた実用的なアルゴリズムです。\n\n【イントロソートの仕組み】\n①まずクイックソートで整列を開始\n  - 平均的にO(n log n)で高速\n\n②再帰の深さが2×log nを超えたらヒープソートに切り替え\n  - クイックソートの最悪ケースO(n²)を回避\n  - ヒープソートで常にO(n log n)を保証\n\n③小規模データ（n < 16程度）は挿入ソートに切り替え\n  - オーバーヘッドが小さく、小規模データに高速\n\n【利点】\n①クイックソートの平均的な速さ（O(n log n)）\n②最悪ケースO(n²)を回避（ヒープソートで保証）\n③小規模データの最適化（挿入ソートでオーバーヘッド削減）\n\n選択肢①は誤りです。イントロソートはクイックソートだけでなく、ヒープソートと挿入ソートも組み合わせています。③は、Timsort（Pythonの標準ソート）の説明です。④は誤りです。イントロソートは不安定ソートです（C++のstd::stable_sort()が安定ソート）。イントロソートは、実用的なソートアルゴリズムの代表例で、C++ std::sort()、Rustの不安定ソートなどで採用されています。"
    }
  ]
}
