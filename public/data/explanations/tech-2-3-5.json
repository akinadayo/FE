{
  "topicId": "tech-2-3-5",
  "title": "仮想記憶管理",
  "pages": [
    {
      "id": 1,
      "title": "仮想記憶の概念とページング方式の基礎",
      "sections": [
        {
          "type": "text",
          "content": "**仮想記憶（Virtual Memory）**とは、物理メモリ（RAM）とハードディスク（またはSSD）を組み合わせて、実際のメモリ容量より大きな仮想的なメモリ空間をプログラムに提供する技術です。仮想記憶により、①物理メモリより大きなプログラムを実行できる、②複数のプログラムを効率的に同時実行できる、③プログラマはメモリ容量を気にせずプログラムを開発できる、などの利点があります。仮想記憶の主な方式には、①**ページング方式（Paging）**、②**セグメント方式（Segmentation）**、がありますが、現在のOSではページング方式が主流です。"
        },
        {
          "type": "example",
          "title": "仮想記憶が必要な理由",
          "content": "【背景】\nあなたのパソコンには8GBのRAMがあります。今、動画編集ソフト（10GB）を起動しようとしています。\n\n【実記憶管理（仮想記憶なし）の場合】\nプログラム全体（10GB）をRAM（8GB）に配置しようとすると、メモリ不足で起動できません。\nエラー: メモリ不足\n\n【仮想記憶ありの場合】\nOSは、動画編集ソフト（10GB）を小さな単位（ページ、例: 4KB）に分割します。\n①プログラムは10GB = 10,000MB = 10,240,000KB = 2,560,000ページ（1ページ = 4KB）に分割される\n②OSは、現在実行に必要なページだけ（例: 100,000ページ = 400MB）をRAMに配置する\n③残りのページ（2,460,000ページ = 9.6GB）はハードディスクに保存される\n④プログラムが別のページを必要とする場合、OSはハードディスクから必要なページをRAMに読み込み（ページイン）、使わないページをハードディスクに退避（ページアウト）する\n\nこうして、8GBのRAMで10GBのプログラムを実行できます！\n\n【ユーザーから見た仮想記憶】\nユーザー（プログラム）は、10GBの連続したメモリ空間（仮想メモリ空間）があるように見えます。実際には、一部はRAMに、一部はハードディスクに配置されていますが、OSが自動的に管理するため、ユーザーは意識する必要がありません。"
        },
        {
          "type": "text",
          "content": "**ページング方式（Paging）**とは、プログラムの仮想メモリ空間を固定サイズの小さな単位（ページ、Page）に分割し、物理メモリも同じサイズの単位（ページフレーム、Page Frame）に分割して管理する方式です。1ページのサイズは、一般的に4KB（4,096バイト）です（OSによっては8KB、16KBなど）。ページング方式では、プログラムの各ページを、物理メモリのページフレームまたはハードディスクに配置します。プログラムが実行される際、必要なページだけが物理メモリに配置され、使わないページはハードディスクに保存されます。"
        },
        {
          "type": "table",
          "headers": ["用語", "説明", "サイズ例"],
          "rows": [
            ["ページ（Page）", "仮想メモリ空間を分割した固定サイズの単位", "4KB"],
            ["ページフレーム（Page Frame）", "物理メモリを分割した固定サイズの単位（ページと同じサイズ）", "4KB"],
            ["仮想アドレス（Virtual Address）", "プログラムが使用するアドレス（仮想メモリ空間のアドレス）", "例: 0x00001000"],
            ["物理アドレス（Physical Address）", "実際のRAMのアドレス", "例: 0xA0001000"],
            ["ページテーブル（Page Table）", "仮想アドレスと物理アドレスの対応表", "-"]
          ]
        },
        {
          "type": "example",
          "title": "ページング方式の具体例",
          "content": "【前提】\nプログラムのサイズ: 16KB\n1ページのサイズ: 4KB\n物理メモリ（RAM）のサイズ: 8GB\n\n【プログラムの分割】\nプログラムは、16KB ÷ 4KB = 4ページに分割されます。\nページ0（0～4KB）\nページ1（4KB～8KB）\nページ2（8KB～12KB）\nページ3（12KB～16KB）\n\n【物理メモリの状態】\nRAMは、8GB ÷ 4KB = 2,097,152個のページフレームに分割されています。\n\n【ページの配置】\nOSは、プログラムの各ページを以下のように配置します。\nページ0 → ページフレーム1000（RAMに配置）\nページ1 → ページフレーム2500（RAMに配置）\nページ2 → ハードディスクに保存（今は使わない）\nページ3 → ハードディスクに保存（今は使わない）\n\n【ページテーブル】\nOSは、ページテーブル（Page Table）を使って、仮想アドレスと物理アドレスの対応を管理します。\n\nページ番号 | 物理アドレス（ページフレーム番号） | 有効ビット\n---------|----------------------------------|----------\n0        | 1000                              | 1（RAM内）\n1        | 2500                              | 1（RAM内）\n2        | -                                 | 0（HDD内）\n3        | -                                 | 0（HDD内）\n\n有効ビット（Valid Bit）: 1 = ページがRAM内にある、0 = ページがハードディスク内にある\n\n【プログラムの実行】\nプログラムが、仮想アドレス0x00001000（ページ0の先頭）にアクセスしようとすると、OSは以下の処理を実行します。\n①仮想アドレス0x00001000をページ番号（0）とページ内オフセット（0x000）に分割\n②ページテーブルを参照して、ページ0がページフレーム1000にあることを確認\n③物理アドレス = ページフレーム番号（1000）× ページサイズ（4KB）+ ページ内オフセット（0x000）= 0xFA0000 + 0x000 = 0xFA0000\n④物理アドレス0xFA0000にアクセス\n\nこのように、OSが自動的に仮想アドレスを物理アドレスに変換（アドレス変換）します。プログラムは仮想アドレスを使うだけで、物理アドレスを意識する必要がありません。"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "仮想記憶の透過性",
          "content": "仮想記憶の最大の利点は、**透過性（Transparency）**です。プログラムは、仮想メモリ空間（例: 10GB）が全て連続したRAMに配置されているかのように動作でき、実際にはRAMとハードディスクに分散して配置されていることを意識する必要がありません。OSが自動的にページの配置、アドレス変換、ページの読み込み・退避を管理します。これにより、プログラマはメモリ容量を気にせずプログラムを開発でき、ユーザーは大規模なプログラムを実行できます。"
        }
      ]
    },
    {
      "id": 2,
      "title": "ページフォルトとページの置き換え",
      "sections": [
        {
          "type": "text",
          "content": "**ページフォルト（Page Fault）**とは、プログラムがアクセスしようとしたページが物理メモリ（RAM）に存在しない場合に発生する例外です。ページフォルトが発生すると、OSは以下の処理を実行します。①必要なページをハードディスクから物理メモリに読み込む（ページイン、Page In）、②もし物理メモリが満杯の場合、現在RAMにあるページの中から1つを選び、ハードディスクに退避（ページアウト、Page Out）してスペースを空ける、③プログラムの実行を再開する。ページフォルトは、仮想記憶では正常な動作ですが、頻繁に発生するとシステムが遅くなります（スラッシング）。"
        },
        {
          "type": "example",
          "title": "ページフォルトの具体例",
          "content": "【前提】\n物理メモリ（RAM）のサイズ: 8GB（2,097,152個のページフレーム）\n現在、RAMは満杯で、全てのページフレームが使用中です。\n\n【プログラムの実行】\nプログラムが、仮想アドレス0x00003000（ページ2の先頭）にアクセスしようとします。\n\n【ページテーブルの確認】\nページ番号 | 物理アドレス（ページフレーム番号） | 有効ビット\n---------|----------------------------------|----------\n0        | 1000                              | 1（RAM内）\n1        | 2500                              | 1（RAM内）\n2        | -                                 | 0（HDD内） ← ページ2はハードディスク内\n3        | -                                 | 0（HDD内）\n\n【ページフォルトの発生】\nページ2の有効ビットが0（ハードディスク内）なので、ページフォルトが発生します。\n\n【OSの処理】\n①OSは、ハードディスクからページ2を読み込む必要があると判断\n②RAMが満杯なので、現在RAMにあるページの中から1つを選び、ハードディスクに退避（ページアウト）する\n  例: ページ0をページアウト（LRUアルゴリズム、後述）\n③ハードディスクからページ2をRAMに読み込む（ページイン）\n  ページ2 → ページフレーム1000（ページ0が使っていた領域を再利用）\n④ページテーブルを更新\n  ページ0: 有効ビット = 0（HDD内に移動）\n  ページ2: 有効ビット = 1、物理アドレス = 1000（RAM内に移動）\n⑤プログラムの実行を再開（仮想アドレス0x00003000にアクセス）\n\n【時間】\nページフォルトの処理には、ハードディスクへのアクセスが必要なため、数ミリ秒～数十ミリ秒かかります（RAMアクセスは数ナノ秒なので、1000倍～10000倍遅い）。ページフォルトが頻繁に発生すると、システムが遅くなります。"
        },
        {
          "type": "text",
          "content": "ページフォルトが発生し、物理メモリが満杯の場合、OSは「どのページをハードディスクに退避（ページアウト）するか」を決定する必要があります。この決定に使用されるアルゴリズムが、**ページ置き換えアルゴリズム（Page Replacement Algorithm）**です。ページ置き換えアルゴリズムの目的は、ページフォルトの発生回数を最小化し、システムのパフォーマンスを向上させることです。代表的なアルゴリズムには、①**FIFO（First In First Out）**、②**LRU（Least Recently Used）**、③**LFU（Least Frequently Used）**、があります。"
        },
        {
          "type": "table",
          "headers": ["アルゴリズム", "置き換え方針", "利点", "欠点"],
          "rows": [
            ["FIFO", "最も古くRAMに読み込まれたページを置き換える", "実装が簡単", "よく使われるページも置き換えられる可能性"],
            ["LRU", "最も長い間使われていないページを置き換える", "効率的（よく使われるページは残る）", "実装が複雑、管理のオーバーヘッド"],
            ["LFU", "最も使用頻度が低いページを置き換える", "使用頻度を考慮できる", "過去の使用頻度が高くても、今は使わないページが残る"]
          ]
        },
        {
          "type": "example",
          "title": "ページ置き換えアルゴリズムの比較（具体例）",
          "content": "【前提】\n物理メモリに3つのページフレームがあります（簡単のため、3つのページだけ考えます）。\nプログラムが、以下の順番でページにアクセスします。\nアクセス順: ページ1 → ページ2 → ページ3 → ページ1 → ページ4 → ページ5\n\n【①FIFO（First In First Out）】\n最も古くRAMに読み込まれたページを置き換えます。\n\nアクセス | RAM内のページ | ページフォルト？ | 置き換えられたページ\n-------|--------------|----------------|------------------\nページ1 | [1, -, -]     | はい（初回）    | -\nページ2 | [1, 2, -]     | はい（初回）    | -\nページ3 | [1, 2, 3]     | はい（初回）    | -\nページ1 | [1, 2, 3]     | いいえ（既にRAM内） | -\nページ4 | [4, 2, 3]     | はい            | ページ1（最も古い）\nページ5 | [4, 5, 3]     | はい            | ページ2（最も古い）\n\nページフォルト回数: 5回\n\n【②LRU（Least Recently Used）】\n最も長い間使われていないページを置き換えます。\n\nアクセス | RAM内のページ | ページフォルト？ | 置き換えられたページ\n-------|--------------|----------------|------------------\nページ1 | [1, -, -]     | はい（初回）    | -\nページ2 | [1, 2, -]     | はい（初回）    | -\nページ3 | [1, 2, 3]     | はい（初回）    | -\nページ1 | [1, 2, 3]     | いいえ（既にRAM内、最近使用した） | -\nページ4 | [1, 4, 3]     | はい            | ページ2（最も長い間使われていない）\nページ5 | [1, 4, 5]     | はい            | ページ3（最も長い間使われていない）\n\nページフォルト回数: 5回\n\n【③LFU（Least Frequently Used）】\n最も使用頻度が低いページを置き換えます。\n\nアクセス | RAM内のページ | ページフォルト？ | 置き換えられたページ\n-------|--------------|----------------|------------------\nページ1 | [1(1回), -, -] | はい（初回）    | -\nページ2 | [1(1回), 2(1回), -] | はい（初回） | -\nページ3 | [1(1回), 2(1回), 3(1回)] | はい（初回） | -\nページ1 | [1(2回), 2(1回), 3(1回)] | いいえ（既にRAM内） | -\nページ4 | [1(2回), 4(1回), 3(1回)] | はい | ページ2（使用頻度1回）\nページ5 | [1(2回), 5(1回), 3(1回)] | はい | ページ4（使用頻度1回）\n\nページフォルト回数: 5回\n\n【結論】\nこの例では、3つのアルゴリズムでページフォルト回数は同じでしたが、アクセスパターンによっては、LRUが最も効率的な場合が多いです。現在のOSでは、LRUまたはLRUに近いアルゴリズムが広く使われています。"
        },
        {
          "type": "highlight",
          "icon": "🔧",
          "title": "LRUアルゴリズムの実装",
          "content": "LRU（Least Recently Used）は、理論的には最も効率的なアルゴリズムですが、実装が複雑です。各ページの最終アクセス時刻を記録し、ページフォルト発生時に全てのページを調べて、最も古い時刻のページを選ぶ必要があります。実際のOSでは、LRUを近似したアルゴリズム（Clock アルゴリズム、Second Chance アルゴリズム）が使われることが多いです。これらのアルゴリズムは、各ページに「参照ビット」を付け、最近使われたページを判別します。LRUの近似アルゴリズムは、LRUより実装が簡単で、パフォーマンスもLRUに近いです。"
        }
      ]
    },
    {
      "id": 3,
      "title": "ページテーブルとアドレス変換",
      "sections": [
        {
          "type": "text",
          "content": "**ページテーブル（Page Table）**とは、仮想アドレスと物理アドレスの対応を記録した表です。ページング方式では、プログラムは仮想アドレスを使ってメモリにアクセスしますが、実際のRAMアクセスには物理アドレスが必要です。OSは、ページテーブルを使って、仮想アドレスを物理アドレスに変換（アドレス変換、Address Translation）します。各プログラムは、独自のページテーブルを持ち、OSがプログラムを切り替える際に、ページテーブルも切り替えます。これにより、各プログラムは独立した仮想メモリ空間を持つことができます。"
        },
        {
          "type": "example",
          "title": "アドレス変換の具体例（32ビットシステム）",
          "content": "【前提】\n32ビットシステム（仮想アドレス空間: 4GB = 2^32バイト）\n1ページのサイズ: 4KB = 4,096バイト = 2^12バイト\nページ数: 4GB ÷ 4KB = 1,048,576ページ = 2^20ページ\n\n【仮想アドレスの構造】\n32ビットの仮想アドレスは、以下のように分割されます。\n\n|--- 上位20ビット ---||--- 下位12ビット ---||\n   ページ番号              ページ内オフセット\n\n例: 仮想アドレス 0x00123456（16進数）\n  → 2進数: 0000 0000 0001 0010 0011 0100 0101 0110\n  → ページ番号: 上位20ビット = 0000 0000 0001 0010 0011（0x123 = 291）\n  → ページ内オフセット: 下位12ビット = 0100 0101 0110（0x456 = 1110バイト）\n\n【ページテーブルの参照】\nOSは、ページテーブルを使って、ページ番号291に対応するページフレーム番号を調べます。\n\nページ番号 | ページフレーム番号 | 有効ビット\n---------|-------------------|----------\n...\n291      | 5000              | 1（RAM内）\n...\n\nページ番号291は、ページフレーム5000に配置されています。\n\n【物理アドレスの計算】\n物理アドレス = ページフレーム番号（5000）× ページサイズ（4KB）+ ページ内オフセット（0x456）\n            = 5000 × 4096 + 1110\n            = 20,480,000 + 1110\n            = 20,481,110バイト\n            = 0x01388456（16進数）\n\n【RAMアクセス】\nCPUは、物理アドレス0x01388456にアクセスして、データを読み書きします。\n\n【高速化: TLB（Translation Lookaside Buffer）】\nページテーブルへのアクセスは、メモリアクセスが必要なため、遅い（数十ナノ秒）です。そのため、CPUには、最近使われたページテーブルのエントリをキャッシュする**TLB（Translation Lookaside Buffer）**というハードウェアがあります。TLBにエントリがあれば（TLBヒット）、ページテーブルへのアクセスなしで、直接物理アドレスを取得できます（数ナノ秒）。TLBにエントリがない場合（TLBミス）、ページテーブルにアクセスします。TLBのヒット率は一般的に90%以上で、アドレス変換を大幅に高速化します。"
        },
        {
          "type": "table",
          "headers": ["処理", "アクセス先", "所要時間", "備考"],
          "rows": [
            ["TLBヒット（キャッシュにある）", "TLB（CPUのキャッシュ）", "数ナノ秒", "90%以上の確率"],
            ["TLBミス（キャッシュにない）", "ページテーブル（RAM）", "数十ナノ秒", "10%未満の確率"],
            ["ページフォルト（ページがHDDにある）", "ハードディスク", "数ミリ秒", "まれ（頻発するとスラッシング）"]
          ]
        },
        {
          "type": "text",
          "content": "ページテーブルのサイズは、仮想アドレス空間のサイズとページサイズによって決まります。32ビットシステム（4GB）、1ページ4KBの場合、ページ数は1,048,576ページです。各ページテーブルエントリは、ページフレーム番号（20ビット）、有効ビット、アクセス権限などを含むため、4バイト程度必要です。したがって、ページテーブルのサイズは、1,048,576ページ × 4バイト = 4MBです。64ビットシステム（理論上16EB = 2^64バイト）では、ページテーブルが非常に大きくなるため、**多段ページテーブル（Multi-Level Page Table）**が使われます。多段ページテーブルでは、ページテーブルを階層化し、必要な部分だけをRAMに配置することで、メモリ使用量を削減します。"
        },
        {
          "type": "highlight",
          "icon": "📌",
          "title": "仮想記憶のメリット",
          "content": "ページテーブルとアドレス変換により、仮想記憶は以下のメリットを提供します。①**メモリの抽象化**: プログラムは、物理メモリの配置を気にせず、連続した仮想メモリ空間を使える。②**メモリ保護**: 各プログラムは独立した仮想メモリ空間を持ち、他のプログラムのメモリにアクセスできない（セキュリティ）。③**メモリの共有**: 複数のプログラムが同じ物理メモリ（例: ライブラリ）を共有できる（効率化）。④**大規模プログラムの実行**: 物理メモリより大きなプログラムを実行できる。これらのメリットにより、仮想記憶は現代のOSで不可欠な技術になっています。"
        }
      ]
    },
    {
      "id": 4,
      "title": "ページング方式の性能とスラッシング",
      "sections": [
        {
          "type": "text",
          "content": "ページング方式の性能は、**ページフォルト率（Page Fault Rate）**に大きく依存します。ページフォルト率とは、メモリアクセスのうち、ページフォルトが発生する割合です。ページフォルト率が低い（例: 1%未満）場合、ほとんどのメモリアクセスはRAM内で完結し、システムは高速に動作します。ページフォルト率が高い（例: 10%以上）場合、頻繁にハードディスクへのアクセスが発生し、システムは非常に遅くなります。ページフォルト率を低く保つためには、①十分な物理メモリを確保する、②効率的なページ置き換えアルゴリズム（LRU）を使用する、③プログラムの局所性（Locality）を活用する、などの工夫が必要です。"
        },
        {
          "type": "example",
          "title": "ページフォルト率の計算例",
          "content": "【前提】\nプログラムが、1秒間に1,000,000回のメモリアクセスを実行します。\nそのうち、ページフォルトが100回発生しました。\n\n【ページフォルト率の計算】\nページフォルト率 = ページフォルト回数 ÷ メモリアクセス回数 × 100%\n               = 100 ÷ 1,000,000 × 100%\n               = 0.01%\n\n【実効アクセス時間の計算】\nRAMアクセス時間: 100ナノ秒\nページフォルト処理時間: 10ミリ秒 = 10,000,000ナノ秒（ハードディスクへのアクセスを含む）\n\n実効アクセス時間 = (1 - ページフォルト率) × RAMアクセス時間 + ページフォルト率 × ページフォルト処理時間\n                = (1 - 0.0001) × 100ナノ秒 + 0.0001 × 10,000,000ナノ秒\n                = 0.9999 × 100ナノ秒 + 0.0001 × 10,000,000ナノ秒\n                = 99.99ナノ秒 + 1,000ナノ秒\n                = 1,099.99ナノ秒\n                ≒ 1,100ナノ秒\n\n【考察】\nページフォルト率が0.01%（非常に低い）でも、実効アクセス時間は100ナノ秒から1,100ナノ秒に増加しました（11倍遅い）。これは、ページフォルト処理時間が非常に長い（RAMアクセスの10万倍）ためです。ページフォルト率が1%になると、実効アクセス時間は約100,000ナノ秒（100マイクロ秒）になり、システムは非常に遅くなります。ページフォルト率を低く保つことが、仮想記憶の性能向上の鍵です。"
        },
        {
          "type": "text",
          "content": "**スラッシング（Thrashing）**とは、ページフォルトが頻繁に発生し、システムがほとんどページの読み込み・退避（ページイン・ページアウト）の処理に時間を使い、プログラムの実行が進まなくなる現象です。スラッシングは、物理メモリに対して実行するプログラムが多すぎる場合に発生します。スラッシングが発生すると、①CPUの使用率が低下（CPUはページフォルト処理を待つ）、②ハードディスクのアクセスが増加（ページの読み込み・退避）、③システムの応答時間が著しく長くなる、などの症状が現れます。"
        },
        {
          "type": "example",
          "title": "スラッシングの具体例",
          "content": "【背景】\nコンピュータの物理メモリは4GBです。現在、10個のプログラム（各500MB）を同時に実行しようとしています。\n合計: 10 × 500MB = 5,000MB = 5GB > 4GB（物理メモリ不足）\n\n【スラッシングの発生】\n①OSは、各プログラムのページの一部（例: 各プログラム200MBずつ、合計2GB）をRAMに配置\n②ユーザーがプログラムAに切り替える → プログラムAのページの一部がハードディスクにある → ページフォルト発生 → ページイン（HDDからRAMへ）\n③RAMが満杯なので、プログラムBのページをページアウト（RAMからHDDへ）\n④ユーザーがプログラムBに切り替える → プログラムBのページがハードディスクにある → ページフォルト発生 → ページイン\n⑤RAMが満杯なので、プログラムCのページをページアウト\n...\n\nページフォルトが延々と繰り返され、システムはほとんどページの読み込み・退避の処理に時間を使い、プログラムの実行が進みません。CPUはアイドル状態（待機状態）になり、ハードディスクは常にアクセスされ続けます。\n\n【スラッシングの症状】\n①システムが非常に遅い（マウスのクリックに数秒～数十秒かかる）\n②ハードディスクのアクセスランプが常に点灯\n③CPU使用率が低い（例: 10%、CPUはページフォルト処理を待っている）\n④メモリ使用率が100%\n\n【スラッシングの対策】\n①同時に実行するプログラムを減らす（例: 10個 → 5個）\n②物理メモリを増設する（4GB → 8GB）\n③不要なバックグラウンドプログラムを終了する\n④ページ置き換えアルゴリズムを改善する（LRU）\n⑤ワーキングセットモデル（後述）を使用する"
        },
        {
          "type": "text",
          "content": "スラッシングを防ぐために、OSは**ワーキングセット（Working Set）**という概念を使います。ワーキングセットとは、プログラムが一定期間内に頻繁にアクセスするページの集合です。OSは、各プログラムのワーキングセットを計算し、ワーキングセット全体が物理メモリに収まるように、実行するプログラム数を調整します（プロセス数の制御）。例えば、各プログラムのワーキングセットが500MBで、物理メモリが4GBの場合、OSは最大8個のプログラムしか同時に実行しません（8 × 500MB = 4GB）。ワーキングセットモデルにより、スラッシングを防ぎ、システムの性能を維持できます。"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "局所性の原理",
          "content": "プログラムは、**局所性の原理（Principle of Locality）**に従って動作します。局所性には、①**時間的局所性（Temporal Locality）**: 最近アクセスされたメモリは、近い将来も再びアクセスされる可能性が高い（例: ループ内の変数）、②**空間的局所性（Spatial Locality）**: あるメモリ領域がアクセスされると、その近くのメモリ領域もアクセスされる可能性が高い（例: 配列の要素）、の2種類があります。ページング方式とページ置き換えアルゴリズム（LRU）は、局所性の原理を活用して、ページフォルト率を低く保ちます。局所性の原理により、仮想記憶は実用的な性能を達成しています。"
        }
      ]
    },
    {
      "id": 5,
      "title": "セグメント方式と仮想記憶の応用",
      "sections": [
        {
          "type": "text",
          "content": "**セグメント方式（Segmentation）**とは、プログラムを論理的な単位（セグメント、Segment）に分割して管理する方式です。セグメントは、プログラムの構造に応じて分割されます（例: コードセグメント、データセグメント、スタックセグメント）。各セグメントは、可変サイズで、セグメントテーブルを使って管理されます。セグメント方式の利点は、①プログラムの論理構造を反映できる（モジュール化）、②セグメント単位でアクセス制御ができる（例: コードセグメントは読み取り専用）、などです。欠点は、①外部フラグメンテーションが発生する（セグメントは可変サイズ）、②実装が複雑、などです。"
        },
        {
          "type": "example",
          "title": "セグメント方式の具体例",
          "content": "【プログラムの構造】\nプログラムは、以下の3つのセグメントで構成されています。\n\nセグメント番号 | セグメント名 | サイズ | 説明\n-------------|------------|-------|-----\n0            | コードセグメント | 100KB | プログラムのコード（命令）\n1            | データセグメント | 50KB  | グローバル変数、静的変数\n2            | スタックセグメント | 20KB | 関数の引数、ローカル変数\n\n【セグメントテーブル】\nセグメント番号 | 基底アドレス（物理メモリの開始位置） | セグメントサイズ | アクセス権限\n-------------|--------------------------------|----------------|------------\n0            | 0x10000000                      | 100KB          | 読み取り・実行\n1            | 0x20000000                      | 50KB           | 読み取り・書き込み\n2            | 0x30000000                      | 20KB           | 読み取り・書き込み\n\n【仮想アドレスの構造】\n仮想アドレス = セグメント番号 + セグメント内オフセット\n例: セグメント1の1,000バイト目 → 仮想アドレス = (1, 1000)\n\n【アドレス変換】\n①セグメントテーブルを参照して、セグメント1の基底アドレス（0x20000000）を取得\n②物理アドレス = 基底アドレス + セグメント内オフセット = 0x20000000 + 1000 = 0x200003E8\n③物理アドレス0x200003E8にアクセス\n\n【セグメント方式の利点】\n①論理的な単位で管理: コード、データ、スタックを別々のセグメントとして管理\n②アクセス制御: コードセグメントは読み取り専用、データセグメントは読み書き可能\n③共有が容易: 複数のプログラムが同じコードセグメント（ライブラリ）を共有できる"
        },
        {
          "type": "text",
          "content": "現在のOSでは、**ページング方式とセグメント方式を組み合わせた方式（セグメントページング方式、Segmented Paging）**が使われることがあります。セグメントページング方式では、プログラムをまずセグメントに分割し、各セグメントをさらにページに分割します。これにより、①セグメント方式の利点（論理的な管理、アクセス制御）、②ページング方式の利点（固定サイズで管理しやすい、外部フラグメンテーションが少ない）、の両方を享受できます。ただし、実装が複雑になるため、最近のOSでは、ページング方式のみを使用することが多いです（セグメントは論理的な概念として扱い、実際の管理はページで行う）。"
        },
        {
          "type": "table",
          "headers": ["方式", "分割単位", "サイズ", "外部フラグメンテーション", "実装の複雑さ", "使用状況"],
          "rows": [
            ["ページング方式", "ページ（固定サイズ）", "4KB", "発生しない", "中程度", "現在の主流"],
            ["セグメント方式", "セグメント（可変サイズ）", "可変", "発生する", "複雑", "ほとんど使われていない"],
            ["セグメントページング方式", "セグメント→ページ", "セグメント可変、ページ固定", "発生しない", "非常に複雑", "一部のOSで使用"]
          ]
        },
        {
          "type": "example",
          "title": "仮想記憶の応用例",
          "content": "【①メモリマップドファイル（Memory-Mapped File）】\nファイルを仮想メモリ空間にマッピング（割り当て）し、ファイルをメモリのように読み書きする技術。OSが自動的にファイルとRAMの間でデータを転送するため、プログラマはファイルI/Oを意識せずに済む。大規模ファイルの処理に有効。\n\n【②共有メモリ（Shared Memory）】\n複数のプログラム（プロセス）が同じ物理メモリ領域を共有し、高速にデータをやり取りする技術。プロセス間通信（IPC）の一種。仮想記憶により、各プログラムは異なる仮想アドレスで同じ物理メモリにアクセスできる。\n\n【③コピーオンライト（Copy-On-Write, COW）】\nプログラムをコピー（fork）する際、最初は親プロセスと子プロセスが同じ物理メモリを共有し、データを書き換えようとした時点でコピーを作成する技術。メモリ使用量を削減し、プロセス生成を高速化する。\n\n【④デマンドページング（Demand Paging）】\nプログラム起動時に全てのページをRAMに読み込むのではなく、必要になったページだけを読み込む技術。プログラムの起動時間を短縮し、メモリ使用量を削減する。現在のOSで標準的に使用される。\n\nこれらの応用技術により、仮想記憶は現代のOSの基盤技術となっています。"
        },
        {
          "type": "highlight",
          "icon": "📌",
          "title": "仮想記憶の歴史と未来",
          "content": "仮想記憶は、1960年代にメインフレームコンピュータで開発されました。当時、メモリは非常に高価で（1MB = 数百万円）、限られたメモリで大規模プログラムを実行する必要がありました。1970年代～1980年代に、ページング方式が確立され、UNIX、VAX/VMSなどのOSで採用されました。1990年代以降、Windows、macOS、Linuxなどの一般的なOSで標準的に使用されるようになりました。現在では、スマートフォン、タブレットを含む、ほぼ全てのコンピュータで仮想記憶が使われています。将来的には、不揮発性メモリ（NVRAM）の普及により、仮想記憶の概念が変化する可能性がありますが、基本的な原理（メモリの抽象化、保護、共有）は引き続き重要です。"
        }
      ]
    }
  ]
}
