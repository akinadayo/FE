{
  "topicId": "tech-3-3-5",
  "title": "データベース応用",
  "pages": [
    {
      "id": 1,
      "title": "分散データベース",
      "sections": [
        {
          "type": "text",
          "content": "**分散データベース（Distributed Database）**とは、複数のコンピュータ（ノード）にデータを分散配置し、論理的には1つのデータベースとして扱う仕組みです。利用者は、データがどのノードに保存されているかを意識せずに、あたかも1つのデータベースにアクセスしているかのように操作できます。分散データベースの目的は、①可用性の向上（1つのノードが故障しても他のノードで処理を継続）、②性能の向上（複数ノードで処理を分散し、負荷を分散）、③地理的な分散（各拠点にデータを配置し、ネットワーク遅延を削減）、です。"
        },
        {
          "type": "table",
          "headers": ["方式", "説明", "長所", "短所"],
          "rows": [
            ["集中型データベース", "1つのサーバーに全データを集約", "管理が簡単、整合性が保ちやすい", "単一障害点（サーバー故障で全停止）、性能限界がある"],
            ["分散データベース", "複数のサーバーにデータを分散", "可用性が高い、性能向上、地理的分散", "管理が複雑、整合性維持が困難"]
          ]
        },
        {
          "type": "example",
          "title": "分散データベースの具体例：全国チェーンの在庫管理",
          "content": "【シナリオ】\n全国に10店舗を持つ小売チェーン。各店舗にデータベースサーバーを配置し、在庫情報を分散管理する。\n\n【データ配置】\n東京店サーバー：東京店の在庫データ（商品A: 50個、商品B: 30個...）\n大阪店サーバー：大阪店の在庫データ（商品A: 40個、商品B: 25個...）\n...（各店舗にサーバー配置）\n\n【利用者の操作】\n本部の管理者が「全国の商品Aの在庫合計を知りたい」と問い合わせる。\n→ システムが自動的に10店舗のサーバーにアクセスし、在庫を集計して結果を返す（利用者は1つのデータベースにアクセスしているように見える）\n\n【利点】\n①可用性：東京店のサーバーが故障しても、大阪店など他店舗は営業を継続できる\n②性能：各店舗での在庫照会は自店舗のサーバーにアクセスするだけで高速\n③地理的分散：各店舗のデータは自店舗サーバーにあるため、ネットワーク遅延が少ない"
        },
        {
          "type": "highlight",
          "icon": "🔧",
          "title": "分散データベースの透過性",
          "content": "①位置透過性：利用者はデータの物理的な配置場所を意識しない\n②分割透過性：データが複数のサーバーに分割されていることを意識しない\n③複製透過性：データが複製されていることを意識しない\n\nこれらの透過性により、利用者は分散データベースを集中型データベースと同じように扱えます。"
        }
      ]
    },
    {
      "id": 2,
      "title": "データウェアハウスとデータマート",
      "sections": [
        {
          "type": "text",
          "content": "**データウェアハウス（Data Warehouse、DWH）**とは、企業の様々な業務システムから収集した大量のデータを、分析目的で統合・蓄積したデータベースです。日々の業務処理（OLTP: Online Transaction Processing）とは別に、過去の膨大なデータを分析（OLAP: Online Analytical Processing）するために使われます。データウェアハウスは、①時系列データ（過去数年分のデータを保持）、②主題別（商品別、顧客別など）、③統合（複数システムのデータを統一フォーマットで格納）、④非更新（一度格納したデータは基本的に更新しない）、という特徴があります。"
        },
        {
          "type": "example",
          "title": "データウェアハウスの具体例：小売業の売上分析",
          "content": "【データソース】\n①POSシステム：毎日の売上データ（商品ID、数量、金額、日時、店舗...）\n②在庫管理システム：在庫データ（商品ID、在庫数、入庫日...）\n③顧客管理システム：顧客データ（顧客ID、年齢、性別、住所...）\n\n【データウェアハウスへの統合】\n毎晩、上記3つのシステムからデータを抽出し、データウェアハウスに統合。\n例：「2024年1月1日、東京店で、30代女性の顧客Aが商品Bを5個購入、売上10,000円」という統合データを作成。\n\n【分析例】\n①経営者「過去5年間の月別売上推移を知りたい」→ データウェアハウスから集計\n②マーケティング担当「30代女性に人気の商品TOP10は？」→ 顧客属性と購入商品を分析\n③店長「今年の夏、どの商品が売れ筋か？」→ 季節・商品別の分析\n\n【特徴の適用】\n①時系列データ：過去5年分のデータを保持（日々の業務システムは直近数ヶ月のみ保持）\n②主題別：商品別、顧客別、店舗別など、分析テーマごとにデータを整理\n③統合：POS、在庫、顧客の3システムのデータを統一フォーマットで格納\n④非更新：一度格納した売上データは修正しない（訂正は別レコードで管理）"
        },
        {
          "type": "text",
          "content": "**データマート（Data Mart）**とは、データウェアハウスの一部を、特定の部門や目的に特化して切り出した小規模なデータベースです。例えば、データウェアハウスから「営業部門に必要なデータのみ」を抽出して営業部門専用のデータマートを作成します。データマートは、①構築が容易（全社データウェアハウスより小規模）、②分析が高速（必要なデータのみに絞られている）、③部門ごとに最適化、という利点があります。データウェアハウス（全社）→ データマート（部門別）という階層構造が一般的です。"
        },
        {
          "type": "table",
          "headers": ["項目", "データウェアハウス", "データマート"],
          "rows": [
            ["対象範囲", "全社（全部門）", "特定部門（営業部、マーケティング部など）"],
            ["データ量", "大量（数TB〜数PB）", "中小量（数GB〜数TB）"],
            ["構築コスト", "高い（全システム統合）", "低い（必要データのみ）"],
            ["分析速度", "やや遅い（データ量が多い）", "速い（データ量が少ない）"],
            ["具体例", "全社売上データベース（全商品、全顧客、全店舗）", "営業部門用データベース（営業担当の顧客・売上のみ）"]
          ]
        }
      ]
    },
    {
      "id": 3,
      "title": "OLTP と OLAP",
      "sections": [
        {
          "type": "text",
          "content": "**OLTP（Online Transaction Processing、オンライントランザクション処理）**とは、日々の業務処理を行うシステムです。例：ATM、POSレジ、ネットショッピング。特徴は、①リアルタイム処理（即座に処理結果を返す）、②小規模なトランザクション（1件の入金、1件の販売など）、③更新が頻繁（INSERT、UPDATE、DELETEが多い）、④最新データが重要（過去データは参照頻度が低い）、です。OLTPは「業務を回す」ことが目的です。"
        },
        {
          "type": "text",
          "content": "**OLAP（Online Analytical Processing、オンライン分析処理）**とは、大量の蓄積データを分析するシステムです。例：売上分析、顧客分析、経営ダッシュボード。特徴は、①バッチ処理・集計処理（大量データを集計）、②大規模なクエリ（数年分のデータを集計）、③参照が中心（SELECT が多い、更新は少ない）、④過去データが重要（時系列分析、トレンド分析）、です。OLAPは「経営判断を支援」することが目的です。データウェアハウスはOLAP用のデータベースです。"
        },
        {
          "type": "table",
          "headers": ["項目", "OLTP（業務処理）", "OLAP（分析処理）"],
          "rows": [
            ["目的", "日々の業務を処理", "経営判断を支援"],
            ["処理内容", "INSERT、UPDATE、DELETE（更新が多い）", "SELECT（集計・分析、更新は少ない）"],
            ["トランザクション", "小規模（1件の入金、1件の販売）", "大規模（数年分のデータを集計）"],
            ["データ量", "少量（直近数ヶ月分）", "大量（過去数年分）"],
            ["応答時間", "即座（数秒以内）", "やや遅い（数分〜数時間）"],
            ["具体例", "ATM、POSレジ、ネットショッピング", "売上分析、顧客分析、経営ダッシュボード"]
          ]
        },
        {
          "type": "example",
          "title": "OLTP vs OLAP の具体例：銀行システム",
          "content": "【OLTP（業務処理）】\nシナリオ：顧客がATMで10,000円を預金\n処理内容：①口座表で顧客の残高を読み取る、②残高に10,000円を加算、③口座表を更新、④取引履歴表に1件挿入\n特徴：リアルタイム（数秒で完了）、小規模（1件の更新）、更新が中心\n\n【OLAP（分析処理）】\nシナリオ：経営者が「過去5年間の月別預金残高推移」を知りたい\n処理内容：①過去5年分の取引履歴表を読み取る、②月別に集計、③グラフを生成\n特徴：バッチ処理（数分かかる）、大規模（数百万件のデータを集計）、参照が中心\n\n【システム分離の理由】\nOLTPシステムでOLAP処理を実行すると、大量データの集計処理が業務処理を遅延させる（ATMが使えなくなる）。そのため、OLTP用の業務データベース（最新データ）とOLAP用のデータウェアハウス（過去データ）を分離し、毎晩、OLTP → データウェアハウス へデータをコピーする。"
        }
      ]
    },
    {
      "id": 4,
      "title": "データマイニング",
      "sections": [
        {
          "type": "text",
          "content": "**データマイニング（Data Mining）**とは、大量のデータから、これまで知られていなかった有用なパターンや知識を発見する技術です。「マイニング（mining）」は「採掘」の意味で、データの山から「宝石（有用な知識）」を掘り出すイメージです。データマイニングは、統計学、機械学習、人工知能などの手法を使い、人間では気づかない隠れたパターンを自動的に発見します。主な手法として、①分類（Classification）：データをカテゴリに分類、②クラスタリング（Clustering）：類似データをグループ化、③相関分析（Association Analysis）：関連性の高い項目を発見、④回帰分析（Regression）：数値の予測、があります。"
        },
        {
          "type": "example",
          "title": "データマイニングの具体例：スーパーのバスケット分析",
          "content": "【シナリオ】\nスーパーのPOSデータ（購入商品の組み合わせ）から、「一緒に購入される商品の組み合わせ」を発見したい。\n\n【データ】\n顧客A：ビール、おむつ、牛乳\n顧客B：ビール、おむつ、パン\n顧客C：ビール、おむつ、卵\n...\n（数万件の購入履歴）\n\n【データマイニング実行】\n手法：相関分析（アソシエーション分析）\nアルゴリズム：Apriori（アプリオリ）\n\n【発見されたパターン】\n「ビールとおむつを一緒に購入する顧客が多い」（支持度70%、信頼度80%）\n\n【仮説】\n若い父親が、週末に赤ちゃんのおむつを買うついでに、自分用のビールも購入している。\n\n【施策】\nおむつ売り場の近くにビールを陳列 → 売上が10%向上\n\n【データマイニングの価値】\n人間では気づかない「ビールとおむつ」という意外な組み合わせを、データから自動的に発見できた。"
        },
        {
          "type": "table",
          "headers": ["手法", "目的", "具体例"],
          "rows": [
            ["分類（Classification）", "データをカテゴリに分類", "メールをスパム/非スパムに分類"],
            ["クラスタリング（Clustering）", "類似データをグループ化", "顧客を「高所得層」「中所得層」「低所得層」にグループ化"],
            ["相関分析（Association）", "関連性の高い項目を発見", "ビールとおむつを一緒に購入する"],
            ["回帰分析（Regression）", "数値を予測", "過去の売上データから来月の売上を予測"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "データマイニングの応用例",
          "content": "①マーケティング：顧客セグメンテーション、商品推薦（「この商品を買った人は○○も買っています」）\n②医療：病気の予測（過去の患者データから病気の発症リスクを予測）\n③金融：不正検出（クレジットカードの不正利用パターンを検出）\n④製造：品質予測（製造データから不良品を予測）"
        }
      ]
    },
    {
      "id": 5,
      "title": "ビッグデータとNoSQL",
      "sections": [
        {
          "type": "text",
          "content": "**ビッグデータ（Big Data）**とは、従来のデータベース技術では扱いきれないほど大量・多様・高速なデータのことです。ビッグデータの3V（Volume, Variety, Velocity）が特徴です。①Volume（量）：データ量が膨大（TB、PB、EB単位）、②Variety（多様性）：構造化データ（表形式）だけでなく、非構造化データ（画像、動画、テキスト、SNS投稿など）も含む、③Velocity（速度）：データが高速に生成される（SNSの投稿、センサーデータなど）。ビッグデータを分析することで、新たなビジネス価値を創出できます（例：Google検索、Netflix推薦、自動運転）。"
        },
        {
          "type": "example",
          "title": "ビッグデータの具体例：自動運転車",
          "content": "【データソース】\n①カメラ：道路の画像・動画（毎秒数GB）\n②LiDAR：周囲の物体の3D位置データ（毎秒数MB）\n③GPS：車の位置情報（毎秒数KB）\n④センサー：速度、加速度、ブレーキ圧など（毎秒数KB）\n\n【ビッグデータの3V】\n①Volume（量）：1台の自動運転車が1日で生成するデータは数TB。世界中の自動運転車のデータは数PB〜数EB。\n②Variety（多様性）：画像（非構造化）、3D位置データ（半構造化）、GPS（構造化）など、多様なデータ形式。\n③Velocity（速度）：毎秒数GBのデータが高速に生成される。リアルタイム処理が必要。\n\n【分析と価値創出】\n①安全性向上：過去の事故データを分析し、危険な運転パターンを検出\n②経路最適化：渋滞データを分析し、最適な経路を提案\n③自動運転AI：数億kmの走行データを学習し、自動運転AIを改善"
        },
        {
          "type": "text",
          "content": "**NoSQL（Not only SQL）**とは、従来のリレーショナルデータベース（RDBMS）とは異なる設計思想のデータベースです。RDBMSは表形式のデータを扱い、ACIDトランザクションを保証しますが、大規模分散環境では性能が低下します。NoSQLは、①水平スケーラビリティ（サーバーを追加することで性能を向上）、②柔軟なデータモデル（表形式に縛られない）、③高速な読み書き（一部の整合性を犠牲にして性能を優先）、を重視します。NoSQLの種類として、①キーバリュー型（Key-Value Store）：Redis、②ドキュメント型（Document Store）：MongoDB、③カラム指向型（Column Store）：Cassandra、④グラフ型（Graph Database）：Neo4j、があります。"
        },
        {
          "type": "table",
          "headers": ["項目", "RDBMS（SQL）", "NoSQL"],
          "rows": [
            ["データモデル", "表形式（行・列）", "柔軟（キーバリュー、ドキュメント、グラフなど）"],
            ["トランザクション", "ACIDを厳密に保証", "一部の整合性を犠牲にして性能を優先（BASE）"],
            ["スケーラビリティ", "垂直（サーバーのスペックを上げる）", "水平（サーバーを追加する）"],
            ["適用例", "銀行システム、会計システム（整合性が最重要）", "SNS、IoTセンサーデータ（性能・可用性が最重要）"],
            ["具体例", "MySQL、PostgreSQL、Oracle", "Redis、MongoDB、Cassandra、Neo4j"]
          ]
        },
        {
          "type": "example",
          "title": "NoSQLの具体例：SNSのタイムライン",
          "content": "【要件】\nTwitterのようなSNSで、「フォロワー数100万人のユーザーが投稿した瞬間、100万人のタイムラインに即座に反映させる」という処理が必要。\n\n【RDBMSでの問題】\nRDBMSでは、100万人分のタイムライン表（user_id, post_id）に100万行をINSERTする必要がある。これは時間がかかり、リアルタイム性が失われる。また、トランザクションの厳密な整合性を保つため、ロック待ちが発生し、性能が低下する。\n\n【NoSQLでの解決】\nRedis（キーバリュー型）を使用。各ユーザーのタイムラインをキー（user_123_timeline）に対応するリスト（投稿IDのリスト）として保存。投稿時に、フォロワー100万人のキーに対して、投稿IDをリストに追加（並列処理で高速）。一部のユーザーのタイムライン更新が遅れても許容（結果整合性、Eventual Consistency）。\n\n【利点】\n①高速：並列処理で100万人のタイムラインを数秒で更新\n②スケーラビリティ：サーバーを追加することで性能を向上\n③柔軟性：タイムラインのデータ構造を柔軟に変更可能"
        },
        {
          "type": "highlight",
          "icon": "📌",
          "title": "RDBMS vs NoSQL の使い分け",
          "content": "RDBMS（SQL）を使うべき場合：\n①トランザクションの厳密な整合性が必要（銀行、会計、在庫管理）\n②複雑な検索・集計（JOIN、GROUP BY など）\n③データ構造が定まっている\n\nNoSQLを使うべき場合：\n①大量データを高速に処理（SNS、IoT、ログ分析）\n②水平スケーラビリティが必要（サーバーを追加して性能向上）\n③柔軟なデータ構造（スキーマレス）が必要"
        }
      ]
    }
  ]
}
