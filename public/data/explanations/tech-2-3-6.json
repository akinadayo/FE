{
  "topicId": "tech-2-3-6",
  "title": "プログラムの性質",
  "pages": [
    {
      "id": 1,
      "title": "プログラムの性質の概要とリロケータブルプログラム",
      "sections": [
        {
          "type": "text",
          "content": "**プログラムの性質**とは、プログラムがどのような環境で実行できるか、どのように再利用できるかを示す特性です。OSがプログラムを効率的に管理するために、プログラムには以下の4つの重要な性質があります。①**再配置可能（Relocatable、リロケータブル）**、②**再使用可能（Reusable、リユーザブル）**、③**再入可能（Reentrant、リエントラント）**、④**再帰的（Recursive、リカーシブ）**。これらの性質を持つプログラムは、メモリを効率的に使用でき、マルチタスク環境で安全に実行できます。"
        },
        {
          "type": "table",
          "headers": ["性質", "英語", "説明", "主な用途"],
          "rows": [
            ["再配置可能", "Relocatable（リロケータブル）", "メモリのどの位置に配置しても実行できる", "OSがメモリの空き領域に配置"],
            ["再使用可能", "Reusable（リユーザブル）", "実行後、再度読み込むことなく繰り返し実行できる", "メモリ節約"],
            ["再入可能", "Reentrant（リエントラント）", "複数のプログラムから同時に呼び出しても正しく動作する", "共有ライブラリ、マルチスレッド"],
            ["再帰的", "Recursive（リカーシブ）", "関数が自分自身を呼び出せる", "再帰アルゴリズム（階乗、フィボナッチ数列）"]
          ]
        },
        {
          "type": "text",
          "content": "**リロケータブルプログラム（Relocatable Program、再配置可能プログラム）**とは、メモリのどの位置に配置しても正しく実行できるプログラムです。通常、プログラムは絶対アドレス（固定されたメモリアドレス、例: 0x10000000）を使ってメモリにアクセスしますが、リロケータブルプログラムは相対アドレス（プログラムの先頭からの相対的な位置）を使います。OSがプログラムをメモリの任意の位置に配置できるため、メモリの空き領域を柔軟に利用できます。現在のOSでは、ほとんどのプログラムがリロケータブルです。"
        },
        {
          "type": "example",
          "title": "リロケータブルプログラムの具体例",
          "content": "【背景】\nあるプログラムは、変数Aを参照するコードを含んでいます。\n\n【絶対アドレスを使う場合（リロケータブルでない）】\nプログラムのコード:\n  LOAD R1, 0x10000100  ; 変数A（アドレス0x10000100）をレジスタR1に読み込む\n\nプログラムは、変数Aが常にアドレス0x10000100に配置されていると仮定しています。\n\n問題点:\n①OSがプログラムをアドレス0x20000000に配置した場合、変数Aの実際のアドレスは0x20000100になりますが、プログラムは0x10000100を参照しようとします → 間違ったデータを読み込む（バグ）\n②プログラムは、常に特定のメモリアドレス（0x10000000～）に配置する必要があり、メモリの空き領域を柔軟に利用できない\n\n【相対アドレスを使う場合（リロケータブル）】\nプログラムのコード:\n  LOAD R1, [BASE + 0x100]  ; ベースアドレス + 0x100の位置にある変数AをレジスタR1に読み込む\n\nBASEレジスタには、プログラムの先頭アドレスが設定されています。\n\n利点:\n①OSがプログラムをアドレス0x10000000に配置した場合:\n  BASEレジスタ = 0x10000000\n  変数Aのアドレス = 0x10000000 + 0x100 = 0x10000100\n\n②OSがプログラムをアドレス0x20000000に配置した場合:\n  BASEレジスタ = 0x20000000\n  変数Aのアドレス = 0x20000000 + 0x100 = 0x20000100\n\nどちらの場合も、プログラムは正しく変数Aを参照できます。OSは、プログラムをメモリのどの位置に配置してもよく、メモリの空き領域を柔軟に利用できます。"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "リロケーション（再配置）",
          "content": "**リロケーション（Relocation）**とは、プログラムをメモリの特定の位置に配置する際に、プログラム内のアドレスを調整する処理です。リロケータブルプログラムでは、OSがプログラムをロード（読み込み）する際に、BASEレジスタにプログラムの先頭アドレスを設定します。また、リンカ（プログラムをリンクするツール）は、相対アドレスを絶対アドレスに変換する情報（リロケーション情報）をプログラムに付加します。現在のOSでは、仮想記憶を使うため、プログラムは常に同じ仮想アドレス（例: 0x00000000～）から始まるように見え、リロケーションは物理アドレスレベルで自動的に行われます。"
        }
      ]
    },
    {
      "id": 2,
      "title": "リユーザブルプログラム（再使用可能）",
      "sections": [
        {
          "type": "text",
          "content": "**リユーザブルプログラム（Reusable Program、再使用可能プログラム）**とは、実行後、再度ディスクから読み込むことなく、繰り返し実行できるプログラムです。リユーザブルプログラムは、実行中にコード部分（命令）を変更せず、データ部分だけを変更します。実行が終了すると、データ部分を初期状態に戻すことで、再度実行できます。リユーザブルプログラムの利点は、①メモリ節約（同じプログラムを複数回実行する場合、1回だけメモリに読み込めばよい）、②ディスクアクセスの削減（再度読み込む必要がない）、です。"
        },
        {
          "type": "example",
          "title": "リユーザブルプログラムの具体例",
          "content": "【プログラムの構造】\nプログラムは、コード部分（命令）とデータ部分（変数）で構成されています。\n\nコード部分（読み取り専用）:\n  LOAD R1, [DATA_A]   ; 変数Aをレジスタに読み込む\n  ADD R1, 10          ; レジスタに10を加算\n  STORE R1, [DATA_A]  ; レジスタを変数Aに書き込む\n  ...\n\nデータ部分（読み書き可能）:\n  DATA_A: 0  ; 変数A（初期値: 0）\n\n【リユーザブルでない場合】\nプログラムが、コード部分を変更する場合（自己書き換えコード）:\n  LOAD R1, [DATA_A]\n  ADD R1, 10\n  STORE R1, [CODE_START]  ; コード部分を変更（自己書き換え）\n\n問題点:\n①実行後、コード部分が変更されているため、再度実行すると正しく動作しない\n②再度実行するには、ディスクからプログラムを読み込み直す必要がある（メモリとディスクアクセスの無駄）\n\n【リユーザブルの場合】\nプログラムが、コード部分を変更しない場合:\n  LOAD R1, [DATA_A]   ; 変数Aをレジスタに読み込む\n  ADD R1, 10          ; レジスタに10を加算\n  STORE R1, [DATA_A]  ; レジスタを変数Aに書き込む（データ部分のみ変更）\n\n利点:\n①実行後、コード部分は変更されていないため、データ部分を初期状態に戻せば再度実行できる\n②再度ディスクから読み込む必要がない（メモリとディスクアクセスを節約）\n\n【リユーザブルプログラムの実行】\n①1回目の実行:\n  DATA_A: 0 → 10（10を加算）\n  実行終了\n\n②データ部分を初期状態に戻す:\n  DATA_A: 10 → 0（初期値に戻す）\n\n③2回目の実行:\n  DATA_A: 0 → 10（10を加算）\n  実行終了\n\nプログラムを再度ディスクから読み込むことなく、繰り返し実行できます。"
        },
        {
          "type": "text",
          "content": "現在のOSでは、プログラムのコード部分とデータ部分を別々のメモリ領域に配置し、コード部分を読み取り専用（Read-Only）、データ部分を読み書き可能（Read-Write）に設定します。これにより、コード部分が誤って変更されることを防ぎ、リユーザブルプログラムを実現しています。また、複数のプロセスが同じプログラムを実行する場合、コード部分は共有し、データ部分は各プロセスごとに別々に確保することで、メモリを節約します（例: 複数のユーザーが同じテキストエディタを実行する場合、コード部分は1つ、データ部分は各ユーザーごと）。"
        },
        {
          "type": "highlight",
          "icon": "🔧",
          "title": "リユーザブルとリロケータブルの違い",
          "content": "**リロケータブル（再配置可能）**は、「どこに配置しても実行できる」という性質（配置の柔軟性）。**リユーザブル（再使用可能）**は、「繰り返し実行できる」という性質（実行の効率性）。両者は独立した性質で、リロケータブルかつリユーザブルなプログラムが理想的です。現在のOSで動作するほとんどのプログラムは、リロケータブルかつリユーザブルです。"
        }
      ]
    },
    {
      "id": 3,
      "title": "リエントラントプログラム（再入可能）",
      "sections": [
        {
          "type": "text",
          "content": "**リエントラントプログラム（Reentrant Program、再入可能プログラム）**とは、複数のプログラム（プロセス、スレッド）から同時に呼び出されても、正しく動作するプログラムです。リエントラントプログラムは、実行中にデータ部分を変更しないか、各呼び出しごとに独立したデータ領域（スタック）を使用します。リエントラントプログラムの利点は、①共有ライブラリとして使用できる（複数のプログラムが同じライブラリを共有）、②マルチスレッドプログラムで安全に使用できる（複数のスレッドが同時に同じ関数を呼び出す）、③メモリ節約（1つのプログラムを複数のプロセスで共有）、です。"
        },
        {
          "type": "example",
          "title": "リエントラントプログラムの具体例",
          "content": "【リエントラントでない場合（グローバル変数を使用）】\n```c\nint counter = 0;  // グローバル変数（全てのスレッドで共有）\n\nvoid increment() {\n    counter = counter + 1;  // グローバル変数を変更\n}\n```\n\n問題点:\n①スレッドAがincrement()を呼び出し、counter = 0を読み込む\n②スレッドBが同時にincrement()を呼び出し、counter = 0を読み込む\n③スレッドAがcounter = 0 + 1 = 1を計算し、counterに書き込む → counter = 1\n④スレッドBがcounter = 0 + 1 = 1を計算し、counterに書き込む → counter = 1\n\n期待する結果: counter = 2（2回インクリメント）\n実際の結果: counter = 1（競合状態、Race Condition）\n\nグローバル変数を使うため、複数のスレッドから同時に呼び出すと、正しく動作しません。\n\n【リエントラントの場合（ローカル変数を使用）】\n```c\nvoid increment(int *counter) {  // 引数として受け取る\n    int temp = *counter;  // ローカル変数（スタックに配置）\n    temp = temp + 1;\n    *counter = temp;\n}\n```\n\n各スレッドの実行:\n①スレッドAがincrement(&counter_A)を呼び出す\n  → ローカル変数tempはスレッドAのスタックに配置\n  → counter_A = counter_A + 1\n\n②スレッドBが同時にincrement(&counter_B)を呼び出す\n  → ローカル変数tempはスレッドBのスタックに配置（スレッドAとは独立）\n  → counter_B = counter_B + 1\n\n各スレッドが独立したデータ領域（スタック）を使うため、同時に呼び出しても正しく動作します。\n\n【リエントラントプログラムの条件】\n①グローバル変数や静的変数を変更しない（読み取り専用はOK）\n②各呼び出しごとに独立したデータ領域（スタック、引数）を使用\n③共有リソース（ファイル、データベース）へのアクセスは排他制御（ロック）を使用"
        },
        {
          "type": "text",
          "content": "リエントラントプログラムは、共有ライブラリ（Shared Library、DLL）やマルチスレッドプログラムで重要です。共有ライブラリは、複数のプログラムが同じライブラリのコードを共有することで、メモリを節約します（例: 標準Cライブラリ、数学ライブラリ）。マルチスレッドプログラムでは、複数のスレッドが同時に同じ関数を呼び出すことがあります（例: Webサーバで複数のクライアントのリクエストを同時処理）。リエントラントでない関数を使うと、競合状態（Race Condition）が発生し、バグやセキュリティ問題を引き起こします。"
        },
        {
          "type": "table",
          "headers": ["プログラムの性質", "リユーザブル", "リエントラント", "違い"],
          "rows": [
            ["呼び出し回数", "1つのプロセスから繰り返し呼び出し", "複数のプロセス・スレッドから同時に呼び出し", "-"],
            ["データの扱い", "実行後にデータを初期状態に戻す", "各呼び出しごとに独立したデータ領域を使用", "-"],
            ["主な用途", "メモリ節約（再度ディスクから読み込まない）", "共有ライブラリ、マルチスレッドプログラム", "-"],
            ["関係", "リエントラントならリユーザブル", "リユーザブルでもリエントラントとは限らない", "リエントラントの方が厳しい条件"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "リエントラントプログラムの重要性",
          "content": "現在のOSでは、マルチコアCPUとマルチスレッドプログラミングが一般的です。リエントラントでない関数を使うと、複数のスレッドから同時に呼び出された際に、競合状態（Race Condition）、デッドロック、データ破損などの問題が発生します。これらの問題は、再現が難しく（タイミングに依存）、デバッグが非常に困難です。そのため、共有ライブラリや標準ライブラリの関数は、リエントラント（またはスレッドセーフ）であることが要求されます。例えば、POSIX規格では、一部の関数（strtokなど）にリエントラント版（strtok_r）が用意されています。"
        }
      ]
    },
    {
      "id": 4,
      "title": "リカーシブプログラム（再帰的）",
      "sections": [
        {
          "type": "text",
          "content": "**リカーシブプログラム（Recursive Program、再帰的プログラム）**とは、関数が自分自身を呼び出すプログラムです。再帰（Recursion）は、問題を小さな同じ問題に分割して解くアルゴリズムで、階乗、フィボナッチ数列、木構造の探索、分割統治法（クイックソート、マージソート）などで使われます。再帰プログラムは、スタック（後入れ先出し、LIFO）を使って、関数の呼び出しを管理します。各関数呼び出しごとに、ローカル変数と戻りアドレスがスタックに積まれます。"
        },
        {
          "type": "example",
          "title": "再帰プログラムの具体例：階乗の計算",
          "content": "【問題】\nn! (n の階乗) = n × (n-1) × (n-2) × ... × 2 × 1\n例: 5! = 5 × 4 × 3 × 2 × 1 = 120\n\n【再帰的な定義】\nn! = n × (n-1)!  (n > 0の場合)\n0! = 1          (基底条件)\n\n【再帰プログラム（疑似コード）】\n```python\ndef factorial(n):\n    if n == 0:           # 基底条件（再帰を終了する条件）\n        return 1\n    else:\n        return n * factorial(n - 1)  # 再帰呼び出し（自分自身を呼び出す）\n```\n\n【実行の流れ（factorial(5)を呼び出す）】\n①factorial(5)が呼ばれる\n  → n = 5なので、return 5 * factorial(4)\n  → factorial(4)を呼び出す（スタックに積む）\n\n②factorial(4)が呼ばれる\n  → n = 4なので、return 4 * factorial(3)\n  → factorial(3)を呼び出す（スタックに積む）\n\n③factorial(3)が呼ばれる\n  → n = 3なので、return 3 * factorial(2)\n  → factorial(2)を呼び出す（スタックに積む）\n\n④factorial(2)が呼ばれる\n  → n = 2なので、return 2 * factorial(1)\n  → factorial(1)を呼び出す（スタックに積む）\n\n⑤factorial(1)が呼ばれる\n  → n = 1なので、return 1 * factorial(0)\n  → factorial(0)を呼び出す（スタックに積む）\n\n⑥factorial(0)が呼ばれる\n  → n = 0なので、return 1（基底条件、再帰終了）\n\n【スタックから戻る】\n⑥factorial(0) → 1を返す\n⑤factorial(1) → 1 * 1 = 1を返す\n④factorial(2) → 2 * 1 = 2を返す\n③factorial(3) → 3 * 2 = 6を返す\n②factorial(4) → 4 * 6 = 24を返す\n①factorial(5) → 5 * 24 = 120を返す\n\n結果: factorial(5) = 120"
        },
        {
          "type": "text",
          "content": "再帰プログラムの利点は、①アルゴリズムがシンプルで理解しやすい（問題の定義をそのままコードにできる）、②コードが短い（ループを使うより簡潔）、です。欠点は、①スタックオーバーフロー（再帰の深さが深すぎるとスタックが溢れる）、②パフォーマンスが低い（関数呼び出しのオーバーヘッド、同じ計算を繰り返す）、です。再帰の深さが深い場合（例: factorial(10000)）、スタックオーバーフローが発生するため、ループを使った反復的なアルゴリズムに書き換える必要があります。"
        },
        {
          "type": "example",
          "title": "再帰の深さとスタックオーバーフロー",
          "content": "【スタックのサイズ】\n一般的なOSでは、各プログラム（プロセス、スレッド）のスタックサイズは制限されています（例: Linux: 8MB、Windows: 1MB）。\n\n【再帰の深さとスタック使用量】\n各関数呼び出しごとに、スタックに以下の情報が積まれます。\n①ローカル変数（例: n）\n②戻りアドレス（関数呼び出し後に戻る位置）\n③その他（レジスタの保存など）\n\n例: 1回の関数呼び出しで100バイトのスタックを使う場合\n\n再帰の深さ: 10,000回\nスタック使用量: 100バイト × 10,000 = 1,000,000バイト = 1MB\n\nスタックサイズが1MBの場合、factorial(10000)を呼び出すと、スタックオーバーフローが発生します。\n\n【スタックオーバーフローの対策】\n①再帰を反復（ループ）に書き換える\n```python\ndef factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = result * i\n    return result\n```\nスタック使用量: 定数（ループの深さに依存しない）\n\n②末尾再帰最適化（Tail Recursion Optimization）を使う\n一部のコンパイラは、末尾再帰（関数の最後が再帰呼び出し）を最適化し、スタックを使わないループに変換します。\n\n③再帰の深さを制限する\n例: factorial(n)でn > 1000の場合、エラーを返す"
        },
        {
          "type": "table",
          "headers": ["性質", "説明", "主な条件", "主な用途"],
          "rows": [
            ["リロケータブル", "どの位置に配置しても実行できる", "相対アドレスを使用", "OSのメモリ管理"],
            ["リユーザブル", "繰り返し実行できる", "コード部分を変更しない", "メモリ節約"],
            ["リエントラント", "同時に複数から呼び出しても正しく動作", "グローバル変数を変更しない、独立したデータ領域を使用", "共有ライブラリ、マルチスレッド"],
            ["リカーシブ", "関数が自分自身を呼び出せる", "スタックを使用、基底条件を設定", "再帰アルゴリズム（階乗、木構造の探索）"]
          ]
        },
        {
          "type": "highlight",
          "icon": "📌",
          "title": "プログラムの性質の関係",
          "content": "4つの性質は独立していますが、関連があります。①**リエントラントならリユーザブル**：リエントラントプログラムは、各呼び出しごとに独立したデータ領域を使うため、繰り返し実行できます（リユーザブル）。逆は成り立ちません（リユーザブルでもグローバル変数を使う場合、リエントラントでない）。②**リカーシブはリエントラント**：再帰プログラムは、関数が自分自身を呼び出すため、リエントラントである必要があります（各呼び出しごとに独立したスタック領域を使う）。現在のOSで動作するプログラムは、ほとんどがリロケータブル、リユーザブル、リエントラント、リカーシブの全てを満たしています。"
        }
      ]
    },
    {
      "id": 5,
      "title": "プログラムの性質のまとめと実例",
      "sections": [
        {
          "type": "text",
          "content": "プログラムの4つの性質（リロケータブル、リユーザブル、リエントラント、リカーシブ）は、現代のOSとプログラミングで重要な役割を果たしています。これらの性質を理解することで、①メモリを効率的に使用できる、②マルチタスク環境で安全にプログラムを実行できる、③再帰アルゴリズムを理解できる、などのメリットがあります。実際のソフトウェア開発では、これらの性質を意識してプログラムを設計することが重要です。"
        },
        {
          "type": "example",
          "title": "実際のソフトウェアでの活用例",
          "content": "【①共有ライブラリ（Shared Library、DLL）】\nLinuxの標準Cライブラリ（libc.so）、Windowsのシステムライブラリ（kernel32.dll）は、リロケータブル、リユーザブル、リエントラントです。\n\n利点:\n①複数のプログラムが同じライブラリのコードを共有 → メモリ節約（例: 10個のプログラムが同じlibc.soを使う場合、メモリには1つだけ配置）\n②ライブラリのアップデートが容易（プログラムを再コンパイルせず、ライブラリだけ更新）\n\n【②Webサーバ（Apache、Nginx）】\nWebサーバは、複数のクライアントのリクエストを同時処理するため、マルチスレッドまたはマルチプロセスを使います。リクエスト処理関数はリエントラントである必要があります。\n\n例:\n①クライアントAがリクエストを送信 → スレッド1がhandle_request()を呼び出す\n②クライアントBが同時にリクエストを送信 → スレッド2がhandle_request()を呼び出す\n\nhandle_request()がリエントラントでないと、スレッド1とスレッド2が同じグローバル変数を変更し、データが破損します。\n\n【③データベースシステム（MySQL、PostgreSQL）】\nデータベースシステムは、複数のクライアントから同時にクエリを受け付けるため、リエントラントなプログラムである必要があります。また、トランザクション処理には排他制御（ロック）が使われます。\n\n【④再帰アルゴリズムの活用】\nファイルシステムのディレクトリ探索、コンパイラの構文解析、グラフのDFS（深さ優先探索）など、再帰アルゴリズムは広く使われています。\n\n例: ディレクトリ探索\n```python\ndef list_files(directory):\n    for item in directory:\n        if item is file:\n            print(item.name)\n        elif item is directory:\n            list_files(item)  # 再帰呼び出し（サブディレクトリを探索）\n```"
        },
        {
          "type": "table",
          "headers": ["実例", "必要な性質", "理由"],
          "rows": [
            ["共有ライブラリ（libc.so、kernel32.dll）", "リロケータブル、リユーザブル、リエントラント", "複数のプログラムで共有、同時に呼び出される"],
            ["Webサーバ（Apache、Nginx）", "リエントラント", "複数のスレッドから同時にリクエスト処理関数を呼び出す"],
            ["再帰的なアルゴリズム（クイックソート、ディレクトリ探索）", "リカーシブ", "関数が自分自身を呼び出す"],
            ["OSのメモリ管理", "リロケータブル", "プログラムをメモリのどこに配置してもよい"]
          ]
        },
        {
          "type": "text",
          "content": "プログラムの性質は、OSの設計とプログラミング言語の機能に密接に関連しています。例えば、C言語では、グローバル変数を使うとリエントラントでなくなるため、マルチスレッドプログラムではスレッドローカルストレージ（TLS）やローカル変数を使います。Java、C#などの高級言語では、ガベージコレクション（自動メモリ管理）により、リユーザブルなプログラムを簡単に作成できます。Rustなどの言語では、コンパイラがスレッドセーフ（リエントラント）を検証し、競合状態を防ぎます。"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "プログラムの性質と試験のポイント",
          "content": "基本情報技術者試験では、4つの性質（リロケータブル、リユーザブル、リエントラント、リカーシブ）の定義と違いを理解することが重要です。①**リロケータブル**：どこに配置しても実行できる（相対アドレス）、②**リユーザブル**：繰り返し実行できる（コード部分を変更しない）、③**リエントラント**：同時に複数から呼び出しても正しく動作（独立したデータ領域）、④**リカーシブ**：関数が自分自身を呼び出せる（スタックを使用）。また、リエントラントならリユーザブル、リカーシブはリエントラントである必要がある、という関係も覚えておきましょう。"
        }
      ]
    }
  ]
}
