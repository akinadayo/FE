{
  "topicId": "tech-4-3-2",
  "title": "データ構造",
  "pages": [
    {
      "id": 1,
      "title": "配列とリストの基礎",
      "sections": [
        {
          "type": "text",
          "content": "**データ構造**とは、データを効率的に格納・管理・操作するための仕組みです。適切なデータ構造を選択することで、プログラムの実行速度やメモリ使用量を最適化できます。代表的なデータ構造として、①**配列（Array）**：同じ型のデータを連続したメモリ領域に格納、②**リスト（List）**：データを順序付けて格納（線形リスト、連結リスト）、③**スタック（Stack）**：後入れ先出し（LIFO）、④**キュー（Queue）**：先入れ先出し（FIFO）、⑤**木構造（Tree）**：階層的なデータ構造、⑥**ヒープ（Heap）**：優先度付きキュー、⑦**グラフ（Graph）**：ノードと辺で構成、があります。"
        },
        {
          "type": "text",
          "content": "**配列（Array）**とは、同じ型のデータを連続したメモリ領域に格納するデータ構造です。配列の各要素には、添え字（インデックス）でアクセスできます（0から始まる）。配列は、①**1次元配列**：1列のデータ（例: 成績 = [80, 90, 75, 85]）、②**2次元配列**：表形式のデータ（例: 3クラス×5人の成績）、に分類されます。配列の特徴は、①ランダムアクセス：添え字で直接アクセス可能（高速、O(1)）、②固定サイズ：配列のサイズは作成時に決定（後から変更不可）、です。"
        },
        {
          "type": "example",
          "title": "1次元配列の具体例：学生の成績管理",
          "content": "【背景】\n5人の学生の数学の成績を配列で管理します。\n\n【配列の定義】\n```\n成績 = [80, 90, 75, 85, 95]\n```\n\n【配列の操作】\n①要素へのアクセス：\n  成績[0] → 80（1人目の成績）\n  成績[2] → 75（3人目の成績）\n  成績[4] → 95（5人目の成績）\n\n②要素の更新：\n  成績[1] = 92（2人目の成績を90から92に変更）\n\n③全要素の走査（平均点の計算）：\n  合計 = 0\n  for i = 0 to 4\n    合計 = 合計 + 成績[i]\n  end for\n  平均点 = 合計 / 5 → (80+92+75+85+95) / 5 = 85.4\n\n【配列の利点】\n①添え字で直接アクセスできる（高速、O(1)）\n②メモリ領域が連続しているため、キャッシュ効率が良い\n\n【配列の欠点】\n①サイズ変更ができない（要素の追加・削除が困難）\n②挿入・削除時、要素を移動する必要がある（O(n)）"
        },
        {
          "type": "example",
          "title": "2次元配列の具体例：3クラス×5人の成績表",
          "content": "【背景】\n3クラス（A, B, C）各5人の数学の成績を2次元配列で管理します。\n\n【2次元配列の定義】\n```\n成績[3][5] = [\n  [80, 90, 75, 85, 95],  // クラスA（クラス0）\n  [70, 88, 92, 78, 85],  // クラスB（クラス1）\n  [95, 82, 88, 90, 76]   // クラスC（クラス2）\n]\n```\n\n【2次元配列の操作】\n①特定の要素へのアクセス：\n  成績[0][0] → 80（クラスAの1人目）\n  成績[1][2] → 92（クラスBの3人目）\n  成績[2][4] → 76（クラスCの5人目）\n\n②クラスAの平均点を計算：\n  合計 = 0\n  for i = 0 to 4\n    合計 = 合計 + 成績[0][i]\n  end for\n  平均点 = 合計 / 5 → (80+90+75+85+95) / 5 = 85\n\n③全クラスの全生徒の平均点を計算：\n  合計 = 0\n  for i = 0 to 2  // クラスのループ\n    for j = 0 to 4  // 生徒のループ\n      合計 = 合計 + 成績[i][j]\n    end for\n  end for\n  平均点 = 合計 / 15 → 1275 / 15 = 85\n\n【2次元配列のメモリレイアウト】\n2次元配列は、メモリ上では1次元配列として連続配置されます。\n成績[0][0], 成績[0][1], ..., 成績[0][4], 成績[1][0], 成績[1][1], ..., 成績[2][4]"
        },
        {
          "type": "text",
          "content": "**線形リスト（Linear List）**とは、データを線形（一列）に並べて格納するデータ構造です。配列を用いて実装する場合、配列と同じ特徴（ランダムアクセス可能、固定サイズ）を持ちます。一方、**連結リスト（Linked List）**とは、各要素（ノード）がデータと次の要素へのポインタ（参照）を持つデータ構造です。連結リストの特徴は、①可変サイズ：要素の追加・削除が容易、②順次アクセス：先頭から順番にアクセス（ランダムアクセス不可、O(n)）、③メモリ：ポインタ用のメモリが必要、です。"
        },
        {
          "type": "example",
          "title": "連結リストの具体例：学生名簿の管理",
          "content": "【背景】\n学生名簿を連結リストで管理します。各ノードは、学生名と次のノードへのポインタを持ちます。\n\n【連結リストの構造】\n```\n┌─────┬──────┐   ┌─────┬──────┐   ┌─────┬──────┐   ┌─────┬──────┐\n│太郎 │ ───→│ │花子 │ ───→│ │次郎 │ ───→│ │美咲 │ NULL │\n└─────┴──────┘   └─────┴──────┘   └─────┴──────┘   └─────┴──────┘\n先頭（head）        第2ノード         第3ノード         末尾（tail）\n```\n\n【連結リストの操作】\n①要素の追加（先頭に「一郎」を追加）：\n  新しいノード「一郎」を作成\n  一郎.next = 先頭（太郎）\n  先頭 = 一郎\n  結果: 一郎 → 太郎 → 花子 → 次郎 → 美咲\n\n②要素の削除（「花子」を削除）：\n  太郎.next = 花子.next（次郎）\n  結果: 一郎 → 太郎 → 次郎 → 美咲\n\n③要素の検索（「次郎」を検索）：\n  現在 = 先頭（一郎）\n  while 現在 ≠ NULL\n    if 現在.名前 = \"次郎\" then 見つかった\n    現在 = 現在.next\n  end while\n  結果: 一郎 → 太郎 → 次郎（見つかった）\n\n【連結リストの利点】\n①要素の追加・削除が高速（O(1)、ただし挿入位置が既知の場合）\n②可変サイズ（メモリの無駄が少ない）\n\n【連結リストの欠点】\n①ランダムアクセス不可（n番目の要素にアクセスするにはO(n)）\n②ポインタ用のメモリが必要（配列よりメモリ使用量が多い）"
        },
        {
          "type": "table",
          "headers": ["データ構造", "アクセス速度", "挿入・削除速度", "メモリ効率", "適した用途"],
          "rows": [
            ["配列", "O(1)（高速）", "O(n)（遅い）", "良い", "要素数が固定、頻繁にアクセス"],
            ["連結リスト", "O(n)（遅い）", "O(1)（高速）", "やや悪い", "要素数が可変、頻繁に追加・削除"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "配列と連結リストの使い分け",
          "content": "配列と連結リストは、それぞれ長所・短所があります。①ランダムアクセスが多い場合（例: i番目の要素を頻繁に取得）→ 配列を使用、②挿入・削除が多い場合（例: 要素を頻繁に追加・削除）→ 連結リストを使用、のように使い分けます。実際のプログラムでは、JavaのArrayListは配列ベース、LinkedListは連結リストベースで実装されています。"
        }
      ]
    },
    {
      "id": 2,
      "title": "スタック（LIFO）とキュー（FIFO）",
      "sections": [
        {
          "type": "text",
          "content": "**スタック（Stack）**とは、データを後入れ先出し（LIFO: Last In First Out）で管理するデータ構造です。最後に入れたデータが最初に取り出されます。スタックの操作は、①**push（プッシュ）**：データをスタックの先頭（トップ）に追加、②**pop（ポップ）**：スタックの先頭（トップ）からデータを取り出す、の2つです。スタックは、配列または連結リストで実装できます。スタックの応用例として、①関数呼び出しの管理（コールスタック）、②括弧の対応チェック、③逆ポーランド記法の計算、などがあります。"
        },
        {
          "type": "example",
          "title": "スタックの具体例：関数呼び出しの管理（コールスタック）",
          "content": "【背景】\nプログラムで関数を呼び出すとき、関数の呼び出し情報（戻り先のアドレス、ローカル変数）をスタックで管理します。\n\n【プログラム例】\n```python\ndef funcA():\n  print(\"funcA開始\")\n  funcB()\n  print(\"funcA終了\")\n\ndef funcB():\n  print(\"funcB開始\")\n  funcC()\n  print(\"funcB終了\")\n\ndef funcC():\n  print(\"funcC開始\")\n  print(\"funcC終了\")\n\nfuncA()  # メイン関数から呼び出し\n```\n\n【コールスタックの変化】\n①メイン関数がfuncAを呼び出し\n  スタック: [funcA]\n\n②funcAがfuncBを呼び出し\n  スタック: [funcA, funcB]（funcBが先頭）\n\n③funcBがfuncCを呼び出し\n  スタック: [funcA, funcB, funcC]（funcCが先頭）\n\n④funcCが終了 → pop\n  スタック: [funcA, funcB]\n  funcBの「print(\"funcB終了\")」に戻る\n\n⑤funcBが終了 → pop\n  スタック: [funcA]\n  funcAの「print(\"funcA終了\")」に戻る\n\n⑥funcAが終了 → pop\n  スタック: []\n  メイン関数に戻る\n\n【出力結果】\nfuncA開始\nfuncB開始\nfuncC開始\nfuncC終了\nfuncB終了\nfuncA終了\n\n【スタックの役割】\nスタックにより、関数の呼び出し順序と戻り先を管理でき、ネストした関数呼び出しが実現できます。スタックオーバーフロー（Stack Overflow）は、再帰呼び出しが深すぎてスタックが溢れるエラーです。"
        },
        {
          "type": "example",
          "title": "スタックの具体例：括弧の対応チェック",
          "content": "【背景】\nプログラムのソースコード「((a + b) * (c - d))」の括弧が正しく対応しているかをスタックでチェックします。\n\n【アルゴリズム】\n①文字列を先頭から1文字ずつ読む\n②「(」を読んだら、スタックにpush\n③「)」を読んだら、スタックからpop\n  - スタックが空の場合 → エラー（対応する「(」がない）\n④最後にスタックが空なら正常、空でなければエラー（「(」が余っている）\n\n【処理の流れ】\n入力: ((a + b) * (c - d))\n\n①「(」を読む → push\n  スタック: [1個目の(]\n\n②「(」を読む → push\n  スタック: [1個目の(, 2個目の(]\n\n③「)」を読む（a + bの後）→ pop\n  スタック: [1個目の(]\n\n④「(」を読む → push\n  スタック: [1個目の(, 3個目の(]\n\n⑤「)」を読む（c - dの後）→ pop\n  スタック: [1個目の(]\n\n⑥「)」を読む（最後）→ pop\n  スタック: []\n\n⑦文字列の終わりに到達、スタックが空 → 正常（括弧が正しく対応）\n\n【エラー例】\n入力: ((a + b) * (c - d)\n最後にスタック: [1個目の(]\n→ エラー（「(」が1個余っている）\n\n入力: (a + b)) * (c - d)\n「)」を読んだ時にスタックが空 → エラー（対応する「(」がない）"
        },
        {
          "type": "text",
          "content": "**キュー（Queue）**とは、データを先入れ先出し（FIFO: First In First Out）で管理するデータ構造です。最初に入れたデータが最初に取り出されます。キューの操作は、①**enqueue（エンキュー）**：データをキューの末尾（リア）に追加、②**dequeue（デキュー）**：キューの先頭（フロント）からデータを取り出す、の2つです。キューは、配列または連結リストで実装できます。キューの応用例として、①印刷ジョブの管理（プリンタキュー）、②タスクスケジューリング（プロセス管理）、③幅優先探索（BFS）、などがあります。"
        },
        {
          "type": "example",
          "title": "キューの具体例：印刷ジョブの管理（プリンタキュー）",
          "content": "【背景】\nオフィスで複数のユーザーがプリンタに印刷ジョブを送信します。プリンタは、先に送られたジョブから順番に印刷します（FIFO）。\n\n【キューの状態変化】\n①初期状態（キューは空）\n  キュー: []\n\n②ユーザーAが「レポート.pdf」を印刷依頼 → enqueue\n  キュー: [レポート.pdf]\n  先頭（フロント）→ レポート.pdf ← 末尾（リア）\n\n③ユーザーBが「資料.docx」を印刷依頼 → enqueue\n  キュー: [レポート.pdf, 資料.docx]\n  先頭（フロント）→ レポート.pdf, 資料.docx ← 末尾（リア）\n\n④ユーザーCが「グラフ.xlsx」を印刷依頼 → enqueue\n  キュー: [レポート.pdf, 資料.docx, グラフ.xlsx]\n\n⑤プリンタが「レポート.pdf」の印刷を開始 → dequeue\n  キュー: [資料.docx, グラフ.xlsx]\n\n⑥プリンタが「資料.docx」の印刷を開始 → dequeue\n  キュー: [グラフ.xlsx]\n\n⑦プリンタが「グラフ.xlsx」の印刷を開始 → dequeue\n  キュー: []\n\n【キューの役割】\nキューにより、印刷ジョブを公平に処理でき、先に依頼したユーザーから順番に印刷できます（FIFO）。スタック（LIFO）だと、最後に依頼したユーザーが先に印刷されてしまいます。"
        },
        {
          "type": "table",
          "headers": ["データ構造", "取り出し順序", "操作", "応用例"],
          "rows": [
            ["スタック", "LIFO（後入れ先出し）", "push, pop", "関数呼び出し、括弧チェック、逆ポーランド記法"],
            ["キュー", "FIFO（先入れ先出し）", "enqueue, dequeue", "印刷ジョブ管理、タスクスケジューリング、BFS"]
          ]
        },
        {
          "type": "highlight",
          "icon": "🔧",
          "title": "スタックとキューの実装",
          "content": "スタックとキューは、配列または連結リストで実装できます。①配列で実装：メモリ効率が良いが、固定サイズ、②連結リストで実装：可変サイズだが、ポインタ用のメモリが必要。配列で実装する場合、キューでは環状配列（Circular Queue）を使用することで、メモリを効率的に利用できます。環状配列では、キューの末尾が配列の末尾に達したら、配列の先頭に戻ります（先頭と末尾がループする）。"
        }
      ]
    },
    {
      "id": 3,
      "title": "木構造の基礎（2分木、2分探索木）",
      "sections": [
        {
          "type": "text",
          "content": "**木構造（Tree）**とは、ノード（節点）と辺（枝）で構成される階層的なデータ構造です。木構造の用語として、①**根（Root）**：最上位のノード、②**葉（Leaf）**：子を持たないノード、③**親（Parent）**：あるノードの1つ上のノード、④**子（Child）**：あるノードの1つ下のノード、⑤**兄弟（Sibling）**：同じ親を持つノード、⑥**深さ（Depth）**：根からあるノードまでの辺の数、⑦**高さ（Height）**：根から葉までの最大の辺の数、があります。"
        },
        {
          "type": "text",
          "content": "**2分木（Binary Tree）**とは、各ノードが最大2つの子（左の子、右の子）を持つ木構造です。2分木の種類として、①**完全2分木（Complete Binary Tree）**：全てのレベルが埋まっており、最下層のノードは左から詰まっている、②**満2分木（Full Binary Tree）**：全ての内部ノードが2つの子を持つ、③**2分探索木（Binary Search Tree）**：左の子 < 親 < 右の子の関係を満たす（後述）、があります。2分木は、配列またはポインタを使ったノード構造で実装できます。"
        },
        {
          "type": "example",
          "title": "2分木の具体例：組織図",
          "content": "【背景】\n会社の組織図を2分木で表現します（各部門が最大2つの下位部門を持つ）。\n\n【2分木の構造】\n```\n           社長\n          /    \\\n        営業部   技術部\n        /  \\      /  \\\n      東京 大阪  開発  保守\n```\n\n【用語の説明】\n①根（Root）: 社長\n②葉（Leaf）: 東京、大阪、開発、保守（子を持たない）\n③親と子:\n  - 社長の子: 営業部、技術部\n  - 営業部の子: 東京、大阪\n  - 営業部の親: 社長\n④兄弟（Sibling）: 営業部と技術部、東京と大阪、開発と保守\n⑤深さ（Depth）:\n  - 社長: 0\n  - 営業部、技術部: 1\n  - 東京、大阪、開発、保守: 2\n⑥高さ（Height）: 2（根から葉までの最大の辺の数）\n\n【2分木の走査（探索）】\n2分木を走査する方法として、①前順（Pre-order）: 根 → 左 → 右、②中順（In-order）: 左 → 根 → 右、③後順（Post-order）: 左 → 右 → 根、の3種類があります。\n\n【前順走査の例】\n社長 → 営業部 → 東京 → 大阪 → 技術部 → 開発 → 保守\n\n【中順走査の例】\n東京 → 営業部 → 大阪 → 社長 → 開発 → 技術部 → 保守\n\n【後順走査の例】\n東京 → 大阪 → 営業部 → 開発 → 保守 → 技術部 → 社長"
        },
        {
          "type": "text",
          "content": "**2分探索木（Binary Search Tree, BST）**とは、以下の性質を満たす2分木です。①各ノードの左の子孫は、そのノードより小さい値、②各ノードの右の子孫は、そのノードより大きい値。2分探索木では、データの検索、挿入、削除を効率的に実行できます（平均計算量O(log n)、最悪O(n)）。2分探索木を中順走査すると、データが昇順（小さい順）に取得できます。"
        },
        {
          "type": "example",
          "title": "2分探索木の具体例：数値の管理",
          "content": "【背景】\n数値 [50, 30, 70, 20, 40, 60, 80] を2分探索木に挿入します。\n\n【2分探索木の構築】\n①50を根に挿入\n```\n  50\n```\n\n②30を挿入（30 < 50 なので左に挿入）\n```\n    50\n   /\n  30\n```\n\n③70を挿入（70 > 50 なので右に挿入）\n```\n    50\n   /  \\\n  30   70\n```\n\n④20を挿入（20 < 50, 20 < 30 なので30の左に挿入）\n```\n      50\n     /  \\\n    30   70\n   /\n  20\n```\n\n⑤40を挿入（40 < 50, 40 > 30 なので30の右に挿入）\n```\n      50\n     /  \\\n    30   70\n   /  \\\n  20  40\n```\n\n⑥60を挿入（60 > 50, 60 < 70 なので70の左に挿入）\n```\n      50\n     /  \\\n    30   70\n   /  \\  /\n  20  40 60\n```\n\n⑦80を挿入（80 > 50, 80 > 70 なので70の右に挿入）\n```\n      50\n     /  \\\n    30   70\n   /  \\  /  \\\n  20  40 60 80\n```\n\n【データの検索（例: 40を検索）】\n①50と比較 → 40 < 50 なので左へ\n②30と比較 → 40 > 30 なので右へ\n③40と比較 → 40 = 40 なので見つかった\n検索回数: 3回（高さが3）\n\n【データの検索（例: 45を検索）】\n①50と比較 → 45 < 50 なので左へ\n②30と比較 → 45 > 30 なので右へ\n③40と比較 → 45 > 40 なので右へ\n④右の子がない → 見つからない\n\n【中順走査（昇順に取得）】\n左 → 根 → 右の順で走査すると、\n20 → 30 → 40 → 50 → 60 → 70 → 80（昇順）\n\n【2分探索木の利点】\n①検索が高速（平均O(log n)）\n②挿入・削除も高速（平均O(log n)）\n③中順走査で昇順にデータを取得できる\n\n【2分探索木の欠点】\n①データが昇順で挿入されると、木が一直線になり、計算量がO(n)に悪化\n例: [10, 20, 30, 40, 50] を挿入すると、\n```\n10\n  \\\n  20\n    \\\n    30\n      \\\n      40\n        \\\n        50\n```\nこれを防ぐため、AVL木、赤黒木などの平衡2分探索木が使用されます。"
        },
        {
          "type": "table",
          "headers": ["操作", "平均計算量", "最悪計算量", "備考"],
          "rows": [
            ["検索", "O(log n)", "O(n)", "平衡木ならO(log n)"],
            ["挿入", "O(log n)", "O(n)", "平衡木ならO(log n)"],
            ["削除", "O(log n)", "O(n)", "平衡木ならO(log n)"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "2分探索木の応用",
          "content": "2分探索木は、データベースのインデックス、辞書（キーと値のペア）、ファイルシステムのディレクトリ構造など、様々な場面で使用されています。例えば、データベースでは、B木（B-tree）という多分木（各ノードが複数の子を持つ）を使用してインデックスを構築し、高速な検索を実現しています。"
        }
      ]
    },
    {
      "id": 4,
      "title": "ヒープとハッシュテーブル",
      "sections": [
        {
          "type": "text",
          "content": "**ヒープ（Heap）**とは、以下の性質を満たす完全2分木です。①**最大ヒープ（Max Heap）**：親ノードの値 ≥ 子ノードの値（根が最大値）、②**最小ヒープ（Min Heap）**：親ノードの値 ≤ 子ノードの値（根が最小値）。ヒープは、優先度付きキュー（Priority Queue）の実装に使用されます。優先度付きキューとは、優先度が高いデータを先に取り出すデータ構造です。ヒープの操作は、①挿入：O(log n)、②最大値（最小値）の取り出し：O(log n)、です。"
        },
        {
          "type": "example",
          "title": "最大ヒープの具体例：タスクの優先度管理",
          "content": "【背景】\nタスク管理システムで、優先度が高いタスクを先に処理します。タスクの優先度を最大ヒープで管理します。\n\n【最大ヒープの構築】\n優先度 [50, 30, 70, 20, 40, 60, 80] のタスクを最大ヒープに挿入します。\n\n【最大ヒープの構造】\n```\n      80\n     /  \\\n    40   70\n   /  \\  /  \\\n  20  30 60 50\n```\n\n【最大ヒープの性質】\n①根が最大値（80）\n②親ノード ≥ 子ノード\n  - 80 ≥ 40, 80 ≥ 70\n  - 40 ≥ 20, 40 ≥ 30\n  - 70 ≥ 60, 70 ≥ 50\n\n【操作: 最大値の取り出し（最優先タスクを処理）】\n①根（80）を取り出す\n②最後の要素（50）を根に移動\n③ヒープの性質を回復（ヒープ化）\n  - 50と子（40, 70）を比較 → 70が大きい → 50と70を入れ替え\n  - 50と子（60, 50）を比較 → 60が大きい → 50と60を入れ替え\n\n【取り出し後のヒープ】\n```\n      70\n     /  \\\n    40   60\n   /  \\  /\n  20  30 50\n```\n\n【操作: 新しいタスクの挿入（優先度90）】\n①最後に90を追加\n②親と比較して、親より大きければ入れ替え（ヒープ化）\n  - 90と70を比較 → 90が大きい → 入れ替え\n\n【挿入後のヒープ】\n```\n      90\n     /  \\\n    40   70\n   /  \\  /  \\\n  20  30 50 60\n```\n\n【ヒープの応用】\n①優先度付きキュー（タスクスケジューリング、ネットワークパケットの優先制御）\n②ヒープソート（整列アルゴリズム、O(n log n)）\n③ダイクストラ法（最短経路探索アルゴリズム）"
        },
        {
          "type": "text",
          "content": "**ハッシュテーブル（Hash Table）**とは、キー（Key）と値（Value）のペアを格納するデータ構造です。ハッシュテーブルは、ハッシュ関数を使用してキーをインデックス（ハッシュ値）に変換し、配列に格納します。ハッシュテーブルの特徴は、①検索・挿入・削除が平均O(1)で高速、②キーから値を直接取得できる（連想配列、辞書）、です。ハッシュテーブルの問題点として、**衝突（Collision）**があります。衝突とは、異なるキーが同じハッシュ値になることです。衝突の解決方法として、①チェイン法（Chaining）：同じハッシュ値のデータを連結リストで管理、②オープンアドレス法（Open Addressing）：別の空きスロットを探す、があります。"
        },
        {
          "type": "example",
          "title": "ハッシュテーブルの具体例：学生IDから名前を検索",
          "content": "【背景】\n学生ID（キー）から学生名（値）を高速に検索するために、ハッシュテーブルを使用します。\n\n【ハッシュ関数】\nハッシュ値 = 学生ID % 10（学生IDを10で割った余り）\n\n【データの挿入】\n①学生ID 1001, 名前「太郎」\n  ハッシュ値 = 1001 % 10 = 1\n  配列[1] = 太郎\n\n②学生ID 1012, 名前「花子」\n  ハッシュ値 = 1012 % 10 = 2\n  配列[2] = 花子\n\n③学生ID 1023, 名前「次郎」\n  ハッシュ値 = 1023 % 10 = 3\n  配列[3] = 次郎\n\n④学生ID 1031, 名前「美咲」\n  ハッシュ値 = 1031 % 10 = 1（衝突！）\n  配列[1]には既に「太郎」がいる\n\n【衝突の解決（チェイン法）】\n配列[1]に連結リストを作成し、「太郎」と「美咲」を格納\n```\n配列[0]: NULL\n配列[1]: 太郎 → 美咲\n配列[2]: 花子\n配列[3]: 次郎\n配列[4]: NULL\n...\n```\n\n【データの検索（例: 学生ID 1031を検索）】\n①ハッシュ値を計算 → 1031 % 10 = 1\n②配列[1]の連結リストを走査\n  - 「太郎」の学生ID（1001） → 一致しない\n  - 「美咲」の学生ID（1031） → 一致！\n結果: 「美咲」が見つかった\n\n【ハッシュテーブルの利点】\n①検索が高速（平均O(1)）\n②挿入・削除も高速（平均O(1)）\n\n【ハッシュテーブルの欠点】\n①衝突が多いと、連結リストが長くなり、検索速度が低下（最悪O(n)）\n②データが順序を持たない（ソートされていない）\n③ハッシュ関数の設計が重要（衝突を減らすため）\n\n【良いハッシュ関数の条件】\n①計算が高速\n②衝突が少ない（ハッシュ値が均等に分散）\n③決定的（同じキーなら常に同じハッシュ値）"
        },
        {
          "type": "table",
          "headers": ["データ構造", "検索", "挿入", "削除", "順序", "適した用途"],
          "rows": [
            ["配列", "O(n)", "O(n)", "O(n)", "あり", "要素数が少ない、順序が必要"],
            ["2分探索木", "O(log n)", "O(log n)", "O(log n)", "あり", "順序が必要、動的に変化"],
            ["ハッシュテーブル", "O(1)", "O(1)", "O(1)", "なし", "順序不要、高速検索が必要"]
          ]
        },
        {
          "type": "highlight",
          "icon": "🔧",
          "title": "ハッシュテーブルの応用",
          "content": "ハッシュテーブルは、プログラミング言語の辞書（Dictionary）、連想配列（Associative Array）、データベースのインデックス、キャッシュ（高速化）など、様々な場面で使用されています。例えば、PythonのDict、JavaのHashMap、JavaScriptのObjectは、全てハッシュテーブルで実装されています。また、データベースのSQLでは、JOINやGROUP BYの内部処理でハッシュテーブルが使用されることがあります（ハッシュジョイン）。"
        }
      ]
    },
    {
      "id": 5,
      "title": "グラフとデータ構造の選択",
      "sections": [
        {
          "type": "text",
          "content": "**グラフ（Graph）**とは、ノード（頂点、Vertex）と辺（Edge）で構成されるデータ構造です。グラフは、ネットワーク、地図、SNSの友人関係など、複雑な関係性を表現できます。グラフの種類として、①**無向グラフ（Undirected Graph）**：辺に方向がない（例: 道路）、②**有向グラフ（Directed Graph）**：辺に方向がある（例: 一方通行）、③**重み付きグラフ（Weighted Graph）**：辺に重み（コスト、距離）がある、があります。グラフの表現方法として、①**隣接行列（Adjacency Matrix）**：2次元配列でノード間の接続を表現、②**隣接リスト（Adjacency List）**：各ノードに接続されたノードをリストで表現、があります。"
        },
        {
          "type": "example",
          "title": "グラフの具体例：都市間の道路ネットワーク",
          "content": "【背景】\n5つの都市（A, B, C, D, E）を結ぶ道路ネットワークを重み付き無向グラフで表現します。辺の重みは道路の距離（km）です。\n\n【グラフの構造】\n```\nノード: A, B, C, D, E\n辺（無向）:\n  A - B (10km)\n  A - C (5km)\n  B - D (15km)\n  C - D (20km)\n  C - E (12km)\n  D - E (8km)\n```\n\n【隣接行列による表現】\n```\n   A  B  C  D  E\nA [0, 10, 5, ∞, ∞]\nB [10, 0, ∞, 15, ∞]\nC [5, ∞, 0, 20, 12]\nD [∞, 15, 20, 0, 8]\nE [∞, ∞, 12, 8, 0]\n```\n（∞は接続がないことを示す）\n\n【隣接リストによる表現】\n```\nA: [(B, 10), (C, 5)]\nB: [(A, 10), (D, 15)]\nC: [(A, 5), (D, 20), (E, 12)]\nD: [(B, 15), (C, 20), (E, 8)]\nE: [(C, 12), (D, 8)]\n```\n\n【グラフの探索】\nグラフの探索アルゴリズムとして、①**幅優先探索（BFS: Breadth-First Search）**：キューを使用、近い順に探索、②**深さ優先探索（DFS: Depth-First Search）**：スタックを使用、深い方向に探索、があります。\n\n【幅優先探索（BFS）の例: AからEへの探索】\n①Aを訪問、キューに追加\n  キュー: [A]\n  訪問済み: {A}\n\n②Aの隣接ノード（B, C）をキューに追加\n  キュー: [B, C]\n  訪問済み: {A, B, C}\n\n③Bを訪問、Bの未訪問の隣接ノード（D）をキューに追加\n  キュー: [C, D]\n  訪問済み: {A, B, C, D}\n\n④Cを訪問、Cの未訪問の隣接ノード（E）をキューに追加\n  キュー: [D, E]\n  訪問済み: {A, B, C, D, E}\n\n⑤Eが見つかった！\n\n【グラフの応用】\n①経路探索（カーナビ、Googleマップ）\n②SNSの友人関係（フォロワー、つながり）\n③ネットワークの最適化（最小全域木）\n④Webページのリンク構造（PageRank）"
        },
        {
          "type": "table",
          "headers": ["表現方法", "メモリ使用量", "辺の存在確認", "全隣接ノードの取得", "適した用途"],
          "rows": [
            ["隣接行列", "O(V²)", "O(1)", "O(V)", "密なグラフ（辺が多い）"],
            ["隣接リスト", "O(V+E)", "O(V)", "O(次数)", "疎なグラフ（辺が少ない）"]
          ]
        },
        {
          "type": "text",
          "content": "**データ構造の選択基準**：プログラムの要件に応じて、適切なデータ構造を選択することが重要です。選択基準として、①**操作の頻度**：検索、挿入、削除のどれが多いか、②**データの性質**：順序が必要か、重複があるか、③**メモリ制約**：メモリ使用量を最小化したいか、④**計算量**：時間計算量を最小化したいか、があります。"
        },
        {
          "type": "example",
          "title": "データ構造の選択例",
          "content": "【例1: 学生の成績を管理（検索が多い）】\n要件: 学生ID（キー）から成績（値）を高速に検索したい\n選択: ハッシュテーブル（検索O(1)）\n\n【例2: タスクを優先度順に処理】\n要件: 優先度が高いタスクを先に取り出したい\n選択: ヒープ（優先度付きキュー、取り出しO(log n)）\n\n【例3: 商品を価格順に表示】\n要件: 商品を価格順に並べて表示したい\n選択: 2分探索木（中順走査で昇順取得、挿入・検索O(log n)）\n\n【例4: 印刷ジョブを順番に処理】\n要件: 先に送られたジョブから順番に処理したい\n選択: キュー（FIFO、enqueue/dequeue O(1)）\n\n【例5: 関数呼び出しの管理】\n要件: 関数の呼び出し順序と戻り先を管理したい\n選択: スタック（LIFO、push/pop O(1)）\n\n【例6: 都市間の最短経路を探索】\n要件: 出発地から目的地までの最短経路を見つけたい\n選択: グラフ（ダイクストラ法、A*探索）\n\n【例7: 小規模なデータで順序が必要】\n要件: 10個程度のデータを順序付けて管理したい\n選択: 配列（シンプル、メモリ効率が良い）"
        },
        {
          "type": "table",
          "headers": ["用途", "推奨データ構造", "理由"],
          "rows": [
            ["辞書（キー→値）", "ハッシュテーブル", "検索O(1)"],
            ["優先度付きキュー", "ヒープ", "取り出しO(log n)"],
            ["順序付きデータ", "2分探索木", "中順走査で昇順"],
            ["FIFO処理", "キュー", "先入れ先出し"],
            ["LIFO処理", "スタック", "後入れ先出し"],
            ["ネットワーク", "グラフ", "複雑な関係性"],
            ["小規模・固定サイズ", "配列", "シンプル、高速"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "データ構造の学習のポイント",
          "content": "データ構造は、プログラミングの基礎です。各データ構造の①構造（どのようにデータを格納するか）、②操作（挿入、削除、検索）、③計算量（時間計算量、空間計算量）、④応用例（どのような場面で使用されるか）、を理解することが重要です。基本情報技術者試験では、配列、スタック、キュー、2分探索木、ヒープ、ハッシュテーブルが頻出です。特に、スタック（関数呼び出し）、キュー（印刷ジョブ）、2分探索木（検索）、ヒープ（優先度付きキュー）の応用例を押さえておきましょう。"
        }
      ]
    }
  ]
}
