{
  "topicId": "tech-4-3-6",
  "title": "その他のアルゴリズム",
  "pages": [
    {
      "id": 1,
      "title": "再帰アルゴリズムの基礎と階乗計算",
      "sections": [
        {
          "type": "text",
          "content": "**再帰アルゴリズム（Recursion）**とは、関数が自分自身を呼び出すことで問題を解決する手法です。再帰アルゴリズムは、①**基底ケース（Base Case）**：再帰を終了する条件（最も単純な問題）、②**再帰ケース（Recursive Case）**：問題を小さな問題に分割し、自分自身を呼び出す、の2つで構成されます。再帰アルゴリズムは、問題を自然に小さな部分問題に分割できる場合に有効です。"
        },
        {
          "type": "example",
          "title": "階乗の再帰的計算：factorial(5)の詳細な実行過程",
          "content": "【階乗の定義】\nn! = n × (n-1) × (n-2) × ... × 2 × 1\n例: 5! = 5 × 4 × 3 × 2 × 1 = 120\n\n【再帰による階乗の定義】\nfactorial(n) = {\n  1,                          (n = 0 または n = 1) ← 基底ケース\n  n × factorial(n - 1),       (n > 1)              ← 再帰ケース\n}\n\n【プログラムコード（疑似コード）】\n```python\ndef factorial(n):\n    # 基底ケース: n が 0 または 1 のとき、1 を返す\n    if n == 0 or n == 1:\n        return 1\n    # 再帰ケース: n × factorial(n-1) を返す\n    else:\n        return n * factorial(n - 1)\n```\n\n【factorial(5)の実行過程（呼び出しスタック）】\n\n①factorial(5) を呼び出し\n  → 5 × factorial(4) を計算する必要がある\n  → factorial(4) を呼び出し（スタックに積む）\n\n②factorial(4) を呼び出し\n  → 4 × factorial(3) を計算する必要がある\n  → factorial(3) を呼び出し（スタックに積む）\n\n③factorial(3) を呼び出し\n  → 3 × factorial(2) を計算する必要がある\n  → factorial(2) を呼び出し（スタックに積む）\n\n④factorial(2) を呼び出し\n  → 2 × factorial(1) を計算する必要がある\n  → factorial(1) を呼び出し（スタックに積む）\n\n⑤factorial(1) を呼び出し\n  → n = 1 なので、基底ケースに到達\n  → 1 を返す（スタックから取り出す）\n\n【戻り値の計算（スタックから順に取り出す）】\n\n⑥factorial(2) に戻る\n  → 2 × 1 = 2 を返す\n\n⑦factorial(3) に戻る\n  → 3 × 2 = 6 を返す\n\n⑧factorial(4) に戻る\n  → 4 × 6 = 24 を返す\n\n⑨factorial(5) に戻る\n  → 5 × 24 = 120 を返す\n\n【最終結果】\nfactorial(5) = 120\n\n【呼び出しスタックの状態】\n```\n開始: factorial(5)\n  ↓\nfactorial(5) → 5 × factorial(4)\n  factorial(4) → 4 × factorial(3)\n    factorial(3) → 3 × factorial(2)\n      factorial(2) → 2 × factorial(1)\n        factorial(1) → 1 (基底ケース)\n      factorial(2) = 2 × 1 = 2\n    factorial(3) = 3 × 2 = 6\n  factorial(4) = 4 × 6 = 24\nfactorial(5) = 5 × 24 = 120\n```"
        },
        {
          "type": "table",
          "headers": ["ステップ", "関数呼び出し", "スタックの状態", "計算結果"],
          "rows": [
            ["①", "factorial(5)", "[5]", "待機中"],
            ["②", "factorial(4)", "[5, 4]", "待機中"],
            ["③", "factorial(3)", "[5, 4, 3]", "待機中"],
            ["④", "factorial(2)", "[5, 4, 3, 2]", "待機中"],
            ["⑤", "factorial(1)", "[5, 4, 3, 2, 1]", "1を返す"],
            ["⑥", "factorial(2)に戻る", "[5, 4, 3, 2]", "2×1=2を返す"],
            ["⑦", "factorial(3)に戻る", "[5, 4, 3]", "3×2=6を返す"],
            ["⑧", "factorial(4)に戻る", "[5, 4]", "4×6=24を返す"],
            ["⑨", "factorial(5)に戻る", "[5]", "5×24=120を返す"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "再帰の利点と欠点",
          "content": "【利点】\n①コードが簡潔で読みやすい（階乗の定義をそのままコードに書ける）\n②問題を自然に小さな部分問題に分割できる\n③木構造やグラフ探索など、再帰的な構造を持つ問題に適している\n\n【欠点】\n①関数呼び出しのオーバーヘッド（スタックのメモリ消費）\n②深い再帰（n が大きい場合）は、スタックオーバーフローを引き起こす可能性がある\n③同じ計算を繰り返す場合がある（例: フィボナッチ数列）→ 動的計画法で改善"
        }
      ]
    },
    {
      "id": 2,
      "title": "分割統治法（マージソート、クイックソート）",
      "sections": [
        {
          "type": "text",
          "content": "**分割統治法（Divide and Conquer）**とは、問題を複数の小さな部分問題に分割し、それぞれを解決し、最後に結果を統合する手法です。分割統治法は、①**分割（Divide）**：問題を小さな部分問題に分割、②**統治（Conquer）**：部分問題を再帰的に解決、③**統合（Combine）**：部分問題の解を統合して元の問題の解を得る、の3ステップで構成されます。代表的なアルゴリズムとして、マージソート、クイックソート、2分探索があります。"
        },
        {
          "type": "example",
          "title": "マージソートの詳細な動作例：[38, 27, 43, 3, 9, 82, 10]",
          "content": "【マージソートのアルゴリズム】\n①配列を2つに分割する（分割）\n②各部分配列を再帰的にソートする（統治）\n③ソート済みの2つの配列をマージ（統合）する\n\n【具体例：[38, 27, 43, 3, 9, 82, 10] をソート】\n\n【分割フェーズ（配列を2つに分割）】\n```\n                [38, 27, 43, 3, 9, 82, 10]\n                       ↓ 分割\n         [38, 27, 43, 3]          [9, 82, 10]\n              ↓ 分割                   ↓ 分割\n      [38, 27]    [43, 3]        [9, 82]    [10]\n       ↓ 分割      ↓ 分割         ↓ 分割     ↓(1要素)\n   [38]  [27]  [43]  [3]      [9]  [82]   [10]\n   (1要素) (1要素) (1要素) (1要素)  (1要素) (1要素)  (1要素)\n```\n\n【マージフェーズ（ソート済み配列を統合）】\n\nステップ①：[38] と [27] をマージ\n  → 27 < 38 なので、[27, 38]\n\nステップ②：[43] と [3] をマージ\n  → 3 < 43 なので、[3, 43]\n\nステップ③：[27, 38] と [3, 43] をマージ\n  左: [27, 38]（i=0）、右: [3, 43]（j=0）\n  ①3 < 27 → 3 を結果に追加、j++ → [3]\n  ②27 < 43 → 27 を結果に追加、i++ → [3, 27]\n  ③38 < 43 → 38 を結果に追加、i++ → [3, 27, 38]\n  ④右の残り（43）を追加 → [3, 27, 38, 43]\n\nステップ④：[9] と [82] をマージ\n  → 9 < 82 なので、[9, 82]\n\nステップ⑤：[9, 82] と [10] をマージ\n  左: [9, 82]（i=0）、右: [10]（j=0）\n  ①9 < 10 → 9 を結果に追加、i++ → [9]\n  ②82 > 10 → 10 を結果に追加、j++ → [9, 10]\n  ③左の残り（82）を追加 → [9, 10, 82]\n\nステップ⑥：[3, 27, 38, 43] と [9, 10, 82] をマージ\n  左: [3, 27, 38, 43]（i=0）、右: [9, 10, 82]（j=0）\n  ①3 < 9 → 3 を結果に追加、i++ → [3]\n  ②27 > 9 → 9 を結果に追加、j++ → [3, 9]\n  ③27 > 10 → 10 を結果に追加、j++ → [3, 9, 10]\n  ④27 < 82 → 27 を結果に追加、i++ → [3, 9, 10, 27]\n  ⑤38 < 82 → 38 を結果に追加、i++ → [3, 9, 10, 27, 38]\n  ⑥43 < 82 → 43 を結果に追加、i++ → [3, 9, 10, 27, 38, 43]\n  ⑦右の残り（82）を追加 → [3, 9, 10, 27, 38, 43, 82]\n\n【最終結果】\n[3, 9, 10, 27, 38, 43, 82]（昇順にソート完了）\n\n【時間計算量】\nO(n log n)（最悪の場合でも O(n log n)、安定ソート）"
        },
        {
          "type": "example",
          "title": "クイックソートの詳細な動作例：[38, 27, 43, 3, 9, 82, 10]",
          "content": "【クイックソートのアルゴリズム】\n①配列からピボット（基準値）を選ぶ（例: 最初の要素）\n②ピボットより小さい要素を左、大きい要素を右に分割（分割）\n③左右の部分配列を再帰的にソート（統治）\n\n【具体例：[38, 27, 43, 3, 9, 82, 10] をソート】\n\n【第1回目の分割（ピボット=38）】\n配列: [38, 27, 43, 3, 9, 82, 10]\nピボット: 38（最初の要素）\n\n分割処理:\n  ①27 < 38 → 左グループ\n  ②43 > 38 → 右グループ\n  ③3 < 38 → 左グループ\n  ④9 < 38 → 左グループ\n  ⑤82 > 38 → 右グループ\n  ⑥10 < 38 → 左グループ\n\n分割結果:\n  左: [27, 3, 9, 10]（38より小さい）\n  ピボット: [38]\n  右: [43, 82]（38より大きい）\n\n【左部分配列のソート: [27, 3, 9, 10]（ピボット=27）】\n  ①3 < 27 → 左グループ\n  ②9 < 27 → 左グループ\n  ③10 < 27 → 左グループ\n\n分割結果:\n  左: [3, 9, 10]\n  ピボット: [27]\n  右: []\n\n【左部分配列のソート: [3, 9, 10]（ピボット=3）】\n  ①9 > 3 → 右グループ\n  ②10 > 3 → 右グループ\n\n分割結果:\n  左: []\n  ピボット: [3]\n  右: [9, 10]\n\n【右部分配列のソート: [9, 10]（ピボット=9）】\n  ①10 > 9 → 右グループ\n\n分割結果:\n  左: []\n  ピボット: [9]\n  右: [10]\n\n統合: [9, 10]\n\n統合: [3, 9, 10]\n\n統合: [3, 9, 10, 27]\n\n【右部分配列のソート: [43, 82]（ピボット=43）】\n  ①82 > 43 → 右グループ\n\n分割結果:\n  左: []\n  ピボット: [43]\n  右: [82]\n\n統合: [43, 82]\n\n【最終統合】\n[3, 9, 10, 27] + [38] + [43, 82] = [3, 9, 10, 27, 38, 43, 82]\n\n【時間計算量】\n平均: O(n log n)\n最悪: O(n²)（配列がすでにソート済みの場合）"
        },
        {
          "type": "table",
          "headers": ["アルゴリズム", "平均計算量", "最悪計算量", "安定性", "特徴"],
          "rows": [
            ["マージソート", "O(n log n)", "O(n log n)", "安定", "常に O(n log n)、追加メモリが必要"],
            ["クイックソート", "O(n log n)", "O(n²)", "不安定", "平均的に高速、追加メモリ不要"]
          ]
        },
        {
          "type": "highlight",
          "icon": "🔧",
          "title": "分割統治法の特徴",
          "content": "分割統治法は、問題を小さな部分問題に分割し、それぞれを独立に解決できるため、①並列処理に適している（部分問題を同時に処理）、②再帰的な構造を持つため、コードが簡潔、③多くの効率的なアルゴリズム（マージソート、クイックソート、2分探索、FFT）に応用されています。ただし、再帰呼び出しのオーバーヘッドや、追加メモリ（マージソートの場合）が必要になる場合があります。"
        }
      ]
    },
    {
      "id": 3,
      "title": "動的計画法（ナップサック問題）",
      "sections": [
        {
          "type": "text",
          "content": "**動的計画法（Dynamic Programming, DP）**とは、大きな問題を小さな部分問題に分割し、部分問題の解を記録（メモ化）して、同じ計算を繰り返さないようにする手法です。動的計画法は、①**重複部分問題（Overlapping Subproblems）**：同じ部分問題が何度も出現する、②**最適部分構造（Optimal Substructure）**：問題の最適解が部分問題の最適解から構成される、の2つの性質を持つ問題に適用できます。代表的な例として、フィボナッチ数列、ナップサック問題、最長共通部分列（LCS）があります。"
        },
        {
          "type": "example",
          "title": "0-1ナップサック問題の詳細な解法",
          "content": "【問題】\n容量 W = 10kg のナップサック（リュックサック）に、価値を最大化するように品物を詰める。\n各品物は1つだけ（分割不可）で、以下の重さと価値を持つ:\n\n品物1: 重さ 2kg、価値 3\n品物2: 重さ 3kg、価値 4\n品物3: 重さ 4kg、価値 5\n品物4: 重さ 5kg、価値 6\n\nナップサックに詰める品物の組み合わせを決定し、価値の合計を最大化せよ。\n\n【動的計画法による解法】\n\nDP テーブル dp[i][w] を作成:\n  dp[i][w] = 品物 1～i を使って、容量 w のナップサックに詰めたときの最大価値\n\n【漸化式】\ndp[i][w] = max(\n  dp[i-1][w],                    // 品物 i を詰めない場合\n  dp[i-1][w - weight[i]] + value[i]  // 品物 i を詰める場合（容量が足りる場合のみ）\n)\n\n【DPテーブルの構築（品物1～4、容量0～10kg）】\n\n初期化: dp[0][w] = 0（品物0個の場合、価値は0）\n\n品物1（重さ2kg、価値3）:\n  容量 0～1kg: 品物1を詰められない → dp[1][0] = 0, dp[1][1] = 0\n  容量 2～10kg: 品物1を詰める → dp[1][2] = 3, dp[1][3] = 3, ..., dp[1][10] = 3\n\n品物2（重さ3kg、価値4）:\n  容量 0～2kg: 品物2を詰められない → dp[2][0] = 0, dp[2][1] = 0, dp[2][2] = 3\n  容量 3kg: max(dp[1][3]=3, dp[1][0]+4=4) = 4 → dp[2][3] = 4\n  容量 4kg: max(dp[1][4]=3, dp[1][1]+4=4) = 4 → dp[2][4] = 4\n  容量 5kg: max(dp[1][5]=3, dp[1][2]+4=3+4=7) = 7 → dp[2][5] = 7\n  容量 6～10kg: 同様に計算 → dp[2][6] = 7, ..., dp[2][10] = 7\n\n品物3（重さ4kg、価値5）:\n  容量 0～3kg: 品物3を詰められない → dp[3][0] = 0, ..., dp[3][3] = 4\n  容量 4kg: max(dp[2][4]=4, dp[2][0]+5=5) = 5 → dp[3][4] = 5\n  容量 5kg: max(dp[2][5]=7, dp[2][1]+5=5) = 7 → dp[3][5] = 7\n  容量 6kg: max(dp[2][6]=7, dp[2][2]+5=3+5=8) = 8 → dp[3][6] = 8\n  容量 7kg: max(dp[2][7]=7, dp[2][3]+5=4+5=9) = 9 → dp[3][7] = 9\n  容量 8kg: max(dp[2][8]=7, dp[2][4]+5=4+5=9) = 9 → dp[3][8] = 9\n  容量 9kg: max(dp[2][9]=7, dp[2][5]+5=7+5=12) = 12 → dp[3][9] = 12\n  容量 10kg: max(dp[2][10]=7, dp[2][6]+5=7+5=12) = 12 → dp[3][10] = 12\n\n品物4（重さ5kg、価値6）:\n  容量 0～4kg: 品物4を詰められない → dp[4][0] = 0, ..., dp[4][4] = 5\n  容量 5kg: max(dp[3][5]=7, dp[3][0]+6=6) = 7 → dp[4][5] = 7\n  容量 6kg: max(dp[3][6]=8, dp[3][1]+6=6) = 8 → dp[4][6] = 8\n  容量 7kg: max(dp[3][7]=9, dp[3][2]+6=3+6=9) = 9 → dp[4][7] = 9\n  容量 8kg: max(dp[3][8]=9, dp[3][3]+6=4+6=10) = 10 → dp[4][8] = 10\n  容量 9kg: max(dp[3][9]=12, dp[3][4]+6=5+6=11) = 12 → dp[4][9] = 12\n  容量 10kg: max(dp[3][10]=12, dp[3][5]+6=7+6=13) = 13 → dp[4][10] = 13\n\n【最終結果】\ndp[4][10] = 13（品物1～4を使って、容量10kgのナップサックに詰めたときの最大価値）\n\n【詰める品物の組み合わせ】\nDPテーブルをバックトラック（逆にたどる）:\n  dp[4][10] = 13（品物4を詰めた）\n  → dp[3][10-5] = dp[3][5] = 7（品物4を詰めたので、容量5kgで品物1～3を詰める）\n  dp[3][5] = 7（品物3を詰めなかった）\n  → dp[2][5] = 7（品物2を詰めた）\n  → dp[1][5-3] = dp[1][2] = 3（品物2を詰めたので、容量2kgで品物1を詰める）\n  dp[1][2] = 3（品物1を詰めた）\n  → dp[0][2-2] = dp[0][0] = 0（終了）\n\n詰める品物: 品物1（重さ2kg、価値3）+ 品物2（重さ3kg、価値4）+ 品物4（重さ5kg、価値6）\n合計重さ: 2 + 3 + 5 = 10kg（容量ぴったり）\n合計価値: 3 + 4 + 6 = 13（最大）"
        },
        {
          "type": "table",
          "headers": ["容量(kg)", "品物0個", "品物1まで", "品物2まで", "品物3まで", "品物4まで"],
          "rows": [
            ["0", "0", "0", "0", "0", "0"],
            ["1", "0", "0", "0", "0", "0"],
            ["2", "0", "3", "3", "3", "3"],
            ["3", "0", "3", "4", "4", "4"],
            ["4", "0", "3", "4", "5", "5"],
            ["5", "0", "3", "7", "7", "7"],
            ["6", "0", "3", "7", "8", "8"],
            ["7", "0", "3", "7", "9", "9"],
            ["8", "0", "3", "7", "9", "10"],
            ["9", "0", "3", "7", "12", "12"],
            ["10", "0", "3", "7", "12", "13"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "動的計画法の特徴",
          "content": "動的計画法は、①同じ計算を繰り返さない（メモ化）ため、計算量を大幅に削減できる（フィボナッチ数列: 再帰 O(2^n) → DP O(n)）、②最適化問題（最大値、最小値を求める問題）に適している、③DPテーブルを構築するため、追加メモリが必要（空間計算量 O(n×W)）、という特徴があります。ナップサック問題の時間計算量は O(n×W)（n: 品物数、W: ナップサック容量）です。"
        }
      ]
    },
    {
      "id": 4,
      "title": "貪欲法（コイン問題）",
      "sections": [
        {
          "type": "text",
          "content": "**貪欲法（Greedy Algorithm）**とは、各ステップで局所的に最適な選択をして、最終的に全体の解を得る手法です。貪欲法は、①その時点で最も良さそうな選択をする（局所最適）、②一度選択したら後戻りしない、という特徴があります。貪欲法は、動的計画法よりも単純で高速ですが、必ずしも最適解が得られるとは限りません。貪欲法で最適解が得られる問題は、**貪欲選択性質（Greedy Choice Property）**と**最適部分構造（Optimal Substructure）**を満たす必要があります。"
        },
        {
          "type": "example",
          "title": "コイン問題の詳細な解法",
          "content": "【問題】\n日本の硬貨（500円、100円、50円、10円、5円、1円）を使って、630円を支払う。\n使用する硬貨の枚数を最小にする組み合わせを求めよ。\n\n【貪欲法による解法】\nアルゴリズム:\n  ①最大額の硬貨から順に使う\n  ②各硬貨について、支払額を超えない範囲で最大枚数を使う\n  ③残金が0になるまで繰り返す\n\n【具体的な計算過程】\n\nステップ①：500円硬貨を使う\n  630円 ÷ 500円 = 1枚（余り 130円）\n  使用: 500円 × 1枚\n  残金: 630 - 500 = 130円\n\nステップ②：100円硬貨を使う\n  130円 ÷ 100円 = 1枚（余り 30円）\n  使用: 100円 × 1枚\n  残金: 130 - 100 = 30円\n\nステップ③：50円硬貨を使う\n  30円 ÷ 50円 = 0枚（使えない）\n  使用: 50円 × 0枚\n  残金: 30円\n\nステップ④：10円硬貨を使う\n  30円 ÷ 10円 = 3枚（余り 0円）\n  使用: 10円 × 3枚\n  残金: 30 - 30 = 0円\n\nステップ⑤：残金が0円になったので終了\n\n【最終結果】\n使用硬貨: 500円×1枚、100円×1枚、10円×3枚\n合計枚数: 1 + 1 + 3 = 5枚（最小）\n合計金額: 500 + 100 + 30 = 630円\n\n【別の例：987円を支払う】\n\nステップ①：500円硬貨を使う\n  987円 ÷ 500円 = 1枚（余り 487円）\n  使用: 500円 × 1枚\n  残金: 487円\n\nステップ②：100円硬貨を使う\n  487円 ÷ 100円 = 4枚（余り 87円）\n  使用: 100円 × 4枚\n  残金: 87円\n\nステップ③：50円硬貨を使う\n  87円 ÷ 50円 = 1枚（余り 37円）\n  使用: 50円 × 1枚\n  残金: 37円\n\nステップ④：10円硬貨を使う\n  37円 ÷ 10円 = 3枚（余り 7円）\n  使用: 10円 × 3枚\n  残金: 7円\n\nステップ⑤：5円硬貨を使う\n  7円 ÷ 5円 = 1枚（余り 2円）\n  使用: 5円 × 1枚\n  残金: 2円\n\nステップ⑥：1円硬貨を使う\n  2円 ÷ 1円 = 2枚（余り 0円）\n  使用: 1円 × 2枚\n  残金: 0円\n\n【最終結果】\n使用硬貨: 500円×1枚、100円×4枚、50円×1枚、10円×3枚、5円×1枚、1円×2枚\n合計枚数: 1 + 4 + 1 + 3 + 1 + 2 = 12枚（最小）\n合計金額: 500 + 400 + 50 + 30 + 5 + 2 = 987円"
        },
        {
          "type": "example",
          "title": "貪欲法が最適解を得られない例",
          "content": "【問題】\n硬貨が {1円, 6円, 10円} の3種類しかない場合、12円を支払う。\n\n【貪欲法による解法】\nステップ①：10円硬貨を使う\n  12円 ÷ 10円 = 1枚（余り 2円）\n  使用: 10円 × 1枚\n  残金: 2円\n\nステップ②：6円硬貨を使う\n  2円 ÷ 6円 = 0枚（使えない）\n  使用: 6円 × 0枚\n  残金: 2円\n\nステップ③：1円硬貨を使う\n  2円 ÷ 1円 = 2枚（余り 0円）\n  使用: 1円 × 2枚\n  残金: 0円\n\n貪欲法の解: 10円×1枚、1円×2枚 = 合計3枚\n\n【最適解（動的計画法）】\n6円硬貨を2枚使う: 6円×2枚 = 12円（合計2枚）← これが最適解\n\n貪欲法の解（3枚）は最適解（2枚）ではない!\n\n【理由】\n硬貨の種類が {1円, 6円, 10円} の場合、貪欲選択性質を満たさない（10円硬貨を選ぶことが局所最適だが、全体最適ではない）。日本の硬貨システムでは、大きい硬貨が小さい硬貨の倍数になっているため、貪欲法で最適解が得られます。"
        },
        {
          "type": "table",
          "headers": ["アルゴリズム", "特徴", "計算量", "最適解の保証"],
          "rows": [
            ["貪欲法", "局所最適を選択、後戻りしない", "O(n)（高速）", "問題による（日本の硬貨システムでは保証される）"],
            ["動的計画法", "全ての組み合わせを考慮、メモ化", "O(n×W)（遅い）", "常に最適解が得られる"]
          ]
        },
        {
          "type": "highlight",
          "icon": "📌",
          "title": "貪欲法が適用できる条件",
          "content": "貪欲法で最適解が得られる問題は、①**貪欲選択性質**：その時点で最良の選択をすれば、最終的に最適解が得られる、②**最適部分構造**：問題の最適解が部分問題の最適解から構成される、の2つの性質を満たす必要があります。代表的な例として、①日本の硬貨システム（大きい硬貨が小さい硬貨の倍数）、②ハフマン符号化、③ダイクストラ法（最短経路）、④クラスカル法（最小全域木）、があります。貪欲法は、動的計画法よりも単純で高速ですが、最適解が得られない場合もあるため、問題の性質を理解することが重要です。"
        }
      ]
    },
    {
      "id": 5,
      "title": "バックトラック（8クイーン問題）",
      "sections": [
        {
          "type": "text",
          "content": "**バックトラック（Backtracking）**とは、全ての可能性を系統的に探索し、解を見つける手法です。バックトラックは、①候補解を順番に試す、②制約を満たさない候補解は早期に枝刈り（探索を打ち切る）、③解が見つからない場合は前の状態に戻る（バックトラック）、という特徴があります。バックトラックは、全探索よりも効率的ですが、最悪の場合は指数時間がかかります。代表的な例として、8クイーン問題、数独、迷路探索、グラフの彩色問題があります。"
        },
        {
          "type": "example",
          "title": "8クイーン問題の詳細な解法",
          "content": "【問題】\n8×8のチェス盤に8個のクイーン（チェスの駒）を配置する。\nクイーンは、縦、横、斜めの任意の距離を移動できる。\n8個のクイーンが互いに攻撃し合わないように配置する方法を求めよ。\n\n【制約】\n①同じ行に2個以上のクイーンを配置できない\n②同じ列に2個以上のクイーンを配置できない\n③同じ斜め線上に2個以上のクイーンを配置できない\n\n【バックトラックによる解法】\n\nアルゴリズム:\n  ①1行目から順番にクイーンを配置\n  ②各行で、列1～8の位置を試す\n  ③制約を満たす位置があれば、クイーンを配置し、次の行へ\n  ④制約を満たす位置がなければ、前の行に戻る（バックトラック）\n  ⑤8行全てにクイーンを配置できたら解が見つかった\n\n【具体的な探索過程（4×4の盤で説明）】\n\n4×4の盤に4個のクイーンを配置する簡単な例:\n\n初期状態（空の盤）:\n```\n  1 2 3 4\n1 ・・・・\n2 ・・・・\n3 ・・・・\n4 ・・・・\n```\n\nステップ①：1行目にクイーンを配置\n  1列目を試す → 配置可能 → Q を (1,1) に配置\n```\n  1 2 3 4\n1 Q ・・・\n2 ・・・・\n3 ・・・・\n4 ・・・・\n```\n\nステップ②：2行目にクイーンを配置\n  1列目を試す → (1,1) と同じ列、NG\n  2列目を試す → (1,1) と同じ斜め線、NG\n  3列目を試す → 配置可能 → Q を (2,3) に配置\n```\n  1 2 3 4\n1 Q ・・・\n2 ・・Q ・\n3 ・・・・\n4 ・・・・\n```\n\nステップ③：3行目にクイーンを配置\n  1列目を試す → (1,1) と同じ列、NG\n  2列目を試す → (2,3) と同じ斜め線、NG\n  3列目を試す → (2,3) と同じ列、NG\n  4列目を試す → (2,3) と同じ斜め線、NG\n  → 配置できる列がない → バックトラック（2行目に戻る）\n\nバックトラック：2行目のクイーンを別の位置に移動\n  4列目を試す → 配置可能 → Q を (2,4) に配置\n```\n  1 2 3 4\n1 Q ・・・\n2 ・・・Q\n3 ・・・・\n4 ・・・・\n```\n\nステップ④：3行目にクイーンを配置\n  1列目を試す → (1,1) と同じ列、NG\n  2列目を試す → 配置可能 → Q を (3,2) に配置\n```\n  1 2 3 4\n1 Q ・・・\n2 ・・・Q\n3 ・Q ・・\n4 ・・・・\n```\n\nステップ⑤：4行目にクイーンを配置\n  1列目を試す → (1,1) と同じ列、NG\n  2列目を試す → (3,2) と同じ列、NG\n  3列目を試す → (2,4) と同じ斜め線、NG\n  4列目を試す → (2,4) と同じ列、NG\n  → 配置できる列がない → バックトラック（3行目に戻る）\n\nバックトラック：3行目のクイーンを別の位置に移動\n  3列目を試す → (2,4) と同じ斜め線、NG\n  4列目を試す → (2,4) と同じ列、NG\n  → 配置できる列がない → さらにバックトラック（2行目に戻る）\n\n... このプロセスを繰り返す ...\n\n最終的に見つかった解の1つ:\n```\n  1 2 3 4\n1 ・Q ・・\n2 ・・・Q\n3 Q ・・・\n4 ・・Q ・\n```\nクイーンの位置: (1,2), (2,4), (3,1), (4,3)\n\n【8×8の盤の解】\n8×8の盤には92個の解が存在します（回転・反転を区別する場合）。\n\n解の1つ:\n```\n  1 2 3 4 5 6 7 8\n1 Q ・・・・・・・\n2 ・・・・Q ・・・\n3 ・・・・・・・Q\n4 ・・・・・Q ・・\n5 ・・Q ・・・・・\n6 ・・・・・・Q ・\n7 ・Q ・・・・・・\n8 ・・・Q ・・・・\n```\nクイーンの位置: (1,1), (2,5), (3,8), (4,6), (5,3), (6,7), (7,2), (8,4)"
        },
        {
          "type": "table",
          "headers": ["盤のサイズ", "解の数", "計算量"],
          "rows": [
            ["4×4", "2個", "O(n!)"],
            ["8×8", "92個", "O(n!)"],
            ["n×n", "問題により異なる", "O(n!)（最悪）"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "バックトラックの特徴",
          "content": "バックトラックは、①全ての可能性を系統的に探索するため、必ず解が見つかる（解が存在する場合）、②制約を満たさない候補解を早期に枝刈りするため、全探索（n×n の盤に n 個のクイーンを配置する全ての組み合わせ C(n², n) を試す）よりも効率的、③最悪の場合は指数時間（O(n!)）がかかる、という特徴があります。バックトラックは、数独、迷路探索、グラフの彩色問題、制約充足問題（CSP）など、組み合わせ最適化問題に広く応用されています。実装では、再帰を使って探索の深さを管理し、制約チェックを効率化することが重要です。"
        }
      ]
    }
  ]
}
