{
  "topicId": "tech-4-2-1",
  "title": "モジュール設計",
  "pages": [
    {
      "id": 1,
      "title": "モジュール設計の概要",
      "sections": [
        {
          "type": "text",
          "content": "モジュール設計とは、プログラムを複数の小さな部品（モジュール）に分割して設計する手法です。モジュールは、特定の機能を持つプログラムの部品で、他のモジュールから独立して開発・テスト・保守ができます。大規模なプログラムを一つの塊として開発すると、理解が困難で、バグの修正や機能追加が難しくなります。モジュール化により、複雑なプログラムを管理しやすくし、開発効率と保守性を向上させます。"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "モジュール分割の目的",
          "content": "①複雑さの軽減：大きなプログラムを小さな部品に分割し、理解しやすくする。②開発効率の向上：複数人で並行開発できる（Aさんは認証モジュール、Bさんは決済モジュールを担当等）。③再利用性の向上：汎用的なモジュール（例：日付処理モジュール）を他のプロジェクトでも使い回せる。④保守性の向上：バグ修正や機能追加時に、該当モジュールだけを修正すれば良い。⑤テストの容易化：モジュール単位でテストでき、バグの特定が迅速。"
        },
        {
          "type": "table",
          "headers": ["モジュール化なし（1万行の一枚岩プログラム）", "モジュール化あり（100個の100行モジュール）"],
          "rows": [
            ["理解が困難（全体を把握する必要）", "理解が容易（1モジュールだけ把握すれば良い）"],
            ["1人での開発（並行作業不可）", "複数人で並行開発可能"],
            ["バグ修正で全体に影響（副作用のリスク大）", "該当モジュールだけ修正（副作用のリスク小）"],
            ["テストが困難（全体をテスト）", "モジュール単位でテスト可能"],
            ["再利用不可（全体をコピー）", "モジュール単位で再利用可能"]
          ]
        },
        {
          "type": "text",
          "content": "良いモジュール設計の原則は、「高凝集度」（モジュール内の要素が密接に関連）と「低結合度」（モジュール間の依存が少ない）です。これにより、各モジュールが独立性を持ち、変更の影響が局所化され、保守性が向上します。"
        },
        {
          "type": "list",
          "items": [
            "モジュール：特定の機能を持つプログラムの部品で、独立して開発・テスト・保守が可能",
            "高凝集度：モジュール内の要素が密接に関連し、単一の明確な役割を持つ（望ましい）",
            "低結合度：モジュール間の依存関係が少なく、独立性が高い（望ましい）",
            "再利用性：一度作ったモジュールを他のプロジェクトで使い回せること",
            "保守性：バグ修正や機能追加が容易にできること"
          ]
        }
      ]
    },
    {
      "id": 2,
      "title": "モジュール分割技法",
      "sections": [
        {
          "type": "text",
          "content": "モジュール分割技法には、STS分割（Source-Transform-Sink）、TR分割（Transaction）、共通機能分割があります。これらはプログラムの構造や処理の流れに基づいてモジュールを分割する方法で、システムの特性に応じて適切な技法を選択します。"
        },
        {
          "type": "table",
          "headers": ["分割技法", "分割基準", "適用例", "特徴"],
          "rows": [
            ["STS分割（Source-Transform-Sink）", "データの流れ（入力→処理→出力）", "データ処理システム、バッチ処理", "3つのモジュールに分割：入力（Source）、変換（Transform）、出力（Sink）"],
            ["TR分割（Transaction）", "トランザクション（処理単位）", "オンラインシステム、Webアプリ", "トランザクションごとに分割：ユーザー登録、商品購入、注文キャンセル等"],
            ["共通機能分割", "共通して使う機能", "汎用的な処理が多いシステム", "日付処理、文字列処理、DBアクセス等を共通モジュールとして抽出"]
          ]
        },
        {
          "type": "highlight",
          "icon": "📝",
          "title": "STS分割（Source-Transform-Sink）",
          "content": "データの流れに着目し、①入力（Source）：データを取得する、②変換（Transform）：データを加工・処理する、③出力（Sink）：結果を出力する、の3つのモジュールに分割します。例えば、売上集計プログラムでは、①CSVファイルから売上データを読み込む（入力モジュール）、②売上データを集計・分析する（変換モジュール）、③集計結果をレポートに出力する（出力モジュール）、と分割します。データ処理システムやバッチ処理に適しています。"
        },
        {
          "type": "example",
          "title": "STS分割の具体例：給与計算システム",
          "content": "【プログラム全体】社員の勤務データから給与を計算し、給与明細を出力する\n\n【STS分割による3つのモジュール】\n\n①入力モジュール（Source）\n  - 機能：勤務データファイル（CSV）を読み込む\n  - 入力：勤務データファイル（社員ID、勤務時間、残業時間）\n  - 出力：勤務データの配列\n\n②変換モジュール（Transform）\n  - 機能：給与を計算する\n  - 入力：勤務データの配列\n  - 処理：基本給 + 残業代 - 控除額 = 支給額\n  - 出力：給与データの配列\n\n③出力モジュール（Sink）\n  - 機能：給与明細をPDFで出力する\n  - 入力：給与データの配列\n  - 出力：給与明細PDF\n\n【メリット】\n- 各モジュールが独立しており、例えば入力形式をCSVからExcelに変更する場合、入力モジュールだけ修正すれば良い\n- 変換ロジックの変更（税率の変更等）も変換モジュールだけ修正すれば良い"
        },
        {
          "type": "example",
          "title": "TR分割の具体例：ECサイト",
          "content": "【プログラム全体】ECサイトで、ユーザー登録、商品閲覧、カート追加、注文、決済などの機能を提供\n\n【TR分割による各トランザクションモジュール】\n\n①ユーザー登録モジュール\n  - トランザクション：新規ユーザーを登録する\n  - 入力：ユーザー名、メールアドレス、パスワード\n  - 処理：入力チェック、パスワード暗号化、DB登録\n  - 出力：登録完了メッセージ\n\n②商品購入モジュール\n  - トランザクション：商品を購入する\n  - 入力：商品ID、数量、配送先情報\n  - 処理：在庫チェック、注文データ作成、在庫減少、決済処理\n  - 出力：注文完了メッセージ、注文番号\n\n③注文キャンセルモジュール\n  - トランザクション：注文をキャンセルする\n  - 入力：注文番号\n  - 処理：キャンセル可否チェック、注文削除、在庫復元、返金処理\n  - 出力：キャンセル完了メッセージ\n\n【メリット】\n- 各トランザクションが独立しており、例えば決済方法の変更は商品購入モジュールだけ修正すれば良い\n- 新しいトランザクション（例：定期購入）を追加する場合も、既存モジュールに影響しない"
        }
      ]
    },
    {
      "id": 3,
      "title": "結合度（Coupling）",
      "sections": [
        {
          "type": "text",
          "content": "結合度（カップリング）は、モジュール間の依存関係の強さを示す指標です。結合度が低い（疎結合）ほど、モジュールの独立性が高く、変更の影響が局所化され、保守性が向上します。結合度には複数の種類があり、強い結合から弱い結合まで段階があります。良い設計では、結合度を低くすることが重要です。"
        },
        {
          "type": "table",
          "headers": ["結合度の種類", "説明", "依存の強さ", "評価"],
          "rows": [
            ["データ結合", "引数（パラメータ）のみでデータをやり取り", "最も弱い（最良）", "◎"],
            ["スタンプ結合", "データ構造（構造体、配列等）全体を渡す", "弱い", "○"],
            ["制御結合", "制御情報（フラグ等）を渡して動作を制御", "やや強い", "△"],
            ["外部結合", "外部変数（グローバル変数）を共有", "強い", "×"],
            ["共通結合", "共通領域（グローバルメモリ）を共有", "非常に強い", "×"],
            ["内容結合", "他モジュールの内部を直接参照・変更", "最も強い（最悪）", "××"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "望ましい結合度",
          "content": "【データ結合が最も望ましい】\nモジュール間のやり取りを引数（パラメータ）のみに限定し、必要最小限のデータだけを渡します。これにより、モジュールの独立性が高まり、変更の影響が局所化されます。例：add(a, b)という関数は、引数a, bを受け取り、結果を返すだけで、グローバル変数を使いません。\n\n【避けるべき結合度】\n内容結合、共通結合、外部結合は避けるべきです。グローバル変数を多用すると、どこでどの変数が変更されたか追跡困難になり、バグの温床となります。"
        },
        {
          "type": "example",
          "title": "結合度の具体例",
          "content": "【悪い例：外部結合（グローバル変数を使用）】\n\nint total = 0;  // グローバル変数\n\nvoid addPrice(int price) {\n    total += price;  // グローバル変数を直接変更\n}\n\nvoid showTotal() {\n    printf(\"合計: %d円\\n\", total);  // グローバル変数を参照\n}\n\n【問題点】\n- totalがどこで変更されたか追跡困難\n- 複数のモジュールがtotalを変更すると、バグの原因が特定しにくい\n- 並行処理でtotalが予期しない値になる可能性（競合状態）\n\n【良い例：データ結合（引数のみでやり取り）】\n\nint addPrice(int total, int price) {\n    return total + price;  // 引数を受け取り、結果を返すだけ\n}\n\nvoid showTotal(int total) {\n    printf(\"合計: %d円\\n\", total);\n}\n\nint main() {\n    int total = 0;\n    total = addPrice(total, 100);\n    total = addPrice(total, 200);\n    showTotal(total);  // 合計: 300円\n}\n\n【メリット】\n- totalの変更箇所が明確（main関数のみ）\n- 関数が独立しており、再利用しやすい\n- テストが容易（引数を渡すだけで動作確認できる）"
        }
      ]
    },
    {
      "id": 4,
      "title": "凝集度（Cohesion）",
      "sections": [
        {
          "type": "text",
          "content": "凝集度（コヒージョン）は、モジュール内の要素（処理、データ）がどれだけ密接に関連しているかを示す指標です。凝集度が高いほど、モジュールが単一の明確な役割を持ち、理解しやすく、保守しやすくなります。凝集度には複数の種類があり、弱い凝集から強い凝集まで段階があります。良い設計では、凝集度を高くすることが重要です。"
        },
        {
          "type": "table",
          "headers": ["凝集度の種類", "説明", "凝集の強さ", "評価"],
          "rows": [
            ["機能的凝集", "単一の明確な機能を実行", "最も強い（最良）", "◎"],
            ["情報的凝集", "同じデータ構造を操作する複数の機能", "強い", "○"],
            ["連絡的凝集", "データの流れで関連する複数の機能", "やや強い", "○"],
            ["手順的凝集", "実行順序で関連する複数の処理", "普通", "△"],
            ["時間的凝集", "実行タイミングで関連する複数の処理", "やや弱い", "△"],
            ["論理的凝集", "論理的に似た複数の処理を1つにまとめる", "弱い", "×"],
            ["偶発的凝集", "無関係な処理を寄せ集め", "最も弱い（最悪）", "××"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "望ましい凝集度",
          "content": "【機能的凝集が最も望ましい】\nモジュールが単一の明確な機能だけを実行します。例：calculateTax(price)という関数は、価格から消費税を計算するだけの単一機能です。これにより、モジュールの役割が明確で、理解しやすく、再利用しやすくなります。\n\n【避けるべき凝集度】\n論理的凝集、偶発的凝集は避けるべきです。例えば、「なんでもやる関数」は、複数の無関係な処理を含むため、理解困難で、変更時に予期しない副作用が発生しやすくなります。"
        },
        {
          "type": "example",
          "title": "凝集度の具体例",
          "content": "【悪い例：偶発的凝集（無関係な処理を寄せ集め）】\n\nvoid doEverything(int x) {\n    // ユーザー登録\n    registerUser(x);\n    // 売上集計\n    calculateSales(x);\n    // メール送信\n    sendEmail(x);\n    // ログ出力\n    writeLog(x);\n}\n\n【問題点】\n- モジュールの役割が不明確（何をするモジュールか理解困難）\n- 無関係な処理が混在しており、変更時に副作用のリスク大\n- 再利用不可（全部の機能が必要な場合のみ使える）\n\n【良い例：機能的凝集（単一の明確な機能）】\n\nvoid registerUser(String username, String email) {\n    // ユーザー登録の処理のみ\n    // 1. 入力チェック\n    // 2. パスワード暗号化\n    // 3. DB登録\n}\n\nvoid calculateSales(Date startDate, Date endDate) {\n    // 売上集計の処理のみ\n    // 1. 期間内の売上データを取得\n    // 2. 集計\n    // 3. 結果を返す\n}\n\n【メリット】\n- 各モジュールの役割が明確（関数名から何をするか理解できる）\n- 変更の影響が局所化（ユーザー登録の変更は売上集計に影響しない）\n- 再利用しやすい（必要な機能だけ呼び出せる）"
        },
        {
          "type": "text",
          "content": "機能的凝集のモジュールは、「単一責任の原則（Single Responsibility Principle）」に従っています。1つのモジュールは1つの責任（機能）のみを持つべきで、変更する理由も1つだけであるべきです。これにより、モジュールの独立性が高まり、保守性が向上します。"
        }
      ]
    },
    {
      "id": 5,
      "title": "モジュール設計のベストプラクティス",
      "sections": [
        {
          "type": "text",
          "content": "良いモジュール設計を実現するためには、高凝集度と低結合度を目指すことが基本です。これに加えて、適切なモジュール分割技法の選択、明確なインターフェース設計、適切なモジュールサイズの維持などが重要です。"
        },
        {
          "type": "table",
          "headers": ["ベストプラクティス", "説明", "具体例"],
          "rows": [
            ["高凝集度・低結合度", "モジュール内は密接に関連し、モジュール間は疎結合にする", "機能的凝集のモジュールをデータ結合で連携"],
            ["単一責任の原則", "1つのモジュールは1つの責任（機能）のみを持つ", "calculateTax()は税計算のみ、registerUser()はユーザー登録のみ"],
            ["明確なインターフェース", "モジュールの入力・出力を明確に定義", "関数のシグネチャ（引数と戻り値）を明確にする"],
            ["適切なサイズ", "大きすぎず小さすぎないモジュールサイズ", "50～200行程度（目安）、1画面で見渡せる範囲"],
            ["再利用性の考慮", "汎用的な処理は共通モジュールとして抽出", "日付処理、文字列処理、DBアクセス等を共通化"]
          ]
        },
        {
          "type": "highlight",
          "icon": "📝",
          "title": "モジュール設計の評価基準",
          "content": "良いモジュール設計かどうかを評価する基準：①独立性：他のモジュールへの依存が少なく、単独でテスト可能か。②理解しやすさ：モジュールの役割が明確で、コードを読めばすぐに理解できるか。③変更しやすさ：機能変更時に、該当モジュールだけ修正すれば良いか。④再利用しやすさ：他のプロジェクトでもそのまま使えるか。⑤テストしやすさ：単体テストで動作確認できるか。"
        },
        {
          "type": "example",
          "title": "リファクタリング例：悪い設計から良い設計へ",
          "content": "【悪い設計】\n\n// グローバル変数を多用（外部結合）、複数の無関係な処理が混在（偶発的凝集）\nint userCount = 0;\nint totalSales = 0;\n\nvoid processData(String data, int mode) {\n    if (mode == 1) {\n        // ユーザー登録\n        userCount++;\n        saveUser(data);\n    } else if (mode == 2) {\n        // 売上集計\n        totalSales += parseInt(data);\n    } else if (mode == 3) {\n        // レポート出力\n        printReport(userCount, totalSales);\n    }\n}\n\n【問題点】\n- グローバル変数の多用で、どこで値が変更されたか追跡困難\n- 1つの関数で複数の無関係な処理を実行（凝集度が低い）\n- modeによる分岐が多く、理解困難\n\n【良い設計】\n\n// 各機能を独立したモジュールに分割（機能的凝集）\n// 引数のみでやり取り（データ結合）\n\nint registerUser(String userData, int currentCount) {\n    saveUser(userData);\n    return currentCount + 1;  // 新しいカウントを返す\n}\n\nint addSales(int amount, int currentTotal) {\n    return currentTotal + amount;  // 新しい合計を返す\n}\n\nvoid printReport(int userCount, int totalSales) {\n    printf(\"ユーザー数: %d, 売上合計: %d円\\n\", userCount, totalSales);\n}\n\nint main() {\n    int userCount = 0;\n    int totalSales = 0;\n    \n    userCount = registerUser(\"Alice\", userCount);\n    totalSales = addSales(1000, totalSales);\n    printReport(userCount, totalSales);\n}\n\n【改善点】\n- グローバル変数を排除し、データ結合に変更\n- 各機能を独立したモジュール（関数）に分割し、機能的凝集を実現\n- 各関数が単一の明確な責任を持つ（単一責任の原則）"
        },
        {
          "type": "list",
          "items": [
            "高凝集度・低結合度を目指すことが、良いモジュール設計の基本原則",
            "機能的凝集（単一の明確な機能）が最も望ましい凝集度",
            "データ結合（引数のみでやり取り）が最も望ましい結合度",
            "グローバル変数の多用は避け、引数と戻り値でデータをやり取りする",
            "1つのモジュールは1つの責任のみを持つ（単一責任の原則）",
            "適切なモジュール分割技法（STS、TR、共通機能分割）を選択する"
          ]
        }
      ]
    }
  ]
}
