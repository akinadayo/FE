{
  "topicId": "tech-3-3-4",
  "title": "トランザクション処理",
  "pages": [
    {
      "id": 1,
      "title": "トランザクションとACID特性",
      "sections": [
        {
          "type": "text",
          "content": "**トランザクション（Transaction）**とは、データベースに対する一連の操作をまとめた論理的な処理単位です。「全て成功」または「全て失敗」のどちらかであり、途中の状態は存在しません。例えば、銀行の振込では、「A口座から引き落とし」と「B口座へ入金」の2つの操作は1つのトランザクションとして扱われ、一方が失敗したら両方とも取り消されます。トランザクションは、データベースの整合性を保つための重要な仕組みです。"
        },
        {
          "type": "highlight",
          "icon": "🎯",
          "title": "ACID特性（トランザクションの4つの性質）",
          "content": "①原子性（Atomicity）：全て成功 or 全て失敗（途中の状態なし）\n②一貫性（Consistency）：トランザクション実行前後でデータベースの整合性が保たれる\n③独立性（Isolation）：複数トランザクションが同時実行されても互いに影響を与えない\n④永続性（Durability）：コミット後のデータは、システム障害が発生しても永続的に保存される"
        },
        {
          "type": "example",
          "title": "ACID特性の具体例：銀行振込",
          "content": "【トランザクション内容】\nAさんの口座（残高50,000円）からBさんの口座（残高30,000円）へ10,000円を振り込む\n\n【処理手順】\n①BEGIN TRANSACTION（トランザクション開始）\n②UPDATE 口座表 SET 残高 = 残高 - 10000 WHERE 口座番号 = 'A';（Aさんから引き落とし）\n③UPDATE 口座表 SET 残高 = 残高 + 10000 WHERE 口座番号 = 'B';（Bさんへ入金）\n④COMMIT;（トランザクション確定）\n\n【ACID特性の適用】\n①原子性：②と③が両方成功するか、両方失敗するか。一方だけ成功することはない\n②一貫性：振込前の総残高80,000円 = 振込後の総残高80,000円（整合性が保たれる）\n③独立性：他のトランザクション（Cさんの振込など）が同時実行されても、このトランザクションに影響しない\n④永続性：COMMITした後、停電が発生してもAさん40,000円、Bさん40,000円の状態が保存される"
        },
        {
          "type": "table",
          "headers": ["ACID特性", "説明", "違反した場合の問題"],
          "rows": [
            ["原子性（Atomicity）", "全て成功 or 全て失敗", "Aさんから引き落としだけ成功→Aさんの10,000円が消失"],
            ["一貫性（Consistency）", "整合性を保つ", "振込前80,000円→振込後70,000円（総残高が減る）"],
            ["独立性（Isolation）", "他トランザクションの影響を受けない", "同時実行時にデータが壊れる（競合状態）"],
            ["永続性（Durability）", "コミット後は永続的に保存", "COMMITしたのに停電でデータが消える"]
          ]
        }
      ]
    },
    {
      "id": 2,
      "title": "排他制御とロック",
      "sections": [
        {
          "type": "text",
          "content": "**排他制御（Exclusive Control）**とは、複数のトランザクションが同時に同じデータにアクセスする際、データの整合性を保つための仕組みです。主な手法として**ロック（Lock）**があります。ロックには、**共有ロック（Shared Lock、読み取りロック）**と**専有ロック（Exclusive Lock、書き込みロック）**の2種類があります。共有ロックは読み取り専用で複数トランザクションが同時に取得可能、専有ロックは書き込み用で1つのトランザクションのみが取得可能です。"
        },
        {
          "type": "table",
          "headers": ["ロック種類", "用途", "他トランザクションの動作", "具体例"],
          "rows": [
            ["共有ロック（S-Lock）", "読み取り専用", "読み取り○、書き込み×（待機）", "商品一覧を複数ユーザーが同時に閲覧"],
            ["専有ロック（X-Lock）", "書き込み用", "読み取り×（待機）、書き込み×（待機）", "在庫数を更新中は他のトランザクションは待機"]
          ]
        },
        {
          "type": "example",
          "title": "ロックの具体例：在庫管理システム",
          "content": "【シナリオ】\n商品Aの在庫が10個。ユーザー1とユーザー2が同時に5個ずつ購入しようとする。\n\n【ロックなしの場合（問題発生）】\n時刻1：ユーザー1が在庫を読み取る → 10個\n時刻2：ユーザー2が在庫を読み取る → 10個\n時刻3：ユーザー1が在庫を更新 → 10 - 5 = 5個\n時刻4：ユーザー2が在庫を更新 → 10 - 5 = 5個（本来は0個のはずが5個になる）\n→ 在庫の不整合が発生（5個多い）\n\n【専有ロックありの場合（問題解決）】\n時刻1：ユーザー1が在庫に専有ロックを取得 → ロック成功\n時刻2：ユーザー1が在庫を読み取る → 10個\n時刻3：ユーザー2が在庫に専有ロックを取得 → ロック待機（ユーザー1が解放するまで）\n時刻4：ユーザー1が在庫を更新 → 10 - 5 = 5個\n時刻5：ユーザー1がコミット → ロック解放\n時刻6：ユーザー2がロック取得 → ロック成功\n時刻7：ユーザー2が在庫を読み取る → 5個\n時刻8：ユーザー2が在庫を更新 → 5 - 5 = 0個\n時刻9：ユーザー2がコミット → ロック解放\n→ 正しく在庫が0個になる"
        },
        {
          "type": "highlight",
          "icon": "📌",
          "title": "ロックの粒度",
          "content": "ロックの粒度（範囲）には、①行レベルロック（1行のみロック）、②ページレベルロック（複数行を含むページ単位）、③表レベルロック（表全体をロック）、があります。粒度が細かい（行レベル）ほど並行性が高く、粒度が粗い（表レベル）ほど管理が簡単ですが並行性が低下します。"
        }
      ]
    },
    {
      "id": 3,
      "title": "デッドロックと回避方法",
      "sections": [
        {
          "type": "text",
          "content": "**デッドロック（Deadlock）**とは、複数のトランザクションが互いにロックを待ち合って、永久に処理が進まなくなる状態です。例えば、トランザクションAが資源1をロック中で資源2を待ち、トランザクションBが資源2をロック中で資源1を待つ場合、両方とも永久に待ち続けます。デッドロックを解決するには、①デッドロック検出（発生したら一方をロールバック）、②デッドロック回避（発生しないように設計）、の2つの方法があります。"
        },
        {
          "type": "example",
          "title": "デッドロックの具体例",
          "content": "【シナリオ】\n商品表（商品ID, 商品名, 在庫）と注文表（注文ID, 商品ID, 数量）がある。\n\n【デッドロック発生】\n時刻1：トランザクションA「商品ID=1に専有ロック」を取得\n時刻2：トランザクションB「商品ID=2に専有ロック」を取得\n時刻3：トランザクションA「商品ID=2に専有ロック」を取得しようとする → 待機（Bがロックしているため）\n時刻4：トランザクションB「商品ID=1に専有ロック」を取得しようとする → 待機（Aがロックしているため）\n→ AはBを待ち、BはAを待つ → デッドロック発生\n\n【解決方法1：タイムアウト】\n時刻5：30秒経過後、システムがトランザクションBを強制的にロールバック\n時刻6：Bのロックが解放される\n時刻7：トランザクションAが商品ID=2のロックを取得 → 処理続行\n\n【解決方法2：ロックの順序統一（予防）】\nルール：「商品IDの小さい順にロックを取得する」\n→ AもBも商品ID=1 → 商品ID=2の順にロックを取得\n→ 先にロックを取得した方が両方のロックを取得し、後の方は待機するだけ\n→ デッドロック発生しない"
        },
        {
          "type": "table",
          "headers": ["デッドロック対策", "説明", "長所", "短所"],
          "rows": [
            ["デッドロック検出", "発生したら一方をロールバック", "柔軟（どんな場合でも対応可能）", "ロールバック後の再実行が必要"],
            ["デッドロック回避", "発生しないように設計（ロック順序統一など）", "デッドロックが発生しない", "設計が複雑、全トランザクションでルール統一が必要"],
            ["タイムアウト", "一定時間待ってもロック取得できなければロールバック", "実装が簡単", "デッドロックでなくても単に遅い場合も中断される"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "デッドロック発生の4条件（循環待ち条件）",
          "content": "①相互排除（資源を排他的に使用）\n②占有と待機（資源を保持しながら別の資源を待つ）\n③非プリエンプション（資源を強制的に取り上げられない）\n④循環待機（AがBを待ち、BがCを待ち、CがAを待つ）\n\n4つ全てが揃うとデッドロックが発生します。どれか1つでも満たさなければデッドロックは発生しません。"
        }
      ]
    },
    {
      "id": 4,
      "title": "コミット・ロールバック・チェックポイント",
      "sections": [
        {
          "type": "text",
          "content": "**コミット（COMMIT）**とは、トランザクションの変更を確定し、データベースに永続的に反映させる操作です。**ロールバック（ROLLBACK）**とは、トランザクションの変更を取り消し、トランザクション開始前の状態に戻す操作です。**チェックポイント（Checkpoint）**とは、トランザクションログを定期的にデータベースに反映させ、障害発生時のリカバリ時間を短縮する仕組みです。チェックポイントを取得することで、それ以前のトランザクションはリカバリ不要になります。"
        },
        {
          "type": "example",
          "title": "コミットとロールバックの具体例",
          "content": "【成功時：コミット】\nBEGIN TRANSACTION;\nUPDATE 口座表 SET 残高 = 残高 - 10000 WHERE 口座番号 = 'A';（成功）\nUPDATE 口座表 SET 残高 = 残高 + 10000 WHERE 口座番号 = 'B';（成功）\nCOMMIT;（変更を確定）\n→ データベースに永続的に反映され、Aさん40,000円、Bさん40,000円になる\n\n【失敗時：ロールバック】\nBEGIN TRANSACTION;\nUPDATE 口座表 SET 残高 = 残高 - 10000 WHERE 口座番号 = 'A';（成功、残高40,000円）\nUPDATE 口座表 SET 残高 = 残高 + 10000 WHERE 口座番号 = 'B';（エラー発生、例：口座番号Bが存在しない）\nROLLBACK;（全ての変更を取り消し）\n→ Aさんの残高は50,000円に戻る（引き落としが取り消される）"
        },
        {
          "type": "example",
          "title": "チェックポイントの具体例",
          "content": "【チェックポイントなしの場合】\n時刻0：トランザクション1（T1）開始\n時刻1：T1がデータAを更新（ログに記録）\n時刻2：T1がコミット\n時刻3：トランザクション2（T2）開始\n時刻4：T2がデータBを更新（ログに記録）\n時刻5：T2がコミット\n...\n時刻100：システム障害発生\n→ リカバリ時、時刻0からのログを全て再生する必要がある（時間がかかる）\n\n【チェックポイントありの場合】\n時刻0：トランザクション1（T1）開始\n時刻1：T1がデータAを更新（ログに記録）\n時刻2：T1がコミット\n時刻50：チェックポイント取得（T1の変更をデータベースに反映、ログをクリア）\n時刻51：トランザクション2（T2）開始\n時刻52：T2がデータBを更新（ログに記録）\n時刻53：T2がコミット\n時刻100：システム障害発生\n→ リカバリ時、時刻50（チェックポイント）からのログのみ再生すれば良い（速い）"
        },
        {
          "type": "table",
          "headers": ["操作", "説明", "影響範囲", "具体例"],
          "rows": [
            ["COMMIT", "トランザクションを確定", "データベースに永続的に反映", "振込成功→残高が確定"],
            ["ROLLBACK", "トランザクションを取り消し", "トランザクション開始前の状態に戻る", "振込失敗→残高が元に戻る"],
            ["CHECKPOINT", "ログをデータベースに反映", "リカバリ時間を短縮", "定期的に実行し、障害時の復旧を高速化"]
          ]
        }
      ]
    },
    {
      "id": 5,
      "title": "2相コミットとリカバリ",
      "sections": [
        {
          "type": "text",
          "content": "**2相コミット（Two-Phase Commit、2PC）**とは、分散データベースで複数のデータベースサーバーにまたがるトランザクションを、全てのサーバーで一貫してコミットまたはロールバックするためのプロトコルです。フェーズ1（準備フェーズ）で全サーバーに「コミット可能か？」を問い合わせ、全員が「YES」ならフェーズ2（コミットフェーズ）で全サーバーに「コミット実行」を指示します。1つでも「NO」なら全サーバーでロールバックします。"
        },
        {
          "type": "example",
          "title": "2相コミットの具体例：国際送金",
          "content": "【シナリオ】\n日本の銀行（DB1）からアメリカの銀行（DB2）へ送金。両方のデータベースでトランザクションが成功しなければならない。\n\n【2相コミットの流れ】\nフェーズ1：準備（Prepare）\n①コーディネーター「DB1、コミット可能？」\n②DB1「YES（日本の口座から引き落とし可能）」\n③コーディネーター「DB2、コミット可能？」\n④DB2「YES（アメリカの口座へ入金可能）」\n\n全員が「YES」なのでフェーズ2へ\n\nフェーズ2：コミット（Commit）\n⑤コーディネーター「DB1、コミット実行！」\n⑥DB1「コミット完了」\n⑦コーディネーター「DB2、コミット実行！」\n⑧DB2「コミット完了」\n→ 両方のデータベースでコミットが完了\n\n【失敗パターン】\nフェーズ1で1つでも「NO」なら全員ロールバック\n①コーディネーター「DB1、コミット可能？」\n②DB1「YES」\n③コーディネーター「DB2、コミット可能？」\n④DB2「NO（アメリカの口座が存在しない）」\n⑤コーディネーター「DB1、ロールバック！」\n⑥DB1「ロールバック完了」\n→ 両方のデータベースでロールバック"
        },
        {
          "type": "highlight",
          "icon": "🔧",
          "title": "リカバリの種類",
          "content": "①ロールフォワード（Roll Forward）：チェックポイント後のログを再生し、コミット済みトランザクションを復元\n②ロールバック（Roll Back）：未コミットトランザクションを取り消し\n\nシステム障害時は、①ロールフォワードで確定済みデータを復元、②ロールバックで中途半端なデータを削除、の両方を実行します。"
        },
        {
          "type": "example",
          "title": "リカバリの具体例",
          "content": "【障害発生前の状況】\n時刻0：チェックポイント取得\n時刻1：トランザクション1（T1）開始\n時刻2：T1がデータAを更新\n時刻3：T1がコミット（確定）\n時刻4：トランザクション2（T2）開始\n時刻5：T2がデータBを更新\n時刻6：システム障害発生（T2はコミット前）\n\n【リカバリ処理】\nステップ1：ログを読み込み、チェックポイント（時刻0）以降のトランザクションを確認\n→ T1（コミット済み）、T2（未コミット）を発見\n\nステップ2：ロールフォワード\n→ T1のログ（データAの更新）を再生し、データAを復元\n\nステップ3：ロールバック\n→ T2のログ（データBの更新）を取り消し、データBを元に戻す\n\n【リカバリ後】\nデータA：T1の更新が反映される（コミット済みのため）\nデータB：T2の更新が取り消される（未コミットのため）"
        },
        {
          "type": "table",
          "headers": ["リカバリ手法", "説明", "対象", "具体例"],
          "rows": [
            ["ロールフォワード", "ログを再生してコミット済みトランザクションを復元", "コミット済みトランザクション", "T1の変更を再適用"],
            ["ロールバック", "ログを逆再生して未コミットトランザクションを取り消し", "未コミットトランザクション", "T2の変更を取り消し"],
            ["チェックポイント", "定期的にログをデータベースに反映", "全トランザクション", "1時間ごとに実行し、リカバリ時間を短縮"]
          ]
        }
      ]
    }
  ]
}
