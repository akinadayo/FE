{
  "topicId": "tech-4-3-4",
  "title": "整列アルゴリズム",
  "pages": [
    {
      "id": 1,
      "title": "整列アルゴリズムの基礎とバブルソート",
      "sections": [
        {
          "type": "text",
          "content": "**整列（ソート）**とは、データを特定の順序（昇順または降順）に並び替える処理です。整列アルゴリズムは、データ検索の高速化、データの可視化、データベースのインデックス作成などに使われます。整列アルゴリズムは、①**時間計算量**（データ数nに対する実行時間）、②**空間計算量**（必要なメモリ量）、③**安定性**（同じ値を持つデータの元の順序が保たれるか）、の3つの観点で評価されます。"
        },
        {
          "type": "table",
          "headers": ["アルゴリズム", "最良計算量", "平均計算量", "最悪計算量", "空間計算量", "安定性"],
          "rows": [
            ["バブルソート", "O(n)", "O(n²)", "O(n²)", "O(1)", "安定"],
            ["選択ソート", "O(n²)", "O(n²)", "O(n²)", "O(1)", "不安定"],
            ["挿入ソート", "O(n)", "O(n²)", "O(n²)", "O(1)", "安定"],
            ["クイックソート", "O(n log n)", "O(n log n)", "O(n²)", "O(log n)", "不安定"],
            ["マージソート", "O(n log n)", "O(n log n)", "O(n log n)", "O(n)", "安定"],
            ["ヒープソート", "O(n log n)", "O(n log n)", "O(n log n)", "O(1)", "不安定"]
          ]
        },
        {
          "type": "text",
          "content": "**バブルソート（基本交換法）**は、隣接する2つのデータを比較し、順序が逆ならば交換する処理を繰り返すアルゴリズムです。最大値が配列の末尾に「泡（バブル）」のように浮上していくことから、この名前が付けられました。アルゴリズムはシンプルですが、計算量がO(n²)と大きいため、大規模データには不向きです。"
        },
        {
          "type": "example",
          "title": "バブルソートの具体例：昇順に整列",
          "content": "配列 [5, 2, 8, 1, 9] を昇順に整列します。\n\n【1回目のパス】\n①[5, 2, 8, 1, 9] → 5と2を比較 → 5 > 2 なので交換 → [2, 5, 8, 1, 9]\n②[2, 5, 8, 1, 9] → 5と8を比較 → 5 < 8 なので交換なし → [2, 5, 8, 1, 9]\n③[2, 5, 8, 1, 9] → 8と1を比較 → 8 > 1 なので交換 → [2, 5, 1, 8, 9]\n④[2, 5, 1, 8, 9] → 8と9を比較 → 8 < 9 なので交換なし → [2, 5, 1, 8, 9]\n→ 最大値9が末尾に確定\n\n【2回目のパス】\n①[2, 5, 1, 8, 9] → 2と5を比較 → 2 < 5 なので交換なし → [2, 5, 1, 8, 9]\n②[2, 5, 1, 8, 9] → 5と1を比較 → 5 > 1 なので交換 → [2, 1, 5, 8, 9]\n③[2, 1, 5, 8, 9] → 5と8を比較 → 5 < 8 なので交換なし → [2, 1, 5, 8, 9]\n→ 2番目の最大値8が確定\n\n【3回目のパス】\n①[2, 1, 5, 8, 9] → 2と1を比較 → 2 > 1 なので交換 → [1, 2, 5, 8, 9]\n②[1, 2, 5, 8, 9] → 2と5を比較 → 2 < 5 なので交換なし → [1, 2, 5, 8, 9]\n→ 3番目の最大値5が確定\n\n【4回目のパス】\n①[1, 2, 5, 8, 9] → 1と2を比較 → 1 < 2 なので交換なし → [1, 2, 5, 8, 9]\n→ 整列完了\n\n【交換回数】\n1回目: 2回、2回目: 1回、3回目: 1回、4回目: 0回\n→ 合計4回の交換"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "バブルソートの特徴",
          "content": "利点：①アルゴリズムが単純で理解しやすい、②安定ソート（同じ値の順序が保たれる）、③追加メモリが不要（O(1)の空間計算量）\n\n欠点：①計算量がO(n²)と大きい、②大規模データには不向き、③交換回数が多い\n\n最良ケース（O(n)）：既に整列済みの場合、1回のパスで交換が0回なら終了できる（改良版）\n最悪ケース（O(n²)）：逆順の場合、n(n-1)/2回の比較と交換が必要"
        }
      ]
    },
    {
      "id": 2,
      "title": "選択ソートと挿入ソート",
      "sections": [
        {
          "type": "text",
          "content": "**選択ソート（基本選択法）**は、未整列部分から最小値を選択し、整列済み部分の末尾に移動する処理を繰り返すアルゴリズムです。バブルソートより交換回数が少ないですが、計算量はO(n²)です。選択ソートは不安定ソート（同じ値の順序が保たれない場合がある）です。"
        },
        {
          "type": "example",
          "title": "選択ソートの具体例：昇順に整列",
          "content": "配列 [5, 2, 8, 1, 9] を昇順に整列します。\n\n【初期状態】\n[5, 2, 8, 1, 9]\n未整列部分: [5, 2, 8, 1, 9]、整列済み部分: []\n\n【1回目】\n未整列部分 [5, 2, 8, 1, 9] から最小値1を選択\n→ 先頭の5と交換\n→ [1, 2, 8, 5, 9]\n未整列部分: [2, 8, 5, 9]、整列済み部分: [1]\n\n【2回目】\n未整列部分 [2, 8, 5, 9] から最小値2を選択\n→ 先頭の2と交換（同じ位置なので交換不要）\n→ [1, 2, 8, 5, 9]\n未整列部分: [8, 5, 9]、整列済み部分: [1, 2]\n\n【3回目】\n未整列部分 [8, 5, 9] から最小値5を選択\n→ 先頭の8と交換\n→ [1, 2, 5, 8, 9]\n未整列部分: [8, 9]、整列済み部分: [1, 2, 5]\n\n【4回目】\n未整列部分 [8, 9] から最小値8を選択\n→ 先頭の8と交換（同じ位置なので交換不要）\n→ [1, 2, 5, 8, 9]\n未整列部分: [9]、整列済み部分: [1, 2, 5, 8]\n\n→ 整列完了\n\n【交換回数】\n合計2回の交換（バブルソートの4回より少ない）"
        },
        {
          "type": "text",
          "content": "**挿入ソート（基本挿入法）**は、未整列部分の先頭要素を、整列済み部分の適切な位置に挿入する処理を繰り返すアルゴリズムです。トランプのカードを手札に1枚ずつ追加して並べるイメージです。データがほぼ整列済みの場合、O(n)の高速動作が期待できます。挿入ソートは安定ソートです。"
        },
        {
          "type": "example",
          "title": "挿入ソートの具体例：昇順に整列",
          "content": "配列 [5, 2, 8, 1, 9] を昇順に整列します。\n\n【初期状態】\n[5, 2, 8, 1, 9]\n整列済み部分: [5]、未整列部分: [2, 8, 1, 9]\n\n【1回目】\n2を整列済み部分 [5] に挿入\n→ 5 > 2 なので5を右にシフト → [_, 5, 8, 1, 9]\n→ 2を挿入 → [2, 5, 8, 1, 9]\n整列済み部分: [2, 5]、未整列部分: [8, 1, 9]\n\n【2回目】\n8を整列済み部分 [2, 5] に挿入\n→ 5 < 8 なので挿入位置は末尾\n→ [2, 5, 8, 1, 9]\n整列済み部分: [2, 5, 8]、未整列部分: [1, 9]\n\n【3回目】\n1を整列済み部分 [2, 5, 8] に挿入\n→ 8 > 1 なので8を右にシフト → [2, 5, _, 8, 9]\n→ 5 > 1 なので5を右にシフト → [2, _, 5, 8, 9]\n→ 2 > 1 なので2を右にシフト → [_, 2, 5, 8, 9]\n→ 1を挿入 → [1, 2, 5, 8, 9]\n整列済み部分: [1, 2, 5, 8]、未整列部分: [9]\n\n【4回目】\n9を整列済み部分 [1, 2, 5, 8] に挿入\n→ 8 < 9 なので挿入位置は末尾\n→ [1, 2, 5, 8, 9]\n\n→ 整列完了\n\n【シフト回数】\n1回目: 1回、2回目: 0回、3回目: 3回、4回目: 0回\n→ 合計4回のシフト"
        },
        {
          "type": "table",
          "headers": ["アルゴリズム", "基本操作", "交換回数", "安定性", "最良ケース"],
          "rows": [
            ["バブルソート", "隣接要素を比較・交換", "多い（最悪n²/2回）", "安定", "O(n)（既に整列済み）"],
            ["選択ソート", "最小値を選択・交換", "少ない（n-1回）", "不安定", "O(n²)（常に全探索）"],
            ["挿入ソート", "適切な位置に挿入", "中程度", "安定", "O(n)（既に整列済み）"]
          ]
        },
        {
          "type": "highlight",
          "icon": "🔧",
          "title": "O(n²)アルゴリズムの使い分け",
          "content": "①バブルソート：教育用（アルゴリズムが最もシンプル）\n②選択ソート：交換回数を最小化したい場合（メモリ書き込みコストが高い場合）\n③挿入ソート：ほぼ整列済みのデータ（O(n)で高速動作）、小規模データ（n < 50程度）\n\n実際のプログラミングでは、クイックソートやマージソートなどのO(n log n)アルゴリズムが使われます。ただし、小規模データ（n < 10）では、挿入ソートの方が高速な場合があります（Pythonの標準ライブラリも、小規模データには挿入ソートを使用）。"
        }
      ]
    },
    {
      "id": 3,
      "title": "クイックソート（高速整列法）",
      "sections": [
        {
          "type": "text",
          "content": "**クイックソート**は、配列から基準値（ピボット、pivot）を選び、ピボットより小さい要素を左、大きい要素を右に分割し、再帰的に整列する分割統治法のアルゴリズムです。平均計算量がO(n log n)と高速で、実用的に最も使われるソートアルゴリズムの1つです。追加メモリがほとんど不要（O(log n)のスタック領域）で、空間効率も良好です。"
        },
        {
          "type": "example",
          "title": "クイックソートの具体例：昇順に整列",
          "content": "配列 [5, 2, 8, 1, 9, 3] を昇順に整列します。ピボットは配列の中央値（1番目の要素2）を選びます。\n\n【初期状態】\n[5, 2, 8, 1, 9, 3]\nピボット = 5（先頭要素を選択）\n\n【1回目の分割】\nピボット5を基準に分割\n- 5より小さい要素: [2, 1, 3]\n- ピボット: [5]\n- 5より大きい要素: [8, 9]\n→ [2, 1, 3] + [5] + [8, 9]\n\n【2回目の分割（左側 [2, 1, 3]）】\nピボット = 2\n- 2より小さい要素: [1]\n- ピボット: [2]\n- 2より大きい要素: [3]\n→ [1] + [2] + [3]\n→ 左側の整列完了: [1, 2, 3]\n\n【3回目の分割（右側 [8, 9]）】\nピボット = 8\n- 8より小さい要素: []\n- ピボット: [8]\n- 8より大きい要素: [9]\n→ [] + [8] + [9]\n→ 右側の整列完了: [8, 9]\n\n【最終結果】\n[1, 2, 3] + [5] + [8, 9]\n→ [1, 2, 3, 5, 8, 9]\n→ 整列完了\n\n【分割の流れ（ツリー構造）】\n          [5, 2, 8, 1, 9, 3]\n          /        |        \\\n    [2, 1, 3]    [5]    [8, 9]\n    /   |   \\           /  |  \\\n  [1]  [2]  [3]       [] [8] [9]\n\n【計算量】\n分割の深さ: log₂(6) ≒ 2.6層\n各層での比較回数: n = 6回\n→ 合計: O(n log n) ≒ 6 × 2.6 = 15.6回の比較"
        },
        {
          "type": "example",
          "title": "クイックソートの分割処理（詳細）",
          "content": "配列 [5, 2, 8, 1, 9, 3] をピボット5で分割する手順（Hoareの分割法）\n\n【初期状態】\n[5, 2, 8, 1, 9, 3]\nピボット = 5、左ポインタ(L) = 0、右ポインタ(R) = 5\n\n【分割処理】\n①Lを右に移動（5以上の要素を探す）\n  [5, 2, 8, 1, 9, 3]\n   L → → →\n  L = 2（8は5以上）\n\n②Rを左に移動（5未満の要素を探す）\n  [5, 2, 8, 1, 9, 3]\n           ← ← R\n  R = 3（3は5未満）\n\n③L < R なので、LとRの要素を交換\n  [5, 2, 3, 1, 9, 8]\n       L     R\n\n④Lを右に移動（5以上の要素を探す）\n  [5, 2, 3, 1, 9, 8]\n         L →\n  L = 4（9は5以上）\n\n⑤Rを左に移動（5未満の要素を探す）\n  [5, 2, 3, 1, 9, 8]\n         ← R\n  R = 3（1は5未満）\n\n⑥L > R なので、分割終了\n→ 左側: [5, 2, 3, 1]（インデックス0～3）\n→ 右側: [9, 8]（インデックス4～5）\n\n⑦ピボット5を正しい位置に配置\n  [1, 2, 3, 5, 9, 8]\n           ↑\n           ピボットの正しい位置"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "クイックソートの特徴",
          "content": "利点：①平均計算量がO(n log n)と高速、②追加メモリがほとんど不要（O(log n)のスタック領域）、③実装が比較的簡単、④キャッシュ効率が良い\n\n欠点：①最悪ケースO(n²)（既に整列済み、または逆順の場合）、②不安定ソート（同じ値の順序が保たれない）、③再帰呼び出しによるオーバーヘッド\n\n最悪ケースの回避策：①ピボット選択を工夫（中央値、ランダム）、②最悪ケースでヒープソートに切り替える（イントロソート）、③小規模データは挿入ソートに切り替える\n\n実用例：C言語のqsort()、Javaの配列ソート（プリミティブ型）、Rustの不安定ソートなど"
        },
        {
          "type": "table",
          "headers": ["ケース", "ピボット選択", "分割バランス", "計算量"],
          "rows": [
            ["最良", "常に中央値", "左右が同じサイズ", "O(n log n)"],
            ["平均", "ランダムな値", "ほぼバランス", "O(n log n)"],
            ["最悪", "常に最小値or最大値", "片側のみ分割", "O(n²)"]
          ]
        }
      ]
    },
    {
      "id": 4,
      "title": "マージソート（併合整列法）",
      "sections": [
        {
          "type": "text",
          "content": "**マージソート**は、配列を2つに分割し、それぞれを再帰的に整列した後、2つの整列済み配列を併合（マージ）する分割統治法のアルゴリズムです。最良・平均・最悪の全てのケースでO(n log n)の計算量を保証し、安定ソートです。追加メモリがO(n)必要ですが、大規模データや外部ソート（ディスクを使用）に適しています。"
        },
        {
          "type": "example",
          "title": "マージソートの具体例：昇順に整列",
          "content": "配列 [5, 2, 8, 1, 9, 3] を昇順に整列します。\n\n【分割フェーズ（配列を要素数1まで分割）】\n          [5, 2, 8, 1, 9, 3]\n          /               \\\n    [5, 2, 8]           [1, 9, 3]\n    /       \\           /       \\\n  [5, 2]    [8]      [1, 9]    [3]\n  /   \\               /   \\\n[5]   [2]           [1]   [9]\n\n【併合フェーズ（2つの整列済み配列をマージ）】\n[5]と[2]をマージ → [2, 5]\n[2, 5]と[8]をマージ → [2, 5, 8]\n\n[1]と[9]をマージ → [1, 9]\n[1, 9]と[3]をマージ → [1, 3, 9]\n\n[2, 5, 8]と[1, 3, 9]をマージ → [1, 2, 3, 5, 8, 9]\n\n→ 整列完了"
        },
        {
          "type": "example",
          "title": "マージ処理の詳細（2つの整列済み配列の併合）",
          "content": "2つの整列済み配列 [2, 5, 8] と [1, 3, 9] をマージして、[1, 2, 3, 5, 8, 9] を作成します。\n\n【初期状態】\n左配列: [2, 5, 8]、左ポインタ(L) = 0\n右配列: [1, 3, 9]、右ポインタ(R) = 0\n結果配列: []、結果ポインタ(M) = 0\n\n【マージ処理】\n①L=2、R=1 → 1 < 2 → 結果配列に1を追加 → R++\n  結果: [1]、L=0、R=1\n\n②L=2、R=3 → 2 < 3 → 結果配列に2を追加 → L++\n  結果: [1, 2]、L=1、R=1\n\n③L=5、R=3 → 3 < 5 → 結果配列に3を追加 → R++\n  結果: [1, 2, 3]、L=1、R=2\n\n④L=5、R=9 → 5 < 9 → 結果配列に5を追加 → L++\n  結果: [1, 2, 3, 5]、L=2、R=2\n\n⑤L=8、R=9 → 8 < 9 → 結果配列に8を追加 → L++\n  結果: [1, 2, 3, 5, 8]、L=3（左配列の終端）、R=2\n\n⑥左配列が終了 → 右配列の残り [9] を結果配列にコピー\n  結果: [1, 2, 3, 5, 8, 9]\n\n→ マージ完了\n\n【比較回数】\nマージで5回の比較（n₁ + n₂ - 1 = 3 + 3 - 1 = 5回）"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "マージソートの特徴",
          "content": "利点：①常にO(n log n)の計算量（最悪ケースでも高速）、②安定ソート（同じ値の順序が保たれる）、③並列化が容易、④外部ソート（ディスク使用）に適している\n\n欠点：①追加メモリO(n)が必要、②小規模データではオーバーヘッドが大きい、③キャッシュ効率がクイックソートより劣る\n\n実用例：Pythonの標準ソート（Timsort、マージソートと挿入ソートのハイブリッド）、Javaのコレクションソート（安定ソート）、大規模データの外部ソート\n\n最適化：①小規模データ（n < 10）は挿入ソートに切り替え、②自然な連続部分（既に整列済みの部分）を利用（Timsort）"
        },
        {
          "type": "table",
          "headers": ["段階", "処理", "計算量", "説明"],
          "rows": [
            ["分割", "配列を2つに分割（再帰）", "O(log n)", "要素数1まで分割（深さlog n）"],
            ["併合", "2つの整列済み配列をマージ", "O(n)", "各要素を1回ずつ比較"],
            ["全体", "分割 × 併合", "O(n log n)", "各層でn回の比較、log n層"]
          ]
        }
      ]
    },
    {
      "id": 5,
      "title": "ヒープソートと整列アルゴリズムの比較",
      "sections": [
        {
          "type": "text",
          "content": "**ヒープソート**は、ヒープ（完全2分木の一種）を使用した整列アルゴリズムです。まず配列をヒープ構造に変換（ヒープ化）し、ヒープの根（最大値または最小値）を取り出して配列の末尾に配置する処理を繰り返します。計算量が常にO(n log n)で、追加メモリがO(1)と空間効率が優れています。不安定ソートです。"
        },
        {
          "type": "example",
          "title": "ヒープソートの具体例：昇順に整列",
          "content": "配列 [5, 2, 8, 1, 9] を昇順に整列します。最大ヒープ（親 > 子）を使用します。\n\n【フェーズ1：ヒープ化（配列を最大ヒープに変換）】\n初期配列: [5, 2, 8, 1, 9]\n\n①配列をヒープ構造として見る（完全2分木）\n       5\n     /   \\\n    2     8\n   / \\\n  1   9\n\n②最大ヒープの条件を満たすように調整\n  - ノード2の子: [1, 9] → 9 > 2 なので、2と9を交換\n       5\n     /   \\\n    9     8\n   / \\\n  1   2\n  配列: [5, 9, 8, 1, 2]\n\n  - ルートノード5の子: [9, 8] → 9 > 5 なので、5と9を交換\n       9\n     /   \\\n    5     8\n   / \\\n  1   2\n  配列: [9, 5, 8, 1, 2]\n\n  - ノード5の子: [1, 2] → 5 > 1, 5 > 2 なので調整不要\n\n→ 最大ヒープ完成: [9, 5, 8, 1, 2]\n\n【フェーズ2：整列（ルートを取り出して末尾に配置）】\n①ルート9を取り出し、末尾の2と交換 → [2, 5, 8, 1, | 9]\n  ヒープサイズを1減らす → [2, 5, 8, 1]\n  ヒープを再構築（2を下に移動）\n       8\n     /   \\\n    5     2\n   /\n  1\n  配列: [8, 5, 2, 1, | 9]\n\n②ルート8を取り出し、末尾の1と交換 → [1, 5, 2, | 8, 9]\n  ヒープサイズを1減らす → [1, 5, 2]\n  ヒープを再構築\n       5\n     /   \\\n    1     2\n  配列: [5, 1, 2, | 8, 9]\n\n③ルート5を取り出し、末尾の2と交換 → [2, 1, | 5, 8, 9]\n  ヒープサイズを1減らす → [2, 1]\n  ヒープを再構築\n       2\n     /\n    1\n  配列: [2, 1, | 5, 8, 9]\n\n④ルート2を取り出し、末尾の1と交換 → [1, | 2, 5, 8, 9]\n  ヒープサイズを1減らす → [1]\n\n→ 整列完了: [1, 2, 5, 8, 9]"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "ヒープソートの特徴",
          "content": "利点：①常にO(n log n)の計算量（最悪ケースでも高速）、②追加メモリO(1)（インプレースソート）、③優先度付きキューの実装に利用\n\n欠点：①不安定ソート、②キャッシュ効率が悪い（メモリアクセスがランダム）、③実装が複雑\n\n実用例：優先度付きキュー（ヒープ構造）、イントロソート（クイックソートの最悪ケース対策としてヒープソートに切り替え）、組み込みシステム（メモリ制約がある環境）"
        },
        {
          "type": "table",
          "headers": ["アルゴリズム", "計算量", "空間計算量", "安定性", "適した用途"],
          "rows": [
            ["バブルソート", "O(n²)", "O(1)", "安定", "教育用（小規模データ）"],
            ["選択ソート", "O(n²)", "O(1)", "不安定", "交換回数最小化"],
            ["挿入ソート", "O(n²)", "O(1)", "安定", "ほぼ整列済み、小規模データ"],
            ["クイックソート", "O(n log n)", "O(log n)", "不安定", "平均的に最速、実用的"],
            ["マージソート", "O(n log n)", "O(n)", "安定", "安定ソート必須、大規模データ"],
            ["ヒープソート", "O(n log n)", "O(1)", "不安定", "メモリ制約、最悪ケース対策"]
          ]
        },
        {
          "type": "example",
          "title": "整列アルゴリズムの選択基準",
          "content": "【データサイズと要件による選択】\n\n①小規模データ（n < 50）\n→ 挿入ソート\n理由: シンプル、オーバーヘッドが小さい、ほぼ整列済みならO(n)\n\n②中～大規模データ、平均的に高速\n→ クイックソート\n理由: 平均O(n log n)、キャッシュ効率が良い、実用的に最速\n\n③安定ソートが必須\n→ マージソート\n理由: 安定、常にO(n log n)、並列化が容易\n例: 複数キーによる整列（まず名前でソート、次に年齢でソート）\n\n④メモリ制約が厳しい\n→ ヒープソート\n理由: 追加メモリO(1)、常にO(n log n)\n例: 組み込みシステム、大規模データ（メモリ節約）\n\n⑤最悪ケースO(n²)を回避したい\n→ マージソートまたはヒープソート\n理由: 常にO(n log n)を保証\n例: リアルタイムシステム（処理時間が予測可能）\n\n【実用的なハイブリッドアルゴリズム】\n\n①イントロソート（C++ std::sort）\n→ クイックソート + ヒープソート + 挿入ソート\n流れ: クイックソート → 再帰が深くなったらヒープソート → 小規模データは挿入ソート\n利点: クイックソートの平均的な速さ + 最悪ケース対策 + 小規模データの最適化\n\n②Timsort（Python、Java）\n→ マージソート + 挿入ソート\n流れ: 自然な連続部分を検出 → 挿入ソートで小規模データを整列 → マージソートで併合\n利点: 安定ソート + ほぼ整列済みのデータに高速 + 実用的なデータに最適化"
        },
        {
          "type": "highlight",
          "icon": "📌",
          "title": "安定性の重要性",
          "content": "**安定ソート**とは、同じ値を持つ要素の元の順序が保たれるソートアルゴリズムです。\n\n例: 学生データを「まず学年でソート、次に成績でソート」する場合\n初期データ: [(1年, 80点, 太郎), (2年, 90点, 花子), (1年, 80点, 次郎)]\n\n①学年でソート（安定ソート）\n→ [(1年, 80点, 太郎), (1年, 80点, 次郎), (2年, 90点, 花子)]\n\n②成績でソート（安定ソート）\n→ [(1年, 80点, 太郎), (1年, 80点, 次郎), (2年, 90点, 花子)]\n→ 太郎と次郎の順序が保たれている（同じ80点でも、元の順序を維持）\n\nもし不安定ソートを使うと、太郎と次郎の順序が入れ替わる可能性があります。\n\n安定ソート: バブルソート、挿入ソート、マージソート\n不安定ソート: 選択ソート、クイックソート、ヒープソート"
        }
      ]
    }
  ]
}
