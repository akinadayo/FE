{
  "topicId": "tech-4-3-3",
  "title": "探索アルゴリズム",
  "pages": [
    {
      "id": 1,
      "title": "探索アルゴリズムの基礎と線形探索",
      "sections": [
        {
          "type": "text",
          "content": "**探索アルゴリズム（Search Algorithm）**とは、データの集合の中から、目的のデータを見つけ出すアルゴリズムです。探索は、コンピュータプログラムで頻繁に使用される基本操作の1つです（例: データベースから顧客情報を検索、配列から特定の値を探す）。探索アルゴリズムには、①**線形探索（逐次探索）**：データを先頭から順番に調べる、②**2分探索（二分探索）**：整列済みデータを2分割しながら探す、③**ハッシュ探索**：ハッシュ関数でデータの位置を計算して探す、④**木探索**：木構造をたどって探す、の4種類があります。それぞれの探索方法は、データの状態（整列済みか未整列か）やデータ構造（配列、木）によって使い分けます。"
        },
        {
          "type": "table",
          "headers": ["探索方法", "前提条件", "平均計算量", "特徴"],
          "rows": [
            ["線形探索", "なし（未整列でもOK）", "O(n)", "シンプル、全データを調べる可能性あり"],
            ["2分探索", "整列済み", "O(log n)", "高速、データが整列済みである必要"],
            ["ハッシュ探索", "ハッシュテーブル", "O(1)", "最高速、衝突処理が必要"],
            ["木探索（2分探索木）", "2分探索木", "O(log n)", "動的データに適している"]
          ]
        },
        {
          "type": "text",
          "content": "**線形探索（Linear Search、逐次探索）**とは、配列の先頭から順番に、目的のデータと一致するかを調べていく探索方法です。データが整列されている必要はなく、最もシンプルな探索方法です。線形探索のアルゴリズムは、①配列の先頭（インデックス0）から順番に、目的の値と比較、②一致したら、そのインデックスを返す、③配列の最後まで調べても見つからなかったら、「見つからない」を返す、の3ステップです。"
        },
        {
          "type": "example",
          "title": "線形探索の具体例：配列から値を探す",
          "content": "【問題】\n次の配列から、値23を線形探索で探してください。\n配列: [15, 8, 23, 42, 5, 31, 17]\n\n【手順】\n①インデックス0（値15）と23を比較 → 不一致\n②インデックス1（値8）と23を比較 → 不一致\n③インデックス2（値23）と23を比較 → 一致！\n→ 結果: インデックス2で見つかった（比較回数3回）\n\n【別の例: 見つからない場合】\n配列から値99を探す場合:\n①インデックス0（値15）と99を比較 → 不一致\n②インデックス1（値8）と99を比較 → 不一致\n③インデックス2（値23）と99を比較 → 不一致\n④インデックス3（値42）と99を比較 → 不一致\n⑤インデックス4（値5）と99を比較 → 不一致\n⑥インデックス5（値31）と99を比較 → 不一致\n⑦インデックス6（値17）と99を比較 → 不一致\n→ 結果: 見つからない（比較回数7回、配列の全要素を調べた）"
        },
        {
          "type": "example",
          "title": "線形探索のプログラム（疑似コード）",
          "content": "```python\ndef linear_search(arr, target):\n    \"\"\"\n    線形探索（逐次探索）\n    引数:\n        arr: 探索対象の配列\n        target: 探したい値\n    戻り値:\n        見つかった場合: そのインデックス\n        見つからない場合: -1\n    \"\"\"\n    # 配列の先頭から順番に調べる\n    for i in range(len(arr)):\n        if arr[i] == target:  # 一致したら\n            return i  # インデックスを返す\n    # 最後まで見つからなかったら\n    return -1\n\n# 使用例\narr = [15, 8, 23, 42, 5, 31, 17]\nresult = linear_search(arr, 23)\nprint(f\"インデックス: {result}\")  # 出力: インデックス: 2\n\nresult = linear_search(arr, 99)\nprint(f\"インデックス: {result}\")  # 出力: インデックス: -1（見つからない）\n```"
        },
        {
          "type": "table",
          "headers": ["項目", "線形探索の特性"],
          "rows": [
            ["前提条件", "なし（データが未整列でもOK）"],
            ["最良の場合の比較回数", "1回（先頭にある場合）"],
            ["最悪の場合の比較回数", "n回（最後にある、または見つからない場合）"],
            ["平均比較回数", "n/2回"],
            ["時間計算量", "O(n)"],
            ["利点", "シンプル、データが未整列でも使える"],
            ["欠点", "データ数が多いと遅い"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "線形探索の計算量",
          "content": "線形探索の平均計算量はO(n)です。データ数がnの場合、平均してn/2回の比較が必要です（最良の場合は1回、最悪の場合はn回）。例えば、n=1,000の配列では、平均500回の比較が必要で、n=1,000,000の配列では、平均500,000回の比較が必要です。データ数が多いと、線形探索は非効率になるため、データが整列済みの場合は2分探索を使う方が効率的です。"
        }
      ]
    },
    {
      "id": 2,
      "title": "2分探索（二分探索）の原理と手順",
      "sections": [
        {
          "type": "text",
          "content": "**2分探索（Binary Search、二分探索）**とは、**整列済みの配列**に対して、配列を2分割しながら探索する方法です。2分探索は、線形探索より圧倒的に高速ですが、データが整列されている必要があります。2分探索のアルゴリズムは、①配列の中央の要素と目的の値を比較、②一致したら、そのインデックスを返す、③目的の値が中央の要素より小さい場合 → 左半分を探索（右半分は除外）、④目的の値が中央の要素より大きい場合 → 右半分を探索（左半分は除外）、⑤①～④を繰り返す、⑥探索範囲がなくなったら「見つからない」を返す、の手順です。"
        },
        {
          "type": "example",
          "title": "2分探索の具体例：整列済み配列から値を探す",
          "content": "【問題】\n次の整列済み配列から、値23を2分探索で探してください。\n配列: [5, 8, 15, 17, 23, 31, 42]（昇順に整列済み）\nインデックス: 0, 1, 2, 3, 4, 5, 6\n\n【手順】\n①探索範囲: インデックス0～6（全体）\n  中央のインデックス: (0 + 6) ÷ 2 = 3\n  中央の値: 17\n  17 < 23（目的の値）→ 右半分を探索（左半分は除外）\n\n②探索範囲: インデックス4～6（右半分）\n  中央のインデックス: (4 + 6) ÷ 2 = 5\n  中央の値: 31\n  31 > 23（目的の値）→ 左半分を探索（右半分は除外）\n\n③探索範囲: インデックス4～4（中央の5の左側）\n  中央のインデックス: (4 + 4) ÷ 2 = 4\n  中央の値: 23\n  23 == 23（目的の値）→ 一致！\n\n→ 結果: インデックス4で見つかった（比較回数3回）\n\n【線形探索との比較】\nもし線形探索で23を探すと、先頭から順番に調べるため、比較回数は5回（0, 1, 2, 3, 4）。2分探索では3回で済むため、高速です。"
        },
        {
          "type": "example",
          "title": "2分探索のプログラム（疑似コード）",
          "content": "```python\ndef binary_search(arr, target):\n    \"\"\"\n    2分探索（二分探索）\n    引数:\n        arr: 整列済みの配列（昇順）\n        target: 探したい値\n    戻り値:\n        見つかった場合: そのインデックス\n        見つからない場合: -1\n    \"\"\"\n    left = 0  # 探索範囲の左端\n    right = len(arr) - 1  # 探索範囲の右端\n    \n    while left <= right:  # 探索範囲がある限り繰り返す\n        mid = (left + right) // 2  # 中央のインデックス\n        \n        if arr[mid] == target:  # 中央の値が目的の値と一致\n            return mid  # インデックスを返す\n        elif arr[mid] < target:  # 目的の値が中央より大きい\n            left = mid + 1  # 右半分を探索（左半分を除外）\n        else:  # 目的の値が中央より小さい\n            right = mid - 1  # 左半分を探索（右半分を除外）\n    \n    # 探索範囲がなくなった（見つからない）\n    return -1\n\n# 使用例\narr = [5, 8, 15, 17, 23, 31, 42]  # 整列済み\nresult = binary_search(arr, 23)\nprint(f\"インデックス: {result}\")  # 出力: インデックス: 4\n\nresult = binary_search(arr, 99)\nprint(f\"インデックス: {result}\")  # 出力: インデックス: -1（見つからない）\n```"
        },
        {
          "type": "table",
          "headers": ["項目", "2分探索の特性"],
          "rows": [
            ["前提条件", "データが整列済みである必要（昇順または降順）"],
            ["最良の場合の比較回数", "1回（中央にある場合）"],
            ["最悪の場合の比較回数", "log₂ n回（見つからない場合）"],
            ["平均比較回数", "log₂ n回"],
            ["時間計算量", "O(log n)"],
            ["利点", "高速（線形探索よりはるかに速い）"],
            ["欠点", "データが整列済みである必要がある"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "2分探索の計算量と効率",
          "content": "2分探索の平均計算量はO(log n)です。データ数がnの場合、最大でlog₂ n回の比較で済みます。例えば、n=1,000の配列では、最大10回の比較で済みます（2¹⁰=1,024）。n=1,000,000の配列でも、最大20回の比較で済みます（2²⁰=1,048,576）。線形探索では平均500,000回の比較が必要なので、2分探索は圧倒的に高速です。ただし、データが整列済みである必要があるため、データの整列にO(n log n)の時間がかかる点に注意が必要です（整列アルゴリズム: クイックソート、マージソートなど）。"
        }
      ]
    },
    {
      "id": 3,
      "title": "ハッシュ探索の原理と衝突処理",
      "sections": [
        {
          "type": "text",
          "content": "**ハッシュ探索（Hash Search）**とは、**ハッシュ関数**を使ってデータの格納位置を計算し、高速に探索する方法です。ハッシュ探索では、データを**ハッシュテーブル（配列）**に格納し、ハッシュ関数でキー（例: 社員番号）から配列のインデックスを計算します。ハッシュ探索の流れは、①データを格納する際、キーをハッシュ関数に渡し、インデックスを計算、②計算したインデックスの位置にデータを格納、③データを探索する際、キーをハッシュ関数に渡し、インデックスを計算、④計算したインデックスの位置からデータを取得、の手順です。理想的には、ハッシュ関数で一意のインデックスが得られれば、O(1)（定数時間）で探索できます。"
        },
        {
          "type": "example",
          "title": "ハッシュ探索の具体例：社員番号から社員情報を検索",
          "content": "【前提】\n社員情報をハッシュテーブル（配列）に格納します。\nハッシュテーブルのサイズ: 10（インデックス0～9）\nハッシュ関数: h(社員番号) = 社員番号 mod 10（社員番号を10で割った余り）\n\n【データの格納】\n社員A: 社員番号1025 → h(1025) = 1025 mod 10 = 5 → インデックス5に格納\n社員B: 社員番号2043 → h(2043) = 2043 mod 10 = 3 → インデックス3に格納\n社員C: 社員番号3017 → h(3017) = 3017 mod 10 = 7 → インデックス7に格納\n\nハッシュテーブル:\nインデックス: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nデータ:      [-, -, -, B, -, A, -, C, -, -]\n\n【データの探索】\n社員番号2043の社員情報を探す:\n①ハッシュ関数でインデックスを計算: h(2043) = 2043 mod 10 = 3\n②インデックス3の位置からデータを取得 → 社員B\n→ 比較回数: 1回（O(1)、高速！）\n\n【線形探索との比較】\nもし線形探索で社員番号2043を探すと、配列を先頭から順番に調べるため、比較回数は最悪でn回（社員数）。ハッシュ探索では1回で済むため、圧倒的に高速です。"
        },
        {
          "type": "text",
          "content": "**衝突（Collision）**とは、異なるキーに対して、ハッシュ関数が同じインデックスを返すことです。例えば、社員番号1025と2025は、どちらもh(x) = x mod 10 = 5となり、インデックス5に格納されます。衝突が発生すると、同じ位置に2つのデータを格納できないため、衝突を解決する必要があります。衝突の解決方法には、①**チェイン法（連鎖法）**：同じインデックスに複数のデータをリストで格納、②**オープンアドレス法**：衝突した場合、次の空いている位置に格納、の2種類があります。"
        },
        {
          "type": "example",
          "title": "衝突の解決方法：チェイン法とオープンアドレス法",
          "content": "【チェイン法（連鎖法）】\n同じインデックスに複数のデータを、連結リストで格納します。\n\n例: 社員番号1025と2025を格納\n①社員A（1025）: h(1025) = 5 → インデックス5に格納\n②社員D（2025）: h(2025) = 5 → インデックス5に衝突！ → インデックス5のリストに追加\n\nインデックス5: [社員A（1025）] → [社員D（2025）]（連結リスト）\n\n探索時: インデックス5のリストを先頭から順番に調べる（線形探索）\n→ リストの長さがmの場合、比較回数はO(m)\n\n【オープンアドレス法（線形探査法）】\n衝突した場合、次の空いている位置（インデックス+1、+2、...）に格納します。\n\n例: 社員番号1025と2025を格納\n①社員A（1025）: h(1025) = 5 → インデックス5に格納\n②社員D（2025）: h(2025) = 5 → インデックス5に衝突！ → 次の空いている位置を探す\n  - インデックス6を確認 → 空いている → インデックス6に格納\n\nハッシュテーブル:\nインデックス: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nデータ:      [-, -, -, B, -, A, D, C, -, -]\n\n探索時: h(2025) = 5 → インデックス5を確認 → 社員Aで不一致 → インデックス6を確認 → 社員D（一致）\n→ 比較回数: 2回"
        },
        {
          "type": "table",
          "headers": ["項目", "ハッシュ探索の特性"],
          "rows": [
            ["前提条件", "ハッシュテーブル（配列）が必要"],
            ["衝突がない場合の比較回数", "1回"],
            ["衝突がある場合の比較回数", "O(m)（mは衝突したデータ数）"],
            ["平均時間計算量", "O(1)（衝突が少ない場合）"],
            ["最悪時間計算量", "O(n)（全てのデータが衝突した場合）"],
            ["利点", "高速（平均O(1)）"],
            ["欠点", "ハッシュテーブルのサイズが必要、衝突処理が必要"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "ハッシュ関数の設計と負荷率",
          "content": "ハッシュ探索の性能は、ハッシュ関数の設計に大きく依存します。良いハッシュ関数は、①キーを均等に分散させる（衝突を減らす）、②計算が高速、の2つの条件を満たします。また、**負荷率（Load Factor）**が重要です。負荷率 = データ数 ÷ ハッシュテーブルのサイズ。負荷率が1.0を超えると、衝突が多発し、性能が低下します。一般的には、負荷率を0.7以下に保つことが推奨されます（例: ハッシュテーブルのサイズ10に対して、データ数は7以下）。負荷率が高くなったら、ハッシュテーブルのサイズを拡大し、全てのデータを再配置（リハッシュ）します。"
        }
      ]
    },
    {
      "id": 4,
      "title": "木探索（深さ優先探索と幅優先探索）",
      "sections": [
        {
          "type": "text",
          "content": "**木探索（Tree Search）**とは、木構造（Tree）のデータを探索する方法です。木構造は、ノード（節点）とエッジ（辺）で構成され、階層的なデータ（例: ファイルシステムのディレクトリ、組織図）を表現するのに適しています。代表的な木構造として、**2分探索木（Binary Search Tree）**があります。2分探索木では、各ノードが最大2つの子ノード（左の子、右の子）を持ち、左の子のキー < 親のキー < 右の子のキー、という関係が成り立ちます。2分探索木の探索は、①ルート（根）から開始、②目的の値と現在のノードのキーを比較、③一致したら終了、④目的の値が小さい場合 → 左の子に移動、⑤目的の値が大きい場合 → 右の子に移動、⑥②～⑤を繰り返す、の手順です。"
        },
        {
          "type": "example",
          "title": "2分探索木での探索の具体例",
          "content": "【2分探索木の構造】\n次のような2分探索木があるとします。\n```\n       20\n      /  \\\n     10   30\n    / \\   / \\\n   5  15 25  35\n```\n\n各ノードの関係:\n- ノード20: 左の子10 < 20 < 右の子30\n- ノード10: 左の子5 < 10 < 右の子15\n- ノード30: 左の子25 < 30 < 右の子35\n\n【値25を探索】\n①ルート（20）から開始: 25 > 20 → 右の子（30）に移動\n②ノード30: 25 < 30 → 左の子（25）に移動\n③ノード25: 25 == 25 → 一致！\n→ 比較回数: 3回\n\n【値35を探索】\n①ルート（20）から開始: 35 > 20 → 右の子（30）に移動\n②ノード30: 35 > 30 → 右の子（35）に移動\n③ノード35: 35 == 35 → 一致！\n→ 比較回数: 3回\n\n【2分探索木の利点】\n平均的には、探索にO(log n)の時間がかかります（木の高さがlog n）。ただし、木のバランスが悪い（一直線になる）と、O(n)になります。"
        },
        {
          "type": "text",
          "content": "木探索には、探索の順序によって、①**深さ優先探索（DFS: Depth-First Search）**：できるだけ深く（下に）探索してから、隣の枝を探索、②**幅優先探索（BFS: Breadth-First Search）**：同じ階層（同じ深さ）のノードを全て探索してから、次の階層を探索、の2種類があります。深さ優先探索は**スタック**（またはデータ構造、再帰）を使い、幅優先探索は**キュー**を使います。"
        },
        {
          "type": "example",
          "title": "深さ優先探索（DFS）と幅優先探索（BFS）の具体例",
          "content": "【木の構造】\n次のような木があるとします。\n```\n       A\n      / \\\n     B   C\n    / \\   \\\n   D   E   F\n```\n\n【深さ優先探索（DFS）】\n探索順序: A → B → D → E → C → F\n\n手順:\n①ルートA から開始\n②Aの左の子B に移動（できるだけ深く探索）\n③Bの左の子D に移動\n④Dに子がない → Bに戻る\n⑤Bの右の子E に移動\n⑥Eに子がない → Bに戻る → Aに戻る\n⑦Aの右の子C に移動\n⑧Cの右の子F に移動\n⑨Fに子がない → 終了\n\n【幅優先探索（BFS）】\n探索順序: A → B → C → D → E → F\n\n手順:\n①ルートA から開始（第1階層）\n②Aの子B、C を探索（第2階層）\n③Bの子D、E を探索（第3階層）\n④Cの子F を探索（第3階層）\n⑤全て探索済み → 終了\n\n【使い分け】\n- DFS: 迷路の探索、ファイルシステムの全検索（ディレクトリを深く探索）\n- BFS: 最短経路の探索（同じ階層を先に探索）、SNSの友達の友達を探す"
        },
        {
          "type": "example",
          "title": "深さ優先探索（DFS）のプログラム（疑似コード、再帰）",
          "content": "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None  # 左の子\n        self.right = None  # 右の子\n\ndef dfs(node):\n    \"\"\"\n    深さ優先探索（DFS）- 再帰\n    引数:\n        node: 現在のノード\n    \"\"\"\n    if node is None:  # ノードがない場合（葉の子）\n        return\n    \n    print(node.value)  # 現在のノードを処理（訪問）\n    dfs(node.left)  # 左の子を探索（再帰）\n    dfs(node.right)  # 右の子を探索（再帰）\n\n# 木の構築\nroot = Node('A')\nroot.left = Node('B')\nroot.right = Node('C')\nroot.left.left = Node('D')\nroot.left.right = Node('E')\nroot.right.right = Node('F')\n\n# 深さ優先探索を実行\ndfs(root)  # 出力: A B D E C F\n```"
        },
        {
          "type": "example",
          "title": "幅優先探索（BFS）のプログラム（疑似コード、キュー）",
          "content": "```python\nfrom collections import deque\n\ndef bfs(root):\n    \"\"\"\n    幅優先探索（BFS）- キューを使用\n    引数:\n        root: ルートノード\n    \"\"\"\n    if root is None:\n        return\n    \n    queue = deque([root])  # キューにルートを追加\n    \n    while queue:  # キューが空になるまで繰り返す\n        node = queue.popleft()  # キューの先頭を取り出す\n        print(node.value)  # 現在のノードを処理（訪問）\n        \n        # 子をキューに追加（左の子、右の子の順）\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n\n# 木の構築（上記と同じ）\nroot = Node('A')\nroot.left = Node('B')\nroot.right = Node('C')\nroot.left.left = Node('D')\nroot.left.right = Node('E')\nroot.right.right = Node('F')\n\n# 幅優先探索を実行\nbfs(root)  # 出力: A B C D E F\n```"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "木探索の計算量",
          "content": "2分探索木の探索の平均計算量はO(log n)です（木の高さがlog n）。ただし、木のバランスが悪い（一直線になる）と、最悪O(n)になります。バランスを保つために、AVL木、赤黒木などの自己平衡木が使われます。深さ優先探索（DFS）と幅優先探索（BFS）は、どちらも全てのノードを訪問する場合、時間計算量はO(n)です（nはノード数）。空間計算量は、DFSがO(h)（hは木の高さ、スタックの深さ）、BFSがO(w)（wは木の最大幅、キューのサイズ）です。"
        }
      ]
    },
    {
      "id": 5,
      "title": "探索アルゴリズムの比較と使い分け",
      "sections": [
        {
          "type": "text",
          "content": "探索アルゴリズムは、データの状態（整列済みか未整列か）、データ構造（配列、木、ハッシュテーブル）、探索の頻度によって使い分けます。それぞれのアルゴリズムには利点と欠点があり、適切な場面で使用することが重要です。"
        },
        {
          "type": "table",
          "headers": ["探索方法", "前提条件", "平均計算量", "最悪計算量", "利点", "欠点"],
          "rows": [
            ["線形探索", "なし", "O(n)", "O(n)", "シンプル、未整列でもOK", "遅い（データ数が多いと）"],
            ["2分探索", "整列済み", "O(log n)", "O(log n)", "高速", "整列が必要"],
            ["ハッシュ探索", "ハッシュテーブル", "O(1)", "O(n)", "最高速", "衝突処理が必要、メモリ消費"],
            ["木探索（2分探索木）", "2分探索木", "O(log n)", "O(n)", "動的データに適している", "バランス調整が必要"]
          ]
        },
        {
          "type": "example",
          "title": "探索アルゴリズムの使い分けの具体例",
          "content": "【例1: 小規模なデータ、未整列】\nデータ: [15, 8, 23, 42, 5]（n=5、未整列）\n使う探索: 線形探索\n理由: データ数が少ないため、線形探索でも十分高速。整列のコスト（O(n log n)）を払うより、線形探索（O(n)）の方が効率的。\n\n【例2: 大規模なデータ、整列済み、探索頻度が高い】\nデータ: 1,000,000件の整列済み配列、1秒間に1,000回の探索\n使う探索: 2分探索\n理由: 整列済みなので2分探索が使える。探索頻度が高いため、高速な探索が必要。2分探索なら、最大20回の比較で済む（2²⁰=1,048,576）。\n\n【例3: 大規模なデータ、頻繁に追加・削除、探索頻度が超高い】\nデータ: 100,000件の社員データ、1秒間に10,000回の探索、頻繁に社員の追加・削除\n使う探索: ハッシュ探索\n理由: 探索頻度が超高いため、O(1)のハッシュ探索が最適。データが頻繁に変更されるが、ハッシュテーブルは動的に追加・削除できる。\n\n【例4: 階層構造のデータ、動的に変化】\nデータ: ファイルシステムのディレクトリ構造、頻繁にファイルの追加・削除\n使う探索: 木探索（2分探索木）\n理由: 階層構造のデータは木構造で表現するのが自然。動的にデータが変化するため、2分探索木（またはバランス木）が適している。"
        },
        {
          "type": "table",
          "headers": ["データ数", "線形探索", "2分探索", "ハッシュ探索"],
          "rows": [
            ["n=10", "平均5回", "最大4回", "平均1回"],
            ["n=100", "平均50回", "最大7回", "平均1回"],
            ["n=1,000", "平均500回", "最大10回", "平均1回"],
            ["n=10,000", "平均5,000回", "最大14回", "平均1回"],
            ["n=100,000", "平均50,000回", "最大17回", "平均1回"],
            ["n=1,000,000", "平均500,000回", "最大20回", "平均1回"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "探索回数の計算例（試験頻出）",
          "content": "【問題】\nn=1,000のデータから、線形探索と2分探索で、最悪の場合の比較回数を計算してください。\n\n【解答】\n①線形探索: 最悪の場合、配列の最後まで調べる → 比較回数 = n = 1,000回\n\n②2分探索: 最悪の場合、log₂ n回の比較が必要\n  log₂ 1,000 ≈ 9.97 → 切り上げて10回\n  （2¹⁰ = 1,024 > 1,000 なので、最大10回で探索できる）\n\n→ 2分探索は線形探索の100分の1の比較回数で済む！\n\n【別の例】\nn=16のデータで、2分探索の最悪の比較回数は？\nlog₂ 16 = 4 → 最悪4回\n（例: 16 → 8 → 4 → 2 → 1）"
        },
        {
          "type": "highlight",
          "icon": "📌",
          "title": "探索アルゴリズムの選択基準まとめ",
          "content": "①データが未整列 → 線形探索\n②データが整列済み、大規模 → 2分探索\n③探索頻度が超高い、メモリに余裕あり → ハッシュ探索\n④階層構造、動的に変化 → 木探索（2分探索木）\n⑤探索頻度が低い、データ数が少ない → 線形探索（シンプルで実装が楽）\n\n試験では、①各探索方法の前提条件、②計算量（平均、最悪）、③比較回数の計算、④適切な探索方法の選択、がよく出題されます。特に、2分探索の比較回数（log₂ n）の計算は頻出です。"
        }
      ]
    }
  ]
}
