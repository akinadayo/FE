{
  "topicId": "tech-4-3-5",
  "title": "アルゴリズムの計算量",
  "pages": [
    {
      "id": 1,
      "title": "計算量とは？時間計算量と空間計算量の基礎",
      "sections": [
        {
          "type": "text",
          "content": "**計算量（Computational Complexity）**とは、アルゴリズムが問題を解くために必要な「時間」や「メモリ」の量を評価する指標です。同じ問題を解く複数のアルゴリズムがある場合、計算量を比較することで、どのアルゴリズムが効率的かを判断できます。計算量には、①**時間計算量（Time Complexity）**：アルゴリズムの実行にかかる時間（処理ステップ数）、②**空間計算量（Space Complexity）**：アルゴリズムが使用するメモリの量、の2種類があります。基本情報技術者試験では、主に時間計算量が重要です。"
        },
        {
          "type": "table",
          "headers": ["計算量の種類", "評価対象", "具体例"],
          "rows": [
            ["時間計算量", "アルゴリズムの実行にかかる時間（処理ステップ数）", "n個のデータを線形探索する場合、最悪でn回の比較が必要 → O(n)"],
            ["空間計算量", "アルゴリズムが使用するメモリの量", "n個のデータをコピーして配列を作る場合、nバイトのメモリが必要 → O(n)"]
          ]
        },
        {
          "type": "text",
          "content": "**時間計算量**は、アルゴリズムが実行する「基本操作の回数」で評価します。基本操作とは、①変数の代入（a = 5）、②比較演算（if a > b）、③四則演算（a + b）、④配列へのアクセス（array[i]）、などです。例えば、n個のデータから最大値を見つけるアルゴリズムでは、n個のデータを順番に比較するため、比較演算の回数はn-1回です（時間計算量はO(n)）。時間計算量が小さいアルゴリズムほど、高速に動作します。"
        },
        {
          "type": "example",
          "title": "時間計算量の計算例：配列の最大値を求めるアルゴリズム",
          "content": "【アルゴリズム（疑似コード）】\n```\nmax = array[0]  // 1回（最初の要素を最大値とする）\nfor i = 1 to n-1:  // n-1回のループ\n    if array[i] > max:  // 比較演算（n-1回）\n        max = array[i]  // 代入（最悪の場合、n-1回）\nreturn max\n```\n\n【処理ステップ数の計算】\n①最初の代入：1回\n②ループ（n-1回）の中で、毎回比較演算：n-1回\n③代入（最悪の場合）：n-1回\n\n合計：1 + (n-1) + (n-1) = 2n - 1 回\n\nしかし、計算量の評価では、定数項（-1）や係数（2）は無視します（詳しくは次ページ）。よって、時間計算量は**O(n)**と表現します。データ数nが大きくなると、処理ステップ数はnに比例して増加します。\n\n例：\n- n=10のとき：約20ステップ\n- n=100のとき：約200ステップ\n- n=1000のとき：約2000ステップ\n\nnが10倍になると、処理ステップ数も約10倍になります。"
        },
        {
          "type": "text",
          "content": "**空間計算量**は、アルゴリズムが実行中に使用するメモリの量で評価します。例えば、①配列のコピーを作成する場合、元の配列と同じサイズのメモリが必要 → O(n)、②再帰呼び出しでスタックを使用する場合、再帰の深さに応じたメモリが必要 → O(n)（再帰の深さがnの場合）、③一時変数のみを使用する場合、データ数に関わらず一定のメモリ → O(1)、などです。空間計算量が小さいアルゴリズムほど、メモリ使用量が少なく、大規模なデータを扱えます。"
        },
        {
          "type": "example",
          "title": "空間計算量の計算例：配列の反転",
          "content": "【方法1：新しい配列を作成する場合（空間計算量 O(n)）】\n```\nreversed = new array[n]  // n個の要素を格納する配列を作成\nfor i = 0 to n-1:\n    reversed[i] = array[n-1-i]  // 元の配列の要素を逆順でコピー\nreturn reversed\n```\n新しい配列を作成するため、元の配列と同じサイズ（n個）のメモリが必要 → **空間計算量O(n)**\n\n【方法2：元の配列を直接入れ替える場合（空間計算量 O(1)）】\n```\nfor i = 0 to n/2:\n    temp = array[i]  // 一時変数（1個）\n    array[i] = array[n-1-i]\n    array[n-1-i] = temp\n```\n一時変数temp（1個）のみを使用するため、データ数に関わらず一定のメモリ → **空間計算量O(1)**\n\n方法2の方が、メモリ使用量が少なく効率的です。ただし、元の配列が破壊される（元の順序が失われる）ため、状況に応じて選択します。"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "計算量の重要性",
          "content": "計算量は、アルゴリズムの効率を評価する最も重要な指標です。例えば、100万件のデータを処理する場合、O(n)のアルゴリズムは100万回の処理で済みますが、O(n²)のアルゴリズムは1兆回（100万×100万）の処理が必要で、実行時間が約100万倍になります。データ数が大きい場合、計算量の差が実行時間に大きく影響します。そのため、アルゴリズムを選択・設計する際は、計算量を必ず考慮する必要があります。"
        }
      ]
    },
    {
      "id": 2,
      "title": "オーダ記法（ビッグオー記法）の基礎",
      "sections": [
        {
          "type": "text",
          "content": "**オーダ記法（ビッグオー記法、Big-O Notation）**とは、アルゴリズムの計算量を表記する方法です。O(n)、O(log n)、O(n²)のように、**O(式)**の形で表現します。オーダ記法では、データ数nが十分に大きいときの計算量の「増加傾向」を表現します。具体的には、①**定数項を無視**：2n + 10 → O(n)、②**係数を無視**：3n² + 5n + 2 → O(n²)、③**最も影響の大きい項のみを残す**：n² + n → O(n²)、というルールで単純化します。これにより、アルゴリズムの効率を直感的に比較できます。"
        },
        {
          "type": "table",
          "headers": ["処理ステップ数", "オーダ記法", "理由"],
          "rows": [
            ["5", "O(1)", "定数（データ数に関わらず一定）"],
            ["3n + 10", "O(n)", "係数（3）と定数項（10）を無視 → n"],
            ["n² + 5n + 2", "O(n²)", "最も影響の大きい項（n²）のみを残す → n²"],
            ["2n² + 3n log n", "O(n²)", "n²の方がn log nより増加が速い → n²"],
            ["log n + 100", "O(log n)", "定数項（100）を無視 → log n"]
          ]
        },
        {
          "type": "text",
          "content": "なぜ定数項や係数を無視するのでしょうか？それは、データ数nが十分に大きい場合、定数項や係数の影響は無視できるほど小さくなるためです。例えば、2つのアルゴリズムA（処理ステップ数：10n）とB（処理ステップ数：n²）を比較します。nが小さい場合（n=5）、A=50、B=25で、Bの方が速いです。しかし、nが大きい場合（n=1000）、A=10,000、B=1,000,000で、Aの方が圧倒的に速くなります。オーダ記法では、nが十分に大きいときの傾向を評価するため、係数（10）を無視してO(n) vs O(n²)と表現します。"
        },
        {
          "type": "example",
          "title": "オーダ記法の計算例：3重ループのアルゴリズム",
          "content": "【アルゴリズム（疑似コード）】\n```\nfor i = 0 to n-1:  // n回のループ\n    for j = 0 to n-1:  // n回のループ\n        for k = 0 to n-1:  // n回のループ\n            print(i, j, k)  // 1回の処理\n```\n\n【処理ステップ数の計算】\n①最も内側のループ（k）：n回\n②中間のループ（j）：n回 × n回（kのループ） = n²回\n③最も外側のループ（i）：n回 × n²回（jのループ） = n³回\n\n合計：n³回の処理\n\n【オーダ記法】\nO(n³)と表現します。\n\n例：\n- n=10のとき：1,000回の処理\n- n=100のとき：1,000,000回の処理\n- n=1000のとき：1,000,000,000回の処理（10億回）\n\nnが10倍になると、処理ステップ数は1000倍（10³倍）になります。O(n³)は非常に効率が悪く、大規模なデータには適しません。"
        },
        {
          "type": "table",
          "headers": ["ループ構造", "処理ステップ数", "オーダ記法"],
          "rows": [
            ["単一ループ（for i = 0 to n-1）", "n回", "O(n)"],
            ["2重ループ（for i... for j...）", "n²回", "O(n²)"],
            ["3重ループ（for i... for j... for k...）", "n³回", "O(n³)"],
            ["ループなし", "定数回", "O(1)"]
          ]
        },
        {
          "type": "highlight",
          "icon": "📌",
          "title": "オーダ記法の記述ルール",
          "content": "オーダ記法では、以下のルールで単純化します。\n\n①定数項を無視：\n  - n + 100 → O(n)\n  - n² + 50 → O(n²)\n  理由：nが十分に大きいとき、100や50は無視できる\n\n②係数を無視：\n  - 5n → O(n)\n  - 0.5n² → O(n²)\n  理由：nが十分に大きいとき、5倍や0.5倍の違いは「増加傾向」に影響しない\n\n③最も影響の大きい項のみを残す：\n  - n² + n + 1 → O(n²)\n  - n³ + n² + n → O(n³)\n  理由：nが十分に大きいとき、最も増加が速い項（n²やn³）が支配的になる\n\n例：3n² + 5n + 10 → O(n²)（n²が最も影響が大きい）"
        }
      ]
    },
    {
      "id": 3,
      "title": "主要なオーダと具体例（O(1)、O(log n)、O(n)、O(n log n)、O(n²)、O(2^n)）",
      "sections": [
        {
          "type": "text",
          "content": "アルゴリズムの計算量は、主に以下の6つのオーダに分類されます。効率の良い順（処理が速い順）に、**O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2^n)**です。データ数nが大きくなると、この差が顕著になります。以下、各オーダの特徴と具体例を説明します。"
        },
        {
          "type": "table",
          "headers": ["オーダ", "名称", "n=10", "n=100", "n=1000", "具体例"],
          "rows": [
            ["O(1)", "定数時間", "1", "1", "1", "配列の先頭要素へのアクセス（array[0]）"],
            ["O(log n)", "対数時間", "約3", "約7", "約10", "2分探索（ソート済み配列から探索）"],
            ["O(n)", "線形時間", "10", "100", "1000", "線形探索（配列の全要素を順番に確認）"],
            ["O(n log n)", "線形対数時間", "約30", "約664", "約10000", "マージソート、クイックソート（平均）"],
            ["O(n²)", "2次時間", "100", "10000", "1000000", "バブルソート、選択ソート、挿入ソート"],
            ["O(2^n)", "指数時間", "1024", "約10^30", "約10^301", "全探索（ビット全探索）、フィボナッチ数列（単純再帰）"]
          ]
        },
        {
          "type": "example",
          "title": "O(1) - 定数時間の例：配列の要素へのアクセス",
          "content": "【操作】\n配列の特定のインデックスの要素にアクセスする。\n\n【疑似コード】\n```\nvalue = array[5]  // インデックス5の要素を取得\n```\n\n【計算量の分析】\n配列のインデックス指定によるアクセスは、配列のサイズ（n）に関わらず、常に1回の操作で完了します。配列のサイズが10でも100でも1000でも、処理時間は変わりません。\n\n【時間計算量】\nO(1)（定数時間）\n\n【他の例】\n- 変数の代入（a = 5）\n- 四則演算（a + b）\n- 関数の呼び出し（単純な処理の場合）\n\nO(1)は最も効率の良い計算量で、どんなに大きなデータでも高速に動作します。"
        },
        {
          "type": "example",
          "title": "O(log n) - 対数時間の例：2分探索",
          "content": "【問題】\nソート済みの配列から、特定の値を探索する。\n\n【アルゴリズム（2分探索）】\n①配列の中央の要素と比較\n②探索値が中央より小さい → 左半分を探索\n③探索値が中央より大きい → 右半分を探索\n④見つかるまで①～③を繰り返す\n\n【疑似コード】\n```\nleft = 0\nright = n - 1\nwhile left <= right:\n    mid = (left + right) / 2\n    if array[mid] == target:\n        return mid  // 見つかった\n    else if array[mid] < target:\n        left = mid + 1  // 右半分を探索\n    else:\n        right = mid - 1  // 左半分を探索\nreturn -1  // 見つからなかった\n```\n\n【計算量の分析】\n毎回、探索範囲が半分になります。\n- 1回目：n個\n- 2回目：n/2個\n- 3回目：n/4個\n- k回目：n/(2^k)個\n\n探索範囲が1個になるまでの回数kは、n/(2^k) = 1 → 2^k = n → k = log₂ n（底が2の対数）\n\n【時間計算量】\nO(log n)（対数時間）\n\n例：\n- n=1000のとき、最悪で約10回の比較（2^10 = 1024）\n- n=100万のとき、最悪で約20回の比較（2^20 = 1,048,576）\n\nnが1000倍になっても、処理回数は約2倍にしかなりません。非常に効率的です。"
        },
        {
          "type": "example",
          "title": "O(n) - 線形時間の例：線形探索と配列の合計",
          "content": "【例1：線形探索】\n配列の全要素を順番に確認して、特定の値を探索する。\n```\nfor i = 0 to n-1:\n    if array[i] == target:\n        return i  // 見つかった\nreturn -1  // 見つからなかった\n```\n最悪の場合、n個全てを確認 → O(n)\n\n【例2：配列の全要素の合計】\n```\nsum = 0\nfor i = 0 to n-1:\n    sum = sum + array[i]\nreturn sum\n```\nn個の要素を全て加算 → O(n)\n\n【計算量の分析】\nデータ数nに比例して、処理ステップ数が増加します。\n- n=10のとき：10回の処理\n- n=100のとき：100回の処理\n- n=1000のとき：1000回の処理\n\nnが10倍になると、処理回数も10倍になります。\n\n【時間計算量】\nO(n)（線形時間）"
        },
        {
          "type": "example",
          "title": "O(n log n) - 線形対数時間の例：マージソート",
          "content": "【アルゴリズム（マージソート）】\n①配列を2つに分割\n②それぞれを再帰的にソート\n③ソート済みの2つの配列をマージ（統合）\n\n【計算量の分析】\n①分割の深さ：log₂ n回（毎回半分に分割）\n②各階層でのマージ処理：n回の比較\n③合計：log₂ n × n = n log n\n\n【時間計算量】\nO(n log n)（線形対数時間）\n\n例：\n- n=1000のとき：約10,000回の処理（1000 × 10）\n- n=100万のとき：約2000万回の処理（1,000,000 × 20）\n\nO(n²)のバブルソート（n=1000で100万回）と比較すると、約100倍高速です。\n\n【他の例】\n- クイックソート（平均）\n- ヒープソート"
        },
        {
          "type": "example",
          "title": "O(n²) - 2次時間の例：バブルソート",
          "content": "【アルゴリズム（バブルソート）】\n```\nfor i = 0 to n-1:  // 外側のループ（n回）\n    for j = 0 to n-2-i:  // 内側のループ（n-1回、n-2回、...）\n        if array[j] > array[j+1]:\n            swap(array[j], array[j+1])  // 隣接要素を交換\n```\n\n【計算量の分析】\n①外側のループ：n回\n②内側のループ：(n-1) + (n-2) + ... + 1 = n(n-1)/2 ≈ n²/2回\n③合計：約n²/2回 → 係数を無視してO(n²)\n\n【時間計算量】\nO(n²)（2次時間）\n\n例：\n- n=100のとき：約10,000回の処理\n- n=1000のとき：約1,000,000回の処理（100万回）\n\nnが10倍になると、処理回数は100倍（10²倍）になります。大規模なデータには不向きです。\n\n【他の例】\n- 選択ソート\n- 挿入ソート\n- 2重ループで全ペアを比較する処理"
        },
        {
          "type": "example",
          "title": "O(2^n) - 指数時間の例：フィボナッチ数列（単純再帰）",
          "content": "【問題】\nフィボナッチ数列の第n項を求める（F(n) = F(n-1) + F(n-2)、F(0)=0、F(1)=1）。\n\n【アルゴリズム（単純再帰）】\n```\nfunction fibonacci(n):\n    if n == 0:\n        return 0\n    else if n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n```\n\n【計算量の分析】\nfibonacci(n)を計算するために、fibonacci(n-1)とfibonacci(n-2)を呼び出します。\n- fibonacci(5)を計算する場合、fibonacci(4)とfibonacci(3)を計算\n- fibonacci(4)は、fibonacci(3)とfibonacci(2)を計算\n- この繰り返しで、呼び出し回数が指数的に増加\n\n呼び出し回数は約2^n回（正確には、約1.618^n回、黄金比）\n\n【時間計算量】\nO(2^n)（指数時間）\n\n例：\n- n=10のとき：約1,024回の呼び出し\n- n=20のとき：約104万回の呼び出し\n- n=30のとき：約10億回の呼び出し\n\nnが1増えるだけで、処理回数が約2倍になります。n=50以上は実用的に計算不可能です。\n\n【改善方法】\nメモ化（動的計画法）を使うと、O(n)に改善できます。"
        },
        {
          "type": "highlight",
          "icon": "📊",
          "title": "オーダの成長率の比較",
          "content": "各オーダの成長率（nが増加したときの処理ステップ数の増加）を比較すると、以下のようになります。\n\nデータ数n = 1000の場合：\n- O(1)：1回（一瞬）\n- O(log n)：約10回（一瞬）\n- O(n)：1,000回（数ミリ秒）\n- O(n log n)：約10,000回（数十ミリ秒）\n- O(n²)：1,000,000回（数秒）\n- O(2^n)：約10^301回（宇宙の年齢より長い）\n\nO(n²)以下のアルゴリズムは実用的ですが、O(2^n)のアルゴリズムは、nが少し大きくなると実行不可能になります。そのため、アルゴリズムを選択する際は、計算量を必ず考慮する必要があります。"
        }
      ]
    },
    {
      "id": 4,
      "title": "最良・平均・最悪ケースの計算量",
      "sections": [
        {
          "type": "text",
          "content": "アルゴリズムの計算量は、入力データの状態（並び順など）によって変わることがあります。そのため、計算量を3つのケースで評価します。①**最良ケース（Best Case）**：最も効率的に動作する入力データの場合、②**平均ケース（Average Case）**：様々な入力データの平均的な場合、③**最悪ケース（Worst Case）**：最も非効率に動作する入力データの場合、です。基本情報技術者試験では、主に**最悪ケース**の計算量が重要です（システムの性能を保証するため）。"
        },
        {
          "type": "table",
          "headers": ["ケース", "説明", "重要度"],
          "rows": [
            ["最良ケース", "最も効率的に動作する入力データの場合（例: すでにソート済みの配列）", "低（理想的すぎて実用的でない）"],
            ["平均ケース", "様々な入力データの平均的な場合（ランダムなデータ）", "中（実用的だが、計算が複雑）"],
            ["最悪ケース", "最も非効率に動作する入力データの場合（例: 逆順にソートされた配列）", "高（システムの性能を保証するため）"]
          ]
        },
        {
          "type": "example",
          "title": "線形探索の最良・平均・最悪ケース",
          "content": "【アルゴリズム（線形探索）】\n配列の先頭から順番に探索して、目的の値を見つける。\n```\nfor i = 0 to n-1:\n    if array[i] == target:\n        return i  // 見つかった\nreturn -1  // 見つからなかった\n```\n\n【最良ケース】\n探索値が配列の先頭（array[0]）にある場合、1回の比較で見つかる。\n時間計算量：**O(1)**\n\n【平均ケース】\n探索値が配列のどこかにある場合、平均で約n/2回の比較が必要。\n時間計算量：**O(n)**（係数1/2は無視）\n\n【最悪ケース】\n探索値が配列の最後（array[n-1]）にある、または見つからない場合、n回の比較が必要。\n時間計算量：**O(n)**\n\n例（n=100の配列）：\n- 最良ケース：1回の比較（array[0]に目的の値がある）\n- 平均ケース：約50回の比較\n- 最悪ケース：100回の比較（array[99]に目的の値がある、または見つからない）\n\nシステムの性能を保証するためには、最悪ケースO(n)を想定します。"
        },
        {
          "type": "example",
          "title": "クイックソートの最良・平均・最悪ケース",
          "content": "【アルゴリズム（クイックソート）】\n①ピボット（基準値）を選択\n②ピボットより小さい要素を左、大きい要素を右に分割\n③左右それぞれを再帰的にソート\n\n【最良ケース】\nピボットが毎回、配列を均等に2分割する場合（例: 中央値をピボットに選ぶ）。\n- 分割の深さ：log₂ n回\n- 各階層での処理：n回の比較\n- 時間計算量：**O(n log n)**\n\n【平均ケース】\nランダムなデータの場合、ピボットの選択がある程度均等になる。\n時間計算量：**O(n log n)**\n\n【最悪ケース】\nピボットが毎回、最小値または最大値になる場合（例: すでにソート済みの配列で、先頭をピボットに選ぶ）。\n- 分割の深さ：n回（毎回1個ずつ減る）\n- 各階層での処理：n, n-1, n-2, ..., 1回の比較\n- 時間計算量：**O(n²)**\n\n例（n=1000の配列）：\n- 最良・平均ケース：約10,000回の処理（1000 × 10）\n- 最悪ケース：約500,000回の処理（1000 × 1000 / 2）\n\n最悪ケースを避けるため、ピボットをランダムに選択する、または中央値を選択する改良版が使われます。"
        },
        {
          "type": "example",
          "title": "挿入ソートの最良・平均・最悪ケース",
          "content": "【アルゴリズム（挿入ソート）】\n配列の2番目以降の要素を、順番に「ソート済み部分」の適切な位置に挿入する。\n```\nfor i = 1 to n-1:  // 2番目以降の要素\n    key = array[i]\n    j = i - 1\n    while j >= 0 and array[j] > key:  // 挿入位置を探す\n        array[j+1] = array[j]  // 要素を右にシフト\n        j = j - 1\n    array[j+1] = key  // 挿入\n```\n\n【最良ケース】\nすでにソート済みの配列の場合、内側のwhileループは実行されない（比較は1回のみ）。\n- 外側のループ：n-1回\n- 内側のループ：0回\n- 時間計算量：**O(n)**\n\n【平均ケース】\nランダムなデータの場合、平均で約i/2回の比較・シフトが必要。\n- 合計：(1/2 + 2/2 + 3/2 + ... + (n-1)/2) = n(n-1)/4 ≈ n²/4回\n- 時間計算量：**O(n²)**\n\n【最悪ケース】\n逆順にソートされた配列の場合、毎回i回の比較・シフトが必要。\n- 合計：1 + 2 + 3 + ... + (n-1) = n(n-1)/2 ≈ n²/2回\n- 時間計算量：**O(n²)**\n\n例（n=1000の配列）：\n- 最良ケース：約1,000回の処理（すでにソート済み）\n- 平均ケース：約250,000回の処理\n- 最悪ケース：約500,000回の処理（逆順）\n\n挿入ソートは、すでにソート済みまたはほぼソート済みのデータに対しては高速（O(n)）ですが、ランダムなデータには不向き（O(n²)）です。"
        },
        {
          "type": "table",
          "headers": ["アルゴリズム", "最良ケース", "平均ケース", "最悪ケース"],
          "rows": [
            ["線形探索", "O(1)", "O(n)", "O(n)"],
            ["2分探索", "O(1)", "O(log n)", "O(log n)"],
            ["バブルソート", "O(n)", "O(n²)", "O(n²)"],
            ["選択ソート", "O(n²)", "O(n²)", "O(n²)"],
            ["挿入ソート", "O(n)", "O(n²)", "O(n²)"],
            ["マージソート", "O(n log n)", "O(n log n)", "O(n log n)"],
            ["クイックソート", "O(n log n)", "O(n log n)", "O(n²)"],
            ["ヒープソート", "O(n log n)", "O(n log n)", "O(n log n)"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "最悪ケースの重要性",
          "content": "システム設計では、最悪ケースの計算量を想定することが重要です。例えば、Webサーバの応答時間を保証する場合、「平均ケースでは高速」でも、「最悪ケースで非常に遅い」アルゴリズムは使えません。最悪ケースでも許容範囲内の性能を発揮するアルゴリズムを選択する必要があります。\n\n例：\n- クイックソート：平均O(n log n)だが、最悪O(n²) → ピボットをランダムに選択して最悪ケースを回避\n- マージソート：最良・平均・最悪すべてO(n log n) → 安定して高速だが、追加メモリが必要\n\n状況に応じて、最適なアルゴリズムを選択します。"
        }
      ]
    },
    {
      "id": 5,
      "title": "アルゴリズムの計算量の比較と実践例",
      "sections": [
        {
          "type": "text",
          "content": "これまで学んだ計算量の知識を使って、実際のアルゴリズムを比較します。同じ問題を解く複数のアルゴリズムがある場合、計算量を比較することで、どのアルゴリズムが効率的かを判断できます。ここでは、①探索アルゴリズムの比較（線形探索 vs 2分探索）、②ソートアルゴリズムの比較（バブルソート vs マージソート）、③ループ回数の計算練習、を通して、計算量の評価を実践します。"
        },
        {
          "type": "example",
          "title": "探索アルゴリズムの比較：線形探索 vs 2分探索",
          "content": "【問題】\n100万件のデータから、特定の値を探索する。\n\n【方法1：線形探索】\n配列の先頭から順番に探索。\n時間計算量：O(n) = O(1,000,000)\n最悪の場合、100万回の比較が必要。\n実行時間の目安（1回の比較を1マイクロ秒と仮定）：約1秒\n\n【方法2：2分探索（前提：ソート済み配列）】\n毎回、探索範囲を半分にして探索。\n時間計算量：O(log n) = O(log₂ 1,000,000) ≈ O(20)\n最悪の場合、約20回の比較が必要。\n実行時間の目安：約20マイクロ秒（0.00002秒）\n\n【結論】\n2分探索の方が、約50,000倍高速です。ただし、2分探索は「ソート済み配列」が前提です。配列がソートされていない場合、事前にソート（O(n log n)）が必要です。\n\n【使い分け】\n- データがソート済み → 2分探索（O(log n)）\n- データが未ソートで、探索回数が少ない → 線形探索（O(n)）\n- データが未ソートで、探索回数が多い → 事前にソート + 2分探索（ソート：O(n log n)、探索k回：O(k log n)）"
        },
        {
          "type": "example",
          "title": "ソートアルゴリズムの比較：バブルソート vs マージソート",
          "content": "【問題】\n10,000件のランダムなデータをソートする。\n\n【方法1：バブルソート】\n時間計算量：O(n²) = O(10,000²) = O(100,000,000)（1億回）\n実行時間の目安（1回の比較を1マイクロ秒と仮定）：約100秒\n空間計算量：O(1)（追加メモリ不要）\n\n【方法2：マージソート】\n時間計算量：O(n log n) = O(10,000 × log₂ 10,000) ≈ O(10,000 × 13.3) ≈ O(133,000)\n実行時間の目安：約0.13秒\n空間計算量：O(n)（追加メモリ10,000個必要）\n\n【結論】\nマージソートの方が、約750倍高速です。ただし、マージソートは追加メモリが必要です。\n\n【使い分け】\n- データ数が少ない（n < 100）→ バブルソート（シンプルで実装が容易）\n- データ数が多い（n >= 1000）→ マージソート、クイックソート、ヒープソート（O(n log n)）\n- メモリが限られている → ヒープソート（空間計算量O(1)）\n- 安定ソートが必要 → マージソート（同じ値の順序を保持）"
        },
        {
          "type": "example",
          "title": "ループ回数の計算練習（1）：2重ループ",
          "content": "【疑似コード】\n```\ncount = 0\nfor i = 1 to n:\n    for j = 1 to i:\n        count = count + 1\n```\n\n【ループ回数の計算】\niが1のとき、内側のループは1回実行\niが2のとき、内側のループは2回実行\niが3のとき、内側のループは3回実行\n...\niがnのとき、内側のループはn回実行\n\n合計：1 + 2 + 3 + ... + n = n(n+1)/2 = (n² + n)/2\n\n【時間計算量】\nO(n²)（最も影響の大きい項n²のみを残す）\n\n例：\n- n=10のとき：(10² + 10)/2 = 55回\n- n=100のとき：(100² + 100)/2 = 5,050回\n- n=1000のとき：(1000² + 1000)/2 = 500,500回"
        },
        {
          "type": "example",
          "title": "ループ回数の計算練習（2）：ループの範囲が異なる場合",
          "content": "【疑似コード】\n```\ncount = 0\nfor i = 1 to n:\n    for j = 1 to 10:  // 固定で10回\n        count = count + 1\n```\n\n【ループ回数の計算】\n外側のループ：n回\n内側のループ：毎回10回（固定）\n\n合計：n × 10 = 10n\n\n【時間計算量】\nO(n)（係数10は無視）\n\n例：\n- n=100のとき：10 × 100 = 1,000回\n- n=1000のとき：10 × 1000 = 10,000回\n\n内側のループが定数回（nに依存しない）の場合、時間計算量はO(n)になります。"
        },
        {
          "type": "example",
          "title": "ループ回数の計算練習（3）：2分探索のループ回数",
          "content": "【疑似コード】\n```\nleft = 1\nright = n\nwhile left <= right:\n    mid = (left + right) / 2\n    if array[mid] == target:\n        return mid\n    else if array[mid] < target:\n        left = mid + 1\n    else:\n        right = mid - 1\n```\n\n【ループ回数の計算】\n毎回、探索範囲（right - left）が半分になります。\n- 1回目：n個\n- 2回目：n/2個\n- 3回目：n/4個\n- k回目：n/(2^k)個\n\n探索範囲が1個になるまでの回数kは、n/(2^k) = 1 → 2^k = n → k = log₂ n\n\n【時間計算量】\nO(log n)\n\n例：\n- n=1000のとき：log₂ 1000 ≈ 10回（2^10 = 1024）\n- n=100万のとき：log₂ 1,000,000 ≈ 20回（2^20 = 1,048,576）\n\n「毎回、範囲が半分になる」→ O(log n)と覚えましょう。"
        },
        {
          "type": "table",
          "headers": ["ループの特徴", "時間計算量", "具体例"],
          "rows": [
            ["単一ループ（for i = 1 to n）", "O(n)", "配列の全要素を処理"],
            ["2重ループ（for i = 1 to n, for j = 1 to n）", "O(n²)", "全ペアを比較"],
            ["2重ループ（for i = 1 to n, for j = 1 to i）", "O(n²)", "1+2+3+...+n = n²/2"],
            ["ループ + 固定回数のループ（for i = 1 to n, for j = 1 to 10）", "O(n)", "n × 10 = 10n"],
            ["毎回範囲が半分になるループ", "O(log n)", "2分探索"],
            ["ループなし（定数回の処理）", "O(1)", "配列の先頭へのアクセス"]
          ]
        },
        {
          "type": "highlight",
          "icon": "📊",
          "title": "計算量の評価の重要ポイント",
          "content": "アルゴリズムの計算量を評価する際の重要ポイントをまとめます。\n\n①データ数nが大きいときを想定\n  - n=10では差が小さいが、n=100万では大きな差が出る\n  - オーダ記法は「nが十分に大きいとき」の評価\n\n②最も影響の大きい項を見つける\n  - n² + n → n²が支配的 → O(n²)\n  - n log n + n → n log nが支配的 → O(n log n)\n\n③ループの回数を数える\n  - 2重ループ → O(n²)\n  - 毎回半分になる → O(log n)\n\n④最悪ケースを想定（システム設計）\n  - クイックソート：平均O(n log n)、最悪O(n²)\n  - マージソート：常にO(n log n)（安定）\n\n⑤空間計算量も考慮（メモリ制約）\n  - マージソート：時間O(n log n)、空間O(n)\n  - ヒープソート：時間O(n log n)、空間O(1)\n\nこれらのポイントを押さえて、状況に応じた最適なアルゴリズムを選択しましょう。"
        }
      ]
    }
  ]
}
