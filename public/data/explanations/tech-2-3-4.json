{
  "topicId": "tech-2-3-4",
  "title": "実記憶管理",
  "pages": [
    {
      "id": 1,
      "title": "実記憶管理の基礎と固定区画方式",
      "sections": [
        {
          "type": "text",
          "content": "**実記憶管理（Real Memory Management）**とは、OSがコンピュータの主記憶装置（メインメモリ、RAM）を効率的に管理する技術です。複数のプログラムを同時に実行する場合、限られたメモリ領域をどのように各プログラムに割り当てるかが重要になります。実記憶管理では、物理的に存在するメモリ（実メモリ）を直接管理し、プログラムに割り当てます。実記憶管理の主な方式には、①**固定区画方式**、②**可変区画方式**、③**オーバーレイ方式**、④**スワッピング方式**、があります。"
        },
        {
          "type": "example",
          "title": "実記憶管理が必要な理由",
          "content": "【背景】\nあなたのパソコンには8GBのRAMがあります。複数のプログラムを同時に実行する場合（例: Webブラウザ、メールソフト、動画編集ソフト、音楽プレイヤー）、OSはこの8GBのRAMをどのように各プログラムに割り当てるかを決める必要があります。\n\n【実記憶管理なしの場合】\n①Webブラウザが起動 → RAMの先頭から2GBを使用\n②メールソフトが起動 → 次の1GBを使用\n③動画編集ソフトが起動 → 次の4GBを使用\n④音楽プレイヤーが起動 → 残り1GB（足りない！）\n\n実記憶管理なしでは、メモリが不足してプログラムが起動できなくなります。また、プログラムが終了してもメモリが開放されない、複数のプログラムが同じメモリ領域を使おうとして競合する、などの問題が発生します。\n\n【実記憶管理ありの場合】\nOSが各プログラムにメモリ領域を割り当て、プログラムが終了したらメモリを開放します。また、メモリが不足する場合は、一時的にハードディスクにデータを退避（スワッピング）して、メモリを確保します。実記憶管理により、複数のプログラムを安全かつ効率的に実行できます。"
        },
        {
          "type": "text",
          "content": "**固定区画方式（Fixed Partition）**とは、メモリをあらかじめ固定サイズの区画に分割し、各プログラムを区画に割り当てる方式です。例えば、8GBのメモリを、2GB、2GB、2GB、2GBの4つの区画に分割します。プログラムが起動すると、OSは空いている区画を1つ割り当てます。プログラムが終了すると、その区画は開放され、次のプログラムが使用できます。固定区画方式は、実装が簡単で、管理のオーバーヘッドが小さいという利点がありますが、**内部フラグメンテーション（Internal Fragmentation）**という問題が発生します。"
        },
        {
          "type": "example",
          "title": "固定区画方式の具体例",
          "content": "【メモリの分割】\n8GBのメモリを、2GB、2GB、2GB、2GBの4つの区画に分割します。\n\n【プログラムの割り当て】\n①Webブラウザが起動（必要なメモリ: 1.5GB）\n  → OSは区画1（2GB）を割り当てる\n  → 使用されるメモリ: 1.5GB / 2GB（0.5GBが無駄）\n\n②メールソフトが起動（必要なメモリ: 0.8GB）\n  → OSは区画2（2GB）を割り当てる\n  → 使用されるメモリ: 0.8GB / 2GB（1.2GBが無駄）\n\n③動画編集ソフトが起動（必要なメモリ: 4GB）\n  → 1つの区画は2GBなので、4GBのプログラムは実行できない！\n  → エラー: メモリ不足\n\n④音楽プレイヤーが起動（必要なメモリ: 0.3GB）\n  → OSは区画3（2GB）を割り当てる\n  → 使用されるメモリ: 0.3GB / 2GB（1.7GBが無駄）\n\n【問題点】\n①内部フラグメンテーション: 各区画で、割り当てられたメモリの一部が使われず、無駄になっている（0.5GB + 1.2GB + 1.7GB = 3.4GBが無駄）\n②柔軟性の欠如: 4GBの大きなプログラムは実行できない（区画サイズが固定）"
        },
        {
          "type": "table",
          "headers": ["区画", "サイズ", "割り当てプログラム", "使用メモリ", "無駄なメモリ"],
          "rows": [
            ["区画1", "2GB", "Webブラウザ（1.5GB）", "1.5GB", "0.5GB"],
            ["区画2", "2GB", "メールソフト（0.8GB）", "0.8GB", "1.2GB"],
            ["区画3", "2GB", "音楽プレイヤー（0.3GB）", "0.3GB", "1.7GB"],
            ["区画4", "2GB", "（空き）", "0GB", "0GB"],
            ["合計", "8GB", "-", "2.6GB", "3.4GB（無駄）"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "内部フラグメンテーションとは",
          "content": "**内部フラグメンテーション（Internal Fragmentation）**とは、割り当てられたメモリ領域の一部が使われず、無駄になる現象です。固定区画方式では、プログラムのサイズが区画サイズより小さい場合、余ったメモリは他のプログラムに使えず、無駄になります。例えば、2GBの区画に0.8GBのプログラムを割り当てると、1.2GBが無駄になります。この1.2GBは「内部」（割り当てられた区画の中）で無駄になっているため、「内部フラグメンテーション」と呼ばれます。固定区画方式の最大の欠点です。"
        }
      ]
    },
    {
      "id": 2,
      "title": "可変区画方式とフラグメンテーション",
      "sections": [
        {
          "type": "text",
          "content": "**可変区画方式（Variable Partition）**とは、プログラムが必要とするメモリサイズに応じて、動的に区画を作成する方式です。固定区画方式と異なり、区画サイズは固定されていません。プログラムが起動すると、OSは必要なサイズの区画を作成し、プログラムに割り当てます。プログラムが終了すると、その区画は開放され、次のプログラムが使用できます。可変区画方式は、内部フラグメンテーションが発生しない（プログラムに必要な分だけメモリを割り当てる）という利点がありますが、**外部フラグメンテーション（External Fragmentation）**という別の問題が発生します。"
        },
        {
          "type": "example",
          "title": "可変区画方式の具体例と外部フラグメンテーション",
          "content": "【メモリの状態（初期）】\n8GBのメモリ全体が空き状態です。\n\n【プログラムの割り当て】\n①Webブラウザが起動（必要なメモリ: 1.5GB）\n  → OSは先頭から1.5GBの区画を作成し、割り当てる\n  → 残りメモリ: 6.5GB\n\n②メールソフトが起動（必要なメモリ: 0.8GB）\n  → OSは次の0.8GBの区画を作成し、割り当てる\n  → 残りメモリ: 5.7GB\n\n③動画編集ソフトが起動（必要なメモリ: 4GB）\n  → OSは次の4GBの区画を作成し、割り当てる\n  → 残りメモリ: 1.7GB\n\n④音楽プレイヤーが起動（必要なメモリ: 0.3GB）\n  → OSは次の0.3GBの区画を作成し、割り当てる\n  → 残りメモリ: 1.4GB\n\n【メモリの状態】\n[Webブラウザ 1.5GB][メールソフト 0.8GB][動画編集ソフト 4GB][音楽プレイヤー 0.3GB][空き 1.4GB]\n\n⑤メールソフトが終了\n  → メールソフトの0.8GBが開放される\n  → [Webブラウザ 1.5GB][空き 0.8GB][動画編集ソフト 4GB][音楽プレイヤー 0.3GB][空き 1.4GB]\n\n⑥Webブラウザが終了\n  → Webブラウザの1.5GBが開放される\n  → [空き 1.5GB][空き 0.8GB][動画編集ソフト 4GB][音楽プレイヤー 0.3GB][空き 1.4GB]\n\n⑦新しいプログラム（必要なメモリ: 2GB）が起動\n  → 空きメモリは合計3.7GB（1.5GB + 0.8GB + 1.4GB）あるが、連続した2GBの領域がない！\n  → エラー: メモリ不足（外部フラグメンテーション）\n\n【問題点】\n外部フラグメンテーション: 空きメモリの合計は十分（3.7GB）だが、断片化（細かく分散）しているため、大きなプログラム（2GB）を割り当てられない。"
        },
        {
          "type": "text",
          "content": "**外部フラグメンテーション（External Fragmentation）**とは、空きメモリが細かく分散し、合計では十分なメモリがあるのに、連続した領域として確保できない現象です。可変区画方式では、プログラムの起動・終了が繰り返されると、メモリが断片化（フラグメンテーション）し、外部フラグメンテーションが発生します。外部フラグメンテーションを解決するには、**メモリコンパクション（Memory Compaction）**という技術を使用します。"
        },
        {
          "type": "text",
          "content": "**メモリコンパクション（Memory Compaction、ガベージコレクション）**とは、メモリ上のプログラムを移動させて、空き領域を1つにまとめる技術です。メモリコンパクションを実行すると、断片化した空きメモリが連続した1つの大きな空き領域になり、新しいプログラムを割り当てられるようになります。ただし、メモリコンパクションは、プログラムを移動させる処理が必要なため、処理時間がかかり、その間システムが一時的に停止する（オーバーヘッドが大きい）という欠点があります。"
        },
        {
          "type": "example",
          "title": "メモリコンパクションの具体例",
          "content": "【メモリの状態（コンパクション前）】\n[空き 1.5GB][空き 0.8GB][動画編集ソフト 4GB][音楽プレイヤー 0.3GB][空き 1.4GB]\n空きメモリ合計: 3.7GB（断片化している）\n\n【メモリコンパクションを実行】\nOSが、実行中のプログラム（動画編集ソフト、音楽プレイヤー）をメモリの先頭に移動させます。\n①動画編集ソフトを先頭に移動\n②音楽プレイヤーを動画編集ソフトの直後に移動\n③空き領域をまとめる\n\n【メモリの状態（コンパクション後）】\n[動画編集ソフト 4GB][音楽プレイヤー 0.3GB][空き 3.7GB]\n空きメモリ: 3.7GB（連続した領域になった！）\n\n⑧新しいプログラム（必要なメモリ: 2GB）が起動\n  → 連続した3.7GBの空き領域があるため、2GBを割り当てられる\n  → 成功！\n\n【メモリの状態】\n[動画編集ソフト 4GB][音楽プレイヤー 0.3GB][新しいプログラム 2GB][空き 1.7GB]\n\n【メモリコンパクションの欠点】\nプログラムを移動させる処理が必要なため、時間がかかります（数秒～数十秒）。その間、システムが一時的に停止し、ユーザーは操作できません（オーバーヘッド）。そのため、メモリコンパクションは頻繁に実行せず、外部フラグメンテーションが深刻になった場合のみ実行します。"
        },
        {
          "type": "table",
          "headers": ["方式", "内部フラグメンテーション", "外部フラグメンテーション", "実装の難易度"],
          "rows": [
            ["固定区画方式", "発生する（大きな無駄）", "発生しない", "簡単"],
            ["可変区画方式", "発生しない", "発生する（対策: メモリコンパクション）", "やや複雑"]
          ]
        },
        {
          "type": "highlight",
          "icon": "🔧",
          "title": "フラグメンテーションの違い",
          "content": "**内部フラグメンテーション**は、割り当てられた区画の「内部」で無駄が発生（固定区画方式の問題）。**外部フラグメンテーション**は、区画の「外部」（空き領域）が断片化する問題（可変区画方式の問題）。内部フラグメンテーションは防げませんが、外部フラグメンテーションはメモリコンパクションで解決できます。実際のOSでは、可変区画方式が主流で、外部フラグメンテーションを抑えるアルゴリズム（First Fit、Best Fit、Worst Fit）が使われています。"
        }
      ]
    },
    {
      "id": 3,
      "title": "メモリ割り当てアルゴリズム（First Fit、Best Fit、Worst Fit）",
      "sections": [
        {
          "type": "text",
          "content": "可変区画方式では、プログラムが起動する際、OSは複数の空き領域の中から、どの領域にプログラムを割り当てるかを決定する必要があります。この決定に使用されるアルゴリズムが、**メモリ割り当てアルゴリズム**です。代表的なアルゴリズムには、①**First Fit（最初適合）**、②**Best Fit（最良適合）**、③**Worst Fit（最悪適合）**、の3つがあります。各アルゴリズムは、空き領域の探索方法と割り当て方針が異なり、外部フラグメンテーションの発生率やパフォーマンスに影響します。"
        },
        {
          "type": "example",
          "title": "メモリ割り当てアルゴリズムの比較（具体例）",
          "content": "【メモリの状態】\n[使用中 2GB][空き 1GB][使用中 1.5GB][空き 3GB][使用中 0.5GB][空き 2GB]\n空き領域: 1GB、3GB、2GB\n\n【新しいプログラム（必要なメモリ: 1.2GB）が起動】\nどの空き領域に割り当てるか？\n\n①**First Fit（最初適合）**:\n先頭から順番に空き領域を探し、最初に見つかった「十分なサイズの空き領域」に割り当てる。\n→ 空き領域を先頭から探す: 1GB（不足）→ 3GB（十分！）\n→ 3GBの領域に1.2GBを割り当てる\n→ 残り: 1.8GB\n\n**利点**: 探索が高速（最初に見つかった領域に割り当てる）\n**欠点**: 大きな空き領域が細かく分割されやすい\n\n②**Best Fit（最良適合）**:\n全ての空き領域を調べ、「プログラムのサイズに最も近い空き領域」に割り当てる。\n→ 空き領域: 1GB（不足）、3GB（OK）、2GB（OK）\n→ プログラムのサイズ（1.2GB）に最も近いのは2GB\n→ 2GBの領域に1.2GBを割り当てる\n→ 残り: 0.8GB\n\n**利点**: 無駄な空き領域が小さい（2GB - 1.2GB = 0.8GB）\n**欠点**: 全ての空き領域を探索するため、処理時間がかかる。また、小さな空き領域（0.8GB）が大量に発生しやすい（外部フラグメンテーション）\n\n③**Worst Fit（最悪適合）**:\n全ての空き領域を調べ、「最も大きい空き領域」に割り当てる。\n→ 空き領域: 1GB、3GB、2GB\n→ 最も大きいのは3GB\n→ 3GBの領域に1.2GBを割り当てる\n→ 残り: 1.8GB\n\n**利点**: 割り当て後の残り領域が大きい（1.8GB）ため、次のプログラムも割り当てやすい\n**欠点**: 全ての空き領域を探索するため、処理時間がかかる。大きな空き領域が減りやすい"
        },
        {
          "type": "table",
          "headers": ["アルゴリズム", "割り当て方針", "探索時間", "外部フラグメンテーション", "特徴"],
          "rows": [
            ["First Fit", "最初に見つかった十分なサイズの領域", "高速", "中程度", "実装が簡単、一般的に使用される"],
            ["Best Fit", "サイズが最も近い領域", "遅い（全探索）", "多い（小さな断片が発生）", "無駄が少ないが、断片化しやすい"],
            ["Worst Fit", "最も大きい領域", "遅い（全探索）", "少ない", "残り領域が大きいが、大きな領域が減る"]
          ]
        },
        {
          "type": "text",
          "content": "実際のOSでは、**First Fit**が最も一般的に使用されています。理由は、①探索時間が短く、パフォーマンスが良い、②実装が簡単、③外部フラグメンテーションがBest Fitより少ない、からです。Best Fitは一見効率的に見えますが、小さな空き領域が大量に発生し、結果的に外部フラグメンテーションが悪化することが研究で示されています。Worst Fitは、大きな空き領域を優先的に使うため、大規模プログラムを実行できなくなるリスクがあります。"
        },
        {
          "type": "highlight",
          "icon": "📌",
          "title": "メモリ割り当てアルゴリズムの選択",
          "content": "メモリ割り当てアルゴリズムは、システムの特性（プログラムのサイズ、起動頻度）に応じて選択します。一般的なシステムでは、First Fitが最もバランスが良く、広く使われています。ただし、リアルタイム性が求められるシステム（工場の制御システムなど）では、探索時間が予測可能なアルゴリズム（固定区画方式）が選ばれることもあります。また、最近のOSでは、仮想記憶（後述）を使用するため、実記憶管理の重要性は相対的に低下していますが、組み込みシステムなど、リソースが限られた環境では、実記憶管理の最適化が重要です。"
        }
      ]
    },
    {
      "id": 4,
      "title": "オーバーレイ方式",
      "sections": [
        {
          "type": "text",
          "content": "**オーバーレイ方式（Overlay）**とは、プログラム全体をメモリに配置するのではなく、必要な部分だけを順次メモリに読み込む方式です。プログラムが大きすぎてメモリに収まらない場合、プログラムを複数のモジュール（部品）に分割し、実行に必要なモジュールだけをメモリに配置します。使い終わったモジュールは、次のモジュールで上書き（オーバーレイ）されます。オーバーレイ方式により、メモリ容量より大きなプログラムを実行できます。"
        },
        {
          "type": "example",
          "title": "オーバーレイ方式の具体例",
          "content": "【背景】\nある大規模な科学計算プログラムは、合計10GBのサイズですが、コンピュータのメモリは8GBしかありません。プログラムは、①データ入力モジュール（2GB）、②計算モジュールA（3GB）、③計算モジュールB（4GB）、④結果出力モジュール（1GB）、の4つのモジュールで構成されています。\n\n【オーバーレイなしの場合】\nプログラム全体（10GB）をメモリに配置しようとすると、メモリ不足で実行できません。\n\n【オーバーレイ方式の場合】\nプログラムを分割し、必要なモジュールだけをメモリに配置します。\n\n①データ入力モジュール（2GB）をメモリに読み込み、実行\n  → ユーザーが入力データを入力\n  → データをメモリに保存\n\n②データ入力モジュールを削除し、計算モジュールA（3GB）をメモリに読み込み（オーバーレイ）\n  → 計算モジュールAが、入力データを使って計算を実行\n  → 計算結果をメモリに保存\n\n③計算モジュールAを削除し、計算モジュールB（4GB）をメモリに読み込み（オーバーレイ）\n  → 計算モジュールBが、計算結果を使ってさらに計算を実行\n  → 最終結果をメモリに保存\n\n④計算モジュールBを削除し、結果出力モジュール（1GB）をメモリに読み込み（オーバーレイ）\n  → 結果出力モジュールが、最終結果を画面に表示\n\n【メモリの使用状況】\nどの時点でも、メモリに配置されているのは、最大4GB（計算モジュールB）だけです。8GBのメモリで、10GBのプログラムを実行できました！\n\n【注意点】\nモジュールの切り替え（ディスクからメモリへの読み込み）に時間がかかります（数秒～数十秒）。そのため、プログラム全体の実行時間は長くなります。"
        },
        {
          "type": "text",
          "content": "オーバーレイ方式の最大の利点は、**メモリ容量より大きなプログラムを実行できる**ことです。メモリが少ないコンピュータ（古いパソコン、組み込みシステム）でも、大規模なプログラムを実行できます。ただし、オーバーレイ方式には以下の欠点があります。①**プログラマがモジュール分割を設計する必要がある**：どのモジュールをいつ読み込むかをプログラマが決める必要があり、プログラムが複雑になる。②**モジュールの切り替えに時間がかかる**：ディスクからメモリへの読み込みは遅い（HDD: 数秒、SSD: 数百ミリ秒）。③**現在のOSではほとんど使われていない**：仮想記憶（後述）を使えば、OSが自動的にメモリとディスクを管理するため、オーバーレイ方式は不要。"
        },
        {
          "type": "table",
          "headers": ["方式", "メモリより大きなプログラム", "実装の難易度", "パフォーマンス", "現在の使用状況"],
          "rows": [
            ["固定区画方式", "実行不可", "簡単", "高速", "ほとんど使われていない"],
            ["可変区画方式", "実行不可", "やや複雑", "高速", "組み込みシステムで使用"],
            ["オーバーレイ方式", "実行可能", "複雑（プログラマが設計）", "遅い（モジュール切り替え）", "ほとんど使われていない"],
            ["仮想記憶（後述）", "実行可能", "複雑（OSが自動管理）", "中程度", "現在の主流"]
          ]
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "オーバーレイ方式の歴史的背景",
          "content": "オーバーレイ方式は、1960年代～1980年代のコンピュータで広く使われていました。当時のコンピュータは、メモリが非常に少なく（数KB～数MB）、大規模なプログラムを実行するにはオーバーレイ方式が必須でした。しかし、1990年代以降、メモリの容量が急増し（数GB～数百GB）、仮想記憶技術が普及したため、オーバーレイ方式はほとんど使われなくなりました。現在では、メモリが極端に少ない組み込みシステム（マイコン、IoTデバイス）で、一部使用されています。"
        }
      ]
    },
    {
      "id": 5,
      "title": "スワッピング方式",
      "sections": [
        {
          "type": "text",
          "content": "**スワッピング方式（Swapping）**とは、メモリが不足した場合、実行中のプログラムを一時的にハードディスク（またはSSD）に退避（スワップアウト）し、メモリを空けて、新しいプログラムを実行する方式です。退避されたプログラムは、後で再びメモリに戻され（スワップイン）、実行を再開します。スワッピング方式により、物理メモリより多くのプログラムを同時に実行できます（見かけ上、メモリ容量が増える）。スワッピングは、仮想記憶の基礎となる技術です。"
        },
        {
          "type": "example",
          "title": "スワッピング方式の具体例",
          "content": "【背景】\nコンピュータのメモリは8GBです。現在、①Webブラウザ（2GB）、②メールソフト（1GB）、③動画編集ソフト（4GB）、が実行中で、メモリの使用量は7GBです。残りのメモリは1GBです。\n\n【新しいプログラム（画像編集ソフト、2GB）を起動】\nメモリが不足しているため、そのままでは起動できません。\n\n【スワッピングを実行】\n①OSは、現在実行中だが、しばらく使われていないプログラム（メールソフト、1GB）を選択\n②メールソフトのデータ（1GB）をハードディスクに退避（スワップアウト）\n  → ハードディスクの「スワップ領域」に保存\n  → メモリが1GB空く（残りメモリ: 2GB）\n③画像編集ソフト（2GB）をメモリに読み込み（スワップイン）\n  → 画像編集ソフトが実行開始\n\n【メモリの状態】\n[Webブラウザ 2GB][動画編集ソフト 4GB][画像編集ソフト 2GB]\n\n【ユーザーがメールソフトに切り替え】\nユーザーがメールソフトを使おうとすると、OSは以下の処理を実行します。\n①OSは、現在使われていないプログラム（動画編集ソフト、4GB）を選択\n②動画編集ソフトのデータ（4GB）をハードディスクに退避（スワップアウト）\n  → メモリが4GB空く\n③ハードディスクからメールソフトのデータ（1GB）をメモリに読み込み（スワップイン）\n  → メールソフトが実行再開\n\n【メモリの状態】\n[Webブラウザ 2GB][メールソフト 1GB][画像編集ソフト 2GB][空き 3GB]\n\n【注意点】\nスワッピングは、ハードディスクへの読み書きが発生するため、非常に時間がかかります（HDD: 数秒～数十秒、SSD: 数百ミリ秒～数秒）。スワッピングが頻繁に発生すると、システム全体が遅くなります（スラッシング、後述）。"
        },
        {
          "type": "text",
          "content": "スワッピング方式の最大の利点は、**物理メモリより多くのプログラムを同時に実行できる**ことです。例えば、8GBのメモリしかないコンピュータでも、スワッピングを使えば、合計20GBのプログラムを実行できます（ただし、同時にメモリに配置されるのは8GBまで）。スワッピング方式の欠点は、①**ハードディスクへのアクセスが遅い**：メモリは数ナノ秒でアクセスできますが、ハードディスクは数ミリ秒かかります（100万倍遅い！）。②**スラッシング（Thrashing）**：スワッピングが頻繁に発生すると、システムがほとんどスワッピングの処理に時間を使い、プログラムの実行が進まなくなる現象。"
        },
        {
          "type": "example",
          "title": "スラッシングの具体例",
          "content": "【背景】\nコンピュータのメモリは8GBで、10個のプログラム（各1GB）を同時に実行しようとしています。\n\n【スラッシングの発生】\n①OSは、プログラムA（1GB）をメモリに配置\n②OSは、プログラムB（1GB）をメモリに配置\n...\n⑧OSは、プログラムH（1GB）をメモリに配置（メモリ使用量: 8GB、満杯）\n⑨OSは、プログラムI（1GB）を配置するために、プログラムA（1GB）をスワップアウト\n⑩OSは、プログラムJ（1GB）を配置するために、プログラムB（1GB）をスワップアウト\n⑪ユーザーがプログラムAに切り替える → OSは、プログラムI（1GB）をスワップアウトし、プログラムA（1GB）をスワップイン\n⑫ユーザーがプログラムBに切り替える → OSは、プログラムJ（1GB）をスワップアウトし、プログラムB（1GB）をスワップイン\n...\n\nスワッピングが延々と繰り返され、プログラムの実行がほとんど進みません。システムは、スワッピングの処理に時間を使い、非常に遅くなります。これが**スラッシング**です。\n\n【スラッシングの対策】\n①メモリを増設する（8GB → 16GB）\n②同時に実行するプログラムを減らす\n③仮想記憶のページングアルゴリズム（LRU）を改善する（後述）"
        },
        {
          "type": "table",
          "headers": ["方式", "メモリより多くのプログラム", "パフォーマンス", "スラッシングのリスク", "現在の使用状況"],
          "rows": [
            ["スワッピング方式（プログラム単位）", "実行可能", "遅い（スワップが発生すると）", "高い", "古いOSで使用"],
            ["仮想記憶（ページ単位、後述）", "実行可能", "中程度", "中程度（アルゴリズムで改善）", "現在の主流"]
          ]
        },
        {
          "type": "highlight",
          "icon": "📌",
          "title": "スワッピングと仮想記憶の違い",
          "content": "スワッピング方式は、**プログラム全体**をメモリとハードディスクの間で移動します。一方、仮想記憶（次のトピック）は、プログラムを小さな単位（ページ、例: 4KB）に分割し、**必要なページだけ**をメモリに配置します。仮想記憶は、スワッピングより効率的で、現在のOSで広く使われています。スワッピング方式は、仮想記憶の基礎となる技術ですが、現在では単独で使われることは少なく、仮想記憶の一部として実装されています。"
        }
      ]
    }
  ]
}
