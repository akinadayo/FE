{
  "topicId": "tech-4-1-4",
  "title": "テスト技法",
  "pages": [
    {
      "id": 1,
      "title": "ホワイトボックステストの基礎とカバレッジ",
      "sections": [
        {
          "type": "text",
          "content": "**ホワイトボックステスト（White Box Test）**とは、プログラムの内部構造（ソースコード）を理解した上で、コードの全ての経路が実行されるかを検証するテスト技法です。別名「構造テスト」「ガラス箱テスト」とも呼ばれます。主に単体テストで使用され、開発者（プログラマ）が実施します。ホワイトボックステストでは、**カバレッジ（Coverage）**という指標でテストの網羅性を測定します。"
        },
        {
          "type": "table",
          "headers": ["カバレッジの種類", "別名", "カバレッジの定義", "強度"],
          "rows": [
            ["命令網羅（C0）", "ステートメントカバレッジ", "全ての命令（文）を最低1回実行", "弱い"],
            ["判定条件網羅（C1）", "ブランチカバレッジ、分岐網羅", "全ての判定（if文、while文など）で真と偽の両方を実行", "中"],
            ["条件網羅（C2）", "コンディションカバレッジ", "全ての条件（AとB、AまたはB）で真と偽の両方を実行", "強い"]
          ]
        },
        {
          "type": "text",
          "content": "カバレッジの強度は、条件網羅 > 判定条件網羅 > 命令網羅の順です。条件網羅を満たせば、判定条件網羅と命令網羅も満たします。しかし、テストケースの数が増えるため、実際のプロジェクトでは、コストと品質のバランスを考慮して、カバレッジの目標（例: 判定条件網羅80%以上）を設定します。"
        },
        {
          "type": "example",
          "title": "命令網羅（C0）の具体例：割引計算プログラム",
          "content": "【プログラム（疑似コード）】\n```\n1: function calculateDiscount(price, isMember) {\n2:     discount = 0\n3:     if (isMember) {\n4:         discount = price * 0.1\n5:     }\n6:     finalPrice = price - discount\n7:     return finalPrice\n8: }\n```\n\n【命令網羅（C0）を満たすテストケース】\n目標：全ての命令（1～7行目）を最低1回実行する\n\nテストケース1: calculateDiscount(1000, true)\n実行される行: 1→2→3→4→5→6→7（全7行を実行）\n\n命令網羅率 = 実行された命令数 / 全命令数 = 7 / 7 = 100%\n\n【問題点】\nテストケース1のみでは、if文の偽（isMemberがfalse）のケースが実行されません。しかし、命令網羅では全ての行が実行されているため、100%と判定されます。このため、命令網羅は網羅性が低く、バグを見逃すリスクがあります。"
        },
        {
          "type": "example",
          "title": "判定条件網羅（C1）の具体例：割引計算プログラム",
          "content": "【プログラム（同じもの）】\n```\n1: function calculateDiscount(price, isMember) {\n2:     discount = 0\n3:     if (isMember) {\n4:         discount = price * 0.1\n5:     }\n6:     finalPrice = price - discount\n7:     return finalPrice\n8: }\n```\n\n【判定条件網羅（C1）を満たすテストケース】\n目標：全ての判定（3行目のif文）で真と偽の両方を実行する\n\nテストケース1: calculateDiscount(1000, true)\nif文の判定: true → 真の経路を実行（4行目を実行）\n実行される行: 1→2→3→4→5→6→7\n\nテストケース2: calculateDiscount(1000, false)\nif文の判定: false → 偽の経路を実行（4行目をスキップ）\n実行される行: 1→2→3→6→7\n\n判定条件網羅率 = 実行された判定の組み合わせ数 / 全判定の組み合わせ数 = 2 / 2 = 100%\n\n【利点】\n判定条件網羅を満たすことで、if文の真と偽の両方のケースをテストでき、命令網羅よりも網羅性が高くなります。実際のプロジェクトでは、判定条件網羅80%以上が推奨されます。"
        },
        {
          "type": "example",
          "title": "条件網羅（C2）の具体例：複数条件を含むプログラム",
          "content": "【プログラム（疑似コード）】\n```\n1: function calculateShipping(price, isMember, isExpressShipping) {\n2:     shippingFee = 0\n3:     if (isMember && price >= 5000) {\n4:         shippingFee = 0  // 会員かつ5,000円以上なら送料無料\n5:     } else if (isExpressShipping) {\n6:         shippingFee = 500  // 速達配送は500円\n7:     } else {\n8:         shippingFee = 300  // 通常配送は300円\n9:     }\n10:    return shippingFee\n11: }\n```\n\n【条件網羅（C2）を満たすテストケース】\n目標：全ての条件（isMember、price >= 5000、isExpressShipping）で真と偽の両方を実行する\n\n条件は3つあります:\n- 条件A: isMember\n- 条件B: price >= 5000\n- 条件C: isExpressShipping\n\n各条件で真と偽の両方を実行するテストケース:\n\nテストケース1: calculateShipping(6000, true, false)\nisMember=真、price>=5000=真、isExpressShipping=偽 → 4行目を実行\n\nテストケース2: calculateShipping(3000, false, true)\nisMember=偽、price>=5000=偽、isExpressShipping=真 → 6行目を実行\n\nテストケース3: calculateShipping(4000, true, false)\nisMember=真、price>=5000=偽、isExpressShipping=偽 → 8行目を実行\n\nテストケース4: calculateShipping(6000, false, false)\nisMember=偽、price>=5000=真、isExpressShipping=偽 → 8行目を実行\n\n各条件のカバレッジ:\n- isMember: テストケース1,3で真、テストケース2,4で偽 → 100%\n- price >= 5000: テストケース1,4で真、テストケース2,3で偽 → 100%\n- isExpressShipping: テストケース2で真、テストケース1,3,4で偽 → 100%\n\n条件網羅率 = 100%\n\n【利点】\n条件網羅を満たすことで、複数の条件を含むif文の全ての組み合わせをテストでき、最も網羅性が高くなります。ただし、テストケース数が多くなるため、コストが高くなります。"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "カバレッジの選択基準",
          "content": "カバレッジの目標は、プロジェクトの品質要件とコストのバランスで決定します。一般的には、①安全性が重要なシステム（医療機器、航空機）: 条件網羅80%以上、②ビジネスアプリケーション（ECサイト、業務システム）: 判定条件網羅70～80%、③プロトタイプやPoC（Proof of Concept）: 命令網羅50%以上、が目安です。カバレッジ100%を目指すのは現実的ではなく、重要な機能（決済処理、認証処理）を優先的にテストすることが重要です。"
        }
      ]
    },
    {
      "id": 2,
      "title": "ブラックボックステストの基礎と同値分割法",
      "sections": [
        {
          "type": "text",
          "content": "**ブラックボックステスト（Black Box Test）**とは、プログラムの内部構造（ソースコード）を知らずに、仕様書（要件定義書、外部設計書）に基づいて、入力と出力が正しいかを検証するテスト技法です。別名「仕様テスト」「機能テスト」とも呼ばれます。主に結合テスト、システムテストで使用され、テスト担当者やユーザーが実施します。ブラックボックステストの代表的な技法として、①**同値分割法（Equivalence Partitioning）**、②**境界値分析（Boundary Value Analysis）**、③**デシジョンテーブル（Decision Table）**、があります。"
        },
        {
          "type": "table",
          "headers": ["テスト技法", "概要", "使用場面"],
          "rows": [
            ["同値分割法", "入力値を同じ結果になるグループ（同値クラス）に分割し、各グループから代表値を選んでテスト", "入力値の範囲が広い場合（例: 年齢、価格）"],
            ["境界値分析", "同値クラスの境界値（最小値、最大値、境界の前後）をテスト", "範囲指定のある入力（例: 1～100の範囲）"],
            ["デシジョンテーブル", "複数の条件の組み合わせを表形式で整理し、全ての組み合わせをテスト", "複数の条件がある場合（例: 会員・非会員、配送方法）"]
          ]
        },
        {
          "type": "text",
          "content": "**同値分割法（Equivalence Partitioning）**とは、入力値を同じ結果になるグループ（同値クラス）に分割し、各グループから代表値を1つ選んでテストする技法です。全ての入力値をテストするのは現実的ではないため、同値分割法により、テストケース数を削減しながら、効率的にテストできます。同値クラスは、①有効同値クラス（正しい入力値のグループ）、②無効同値クラス（エラーになる入力値のグループ）、に分類されます。"
        },
        {
          "type": "example",
          "title": "同値分割法の具体例：年齢による料金計算",
          "content": "【仕様】\n映画館の入場料金は、年齢により異なります。\n- 0～5歳: 無料（0円）\n- 6～17歳: 子供料金（1,000円）\n- 18～64歳: 大人料金（1,800円）\n- 65歳以上: シニア料金（1,200円）\n- 負の数、126歳以上: エラー（「無効な年齢」と表示）\n\n【同値分割】\n入力値（年齢）を同値クラスに分割:\n\n有効同値クラス:\n①0～5歳 → 無料（代表値: 3歳）\n②6～17歳 → 子供料金（代表値: 12歳）\n③18～64歳 → 大人料金（代表値: 30歳）\n④65歳以上（～125歳） → シニア料金（代表値: 70歳）\n\n無効同値クラス:\n⑤負の数 → エラー（代表値: -5）\n⑥126歳以上 → エラー（代表値: 150）\n\n【テストケース】\n| テストケース | 入力値（年齢） | 期待される出力 |\n|------------|--------------|---------------|\n| 1          | 3            | 0円（無料）    |\n| 2          | 12           | 1,000円       |\n| 3          | 30           | 1,800円       |\n| 4          | 70           | 1,200円       |\n| 5          | -5           | エラー        |\n| 6          | 150          | エラー        |\n\n同値分割法により、全ての年齢（0～125歳）をテストする代わりに、6つの代表値のみをテストすることで、効率的にテストできます。各同値クラスから1つの代表値を選ぶだけで、そのクラス全体の動作を検証できるという考え方です。"
        },
        {
          "type": "example",
          "title": "同値分割法の具体例：商品価格による送料計算",
          "content": "【仕様】\nECサイトの送料は、商品価格により異なります。\n- 0～2,999円: 送料800円\n- 3,000～4,999円: 送料500円\n- 5,000円以上: 送料無料（0円）\n- 負の数: エラー（「無効な価格」と表示）\n\n【同値分割】\n入力値（価格）を同値クラスに分割:\n\n有効同値クラス:\n①0～2,999円 → 送料800円（代表値: 1,500円）\n②3,000～4,999円 → 送料500円（代表値: 4,000円）\n③5,000円以上 → 送料無料（代表値: 10,000円）\n\n無効同値クラス:\n④負の数 → エラー（代表値: -100）\n\n【テストケース】\n| テストケース | 入力値（価格） | 期待される出力 |\n|------------|--------------|---------------|\n| 1          | 1,500        | 送料800円     |\n| 2          | 4,000        | 送料500円     |\n| 3          | 10,000       | 送料無料      |\n| 4          | -100         | エラー        |\n\n同値分割法により、4つのテストケースで全ての料金計算ロジックを検証できます。ただし、境界値（2,999円、3,000円、4,999円、5,000円）での動作は、境界値分析で検証する必要があります。"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "同値分割法の重要なポイント",
          "content": "同値分割法では、①各同値クラスから代表値を1つ選ぶ（通常は中央の値）、②有効同値クラスだけでなく、無効同値クラス（エラーケース）も必ずテストする、③境界値付近のバグは同値分割法では発見しづらいため、境界値分析と併用する、の3点が重要です。同値分割法は、テストケース数を削減しながら、効率的にテストできるため、実際のプロジェクトで広く使われています。"
        }
      ]
    },
    {
      "id": 3,
      "title": "境界値分析とデシジョンテーブル",
      "sections": [
        {
          "type": "text",
          "content": "**境界値分析（Boundary Value Analysis）**とは、同値クラスの境界値（最小値、最大値、境界の前後の値）を重点的にテストする技法です。経験上、バグは境界値付近で発生しやすいため、境界値分析により、バグを効率的に発見できます。境界値分析では、境界値、境界値-1、境界値+1の3つの値をテストします。同値分割法と併用するのが一般的です。"
        },
        {
          "type": "example",
          "title": "境界値分析の具体例：年齢による料金計算",
          "content": "【仕様（前ページと同じ）】\n映画館の入場料金は、年齢により異なります。\n- 0～5歳: 無料（0円）\n- 6～17歳: 子供料金（1,000円）\n- 18～64歳: 大人料金（1,800円）\n- 65歳以上: シニア料金（1,200円）\n- 負の数、126歳以上: エラー\n\n【境界値分析】\n境界値とその前後の値をテスト:\n\n境界値の候補: 0、5、6、17、18、64、65、125\n\n【テストケース（境界値分析）】\n| テストケース | 入力値（年齢） | 期待される出力 | 備考 |\n|------------|--------------|---------------|------|\n| 1          | -1           | エラー        | 0の前（無効同値クラス） |\n| 2          | 0            | 0円（無料）    | 0～5歳の最小値 |\n| 3          | 5            | 0円（無料）    | 0～5歳の最大値 |\n| 4          | 6            | 1,000円       | 6～17歳の最小値 |\n| 5          | 17           | 1,000円       | 6～17歳の最大値 |\n| 6          | 18           | 1,800円       | 18～64歳の最小値 |\n| 7          | 64           | 1,800円       | 18～64歳の最大値 |\n| 8          | 65           | 1,200円       | 65歳以上の最小値 |\n| 9          | 125          | 1,200円       | 65歳以上の最大値 |\n| 10         | 126          | エラー        | 126の後（無効同値クラス） |\n\n境界値分析により、境界付近のバグ（例: 「18歳が子供料金になる」「65歳が大人料金になる」）を発見できます。同値分割法の6ケースに加えて、境界値分析で10ケースをテストすることで、より網羅的なテストが可能です。"
        },
        {
          "type": "example",
          "title": "境界値分析の具体例：商品価格による送料計算",
          "content": "【仕様（前ページと同じ）】\nECサイトの送料は、商品価格により異なります。\n- 0～2,999円: 送料800円\n- 3,000～4,999円: 送料500円\n- 5,000円以上: 送料無料（0円）\n- 負の数: エラー\n\n【境界値分析】\n境界値とその前後の値をテスト:\n\n境界値の候補: 0、2,999、3,000、4,999、5,000\n\n【テストケース（境界値分析）】\n| テストケース | 入力値（価格） | 期待される出力 | 備考 |\n|------------|--------------|---------------|------|\n| 1          | -1           | エラー        | 0の前（無効同値クラス） |\n| 2          | 0            | 送料800円     | 0～2,999円の最小値 |\n| 3          | 2,999        | 送料800円     | 0～2,999円の最大値 |\n| 4          | 3,000        | 送料500円     | 3,000～4,999円の最小値 |\n| 5          | 4,999        | 送料500円     | 3,000～4,999円の最大値 |\n| 6          | 5,000        | 送料無料      | 5,000円以上の最小値 |\n| 7          | 10,000       | 送料無料      | 5,000円以上の代表値 |\n\n境界値分析により、境界付近のバグ（例: 「3,000円で送料800円が適用される」「5,000円で送料500円が適用される」）を発見できます。特に、プログラムで不等号（>=、>、<=、<）を間違えた場合、境界値でバグが発生します。"
        },
        {
          "type": "text",
          "content": "**デシジョンテーブル（Decision Table、決定表）**とは、複数の条件の組み合わせを表形式で整理し、全ての組み合わせに対する動作（アクション）を定義する技法です。複雑な条件分岐がある場合、デシジョンテーブルにより、漏れや矛盾を防ぎ、全ての組み合わせを網羅的にテストできます。デシジョンテーブルは、①条件（Condition）：判定する条件、②アクション（Action）：条件の組み合わせに対する動作、③ルール（Rule）：条件とアクションの組み合わせ、の3つで構成されます。"
        },
        {
          "type": "example",
          "title": "デシジョンテーブルの具体例：ECサイトの送料計算",
          "content": "【仕様】\nECサイトの送料は、以下の条件で決定されます。\n- 会員かどうか\n- 商品価格が5,000円以上かどうか\n- 速達配送を選択したかどうか\n\n【送料のルール】\n①会員かつ5,000円以上 → 送料無料（0円）\n②会員かつ5,000円未満かつ速達配送 → 送料500円\n③会員かつ5,000円未満かつ通常配送 → 送料300円\n④非会員かつ速達配送 → 送料500円\n⑤非会員かつ通常配送 → 送料300円\n\n【デシジョンテーブル】\n| ルール | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |\n|--------|---|---|---|---|---|---|---|---|\n| **条件** |\n| 会員？ | Y | Y | Y | Y | N | N | N | N |\n| 5,000円以上？ | Y | Y | N | N | Y | Y | N | N |\n| 速達配送？ | Y | N | Y | N | Y | N | Y | N |\n| **アクション** |\n| 送料無料（0円） | ○ | ○ | - | - | - | - | - | - |\n| 送料500円 | - | - | ○ | - | - | - | ○ | - |\n| 送料300円 | - | - | - | ○ | - | - | - | ○ |\n| 送料800円（非会員かつ5,000円以上） | - | - | - | - | ○ | ○ | - | - |\n\nY=Yes（真）、N=No（偽）、○=実行するアクション、-=実行しないアクション\n\n【テストケース】\nデシジョンテーブルの8つのルールに対応する8つのテストケースを作成:\n\n| テストケース | 会員？ | 価格 | 速達？ | 期待される送料 |\n|------------|--------|------|--------|---------------|\n| 1          | Yes    | 6,000 | Yes   | 0円           |\n| 2          | Yes    | 6,000 | No    | 0円           |\n| 3          | Yes    | 3,000 | Yes   | 500円         |\n| 4          | Yes    | 3,000 | No    | 300円         |\n| 5          | No     | 6,000 | Yes   | 800円         |\n| 6          | No     | 6,000 | No    | 800円         |\n| 7          | No     | 3,000 | Yes   | 500円         |\n| 8          | No     | 3,000 | No    | 300円         |\n\nデシジョンテーブルにより、複雑な条件分岐を整理でき、全ての組み合わせを網羅的にテストできます。"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "ブラックボックステスト技法の使い分け",
          "content": "①同値分割法: 入力値の範囲が広い場合（例: 年齢、価格）。テストケース数を削減しながら効率的にテスト。②境界値分析: 同値分割法と併用し、境界値付近のバグを発見。境界値、境界値-1、境界値+1をテスト。③デシジョンテーブル: 複数の条件がある場合（例: 会員・非会員、配送方法）。全ての組み合わせを網羅的にテスト。実際のプロジェクトでは、これらの技法を組み合わせて使用します。"
        }
      ]
    },
    {
      "id": 4,
      "title": "テストレベル（単体テスト、結合テスト、システムテスト、受入テスト）",
      "sections": [
        {
          "type": "text",
          "content": "**テストレベル（Test Level）**とは、テストの段階を表します。システム開発では、小さな単位から大きな単位へ、段階的にテストを実施します。主なテストレベルは、①**単体テスト（Unit Test）**、②**結合テスト（Integration Test）**、③**システムテスト（System Test）**、④**受入テスト（Acceptance Test）**、の4段階です。各テストレベルで、テスト対象、実施者、使用するテスト技法が異なります。"
        },
        {
          "type": "table",
          "headers": ["テストレベル", "テスト対象", "実施者", "主なテスト技法", "目的"],
          "rows": [
            ["単体テスト", "個々のモジュール（関数、クラス）", "開発者", "ホワイトボックステスト（命令網羅、判定条件網羅）", "各モジュールが設計通りに動作するか確認"],
            ["結合テスト", "複数のモジュールを組み合わせたもの", "開発者・テスト担当", "ブラックボックステスト（同値分割、境界値分析）", "モジュール間のインターフェースが正しいか確認"],
            ["システムテスト", "システム全体", "テスト担当者", "ブラックボックステスト、性能テスト、セキュリティテスト", "システム全体が要件を満たすか確認"],
            ["受入テスト", "本番環境に近い環境でのシステム全体", "ユーザー（発注者）", "実際の業務フロー", "実際の業務で使えるか確認"]
          ]
        },
        {
          "type": "text",
          "content": "**単体テスト（Unit Test）**とは、個々のモジュール（関数、クラス）が設計通りに動作するかを検証するテストです。開発者（プログラマ）が実施し、主にホワイトボックステスト技法を使用します。単体テストでは、テスト対象のモジュール以外の部分を**スタブ（Stub）**や**ドライバ（Driver）**という疑似モジュールで置き換えます。スタブは、テスト対象のモジュールが呼び出す下位モジュールの代わり（固定値を返す）、ドライバは、テスト対象のモジュールを呼び出す上位モジュールの代わり（テストデータを渡す）です。"
        },
        {
          "type": "example",
          "title": "単体テストの具体例：商品検索関数のテスト",
          "content": "【テスト対象】\n商品検索関数（searchProducts）\n機能: キーワード、カテゴリ、価格帯に合致する商品をデータベースから検索し、商品リストを返す\n\n【単体テストの手順】\n①テスト環境の準備:\n  - テスト用データベースを作成し、テストデータ（商品10件）を登録\n  - 本番のデータベースを使わないため、テストの影響を隔離\n\n②テストケースの作成（境界値分析と同値分割法を使用）:\n  - テストケース1: キーワード「ノートPC」で検索 → 商品名に「ノートPC」を含む商品が返ってくるか確認\n  - テストケース2: カテゴリID=1で検索 → カテゴリID=1の商品のみが返ってくるか確認\n  - テストケース3: 価格帯50,000～100,000円で検索 → 価格が範囲内の商品のみが返ってくるか確認\n  - テストケース4: 境界値（価格49,999円、50,000円、100,000円、100,001円）をテスト\n  - テストケース5: 検索結果が0件の場合 → 空のリストが返ってくるか確認\n  - テストケース6: 無効な入力（負の価格）→ エラーが返ってくるか確認\n\n③ホワイトボックステストの実施:\n  - カバレッジツールを使用し、判定条件網羅（C1）80%以上を確認\n  - 未実行のコードがあれば、追加のテストケースを作成\n\n④テスト結果の記録:\n  - 全てのテストケースが成功 → 単体テスト合格\n  - 失敗したテストケースがあれば → バグを修正して再テスト\n\n【スタブとドライバの使用例】\n商品検索関数は、データベースアクセスモジュール（getProducts）を呼び出します。単体テストでは、getProductsの代わりにスタブ（固定値を返す疑似モジュール）を使用し、商品検索関数のロジックのみをテストします。\n\nスタブの例:\n```\nfunction getProducts_stub(sql) {\n    // 固定値を返す（データベースにアクセスしない）\n    return [\n        {商品ID: 1, 商品名: \"ノートPC A\", 価格: 80000},\n        {商品ID: 2, 商品名: \"ノートPC B\", 価格: 120000}\n    ]\n}\n```\n\nスタブを使用することで、データベースの準備が不要になり、テストを高速化できます。"
        },
        {
          "type": "text",
          "content": "**結合テスト（Integration Test）**とは、複数のモジュールを組み合わせて、モジュール間のインターフェース（データの受け渡し）が正しいかを検証するテストです。開発者やテスト担当者が実施し、主にブラックボックステスト技法を使用します。結合テストには、①**トップダウンテスト**：上位モジュールから下位モジュールへ順番に結合、②**ボトムアップテスト**：下位モジュールから上位モジュールへ順番に結合、の2つの方法があります。トップダウンテストではスタブを使用し、ボトムアップテストではドライバを使用します。"
        },
        {
          "type": "example",
          "title": "結合テストの具体例：ECサイトの注文処理",
          "content": "【テスト対象】\n注文処理の結合テスト\nモジュール構成:\n- 注文画面（UI）\n- 注文コントローラ（ビジネスロジック）\n- 商品管理モジュール（在庫確認）\n- データベースアクセスモジュール\n\n【トップダウンテストの手順】\n①第1段階: 注文画面と注文コントローラを結合\n  - 注文画面から注文コントローラにcreateOrder()を呼び出す\n  - 注文コントローラが呼び出す商品管理モジュールとデータベースアクセスモジュールは、スタブ（固定値を返す）で代用\n  - テストケース: ユーザーが注文ボタンをクリック → 注文コントローラが正しく呼ばれるか確認\n\n②第2段階: 商品管理モジュールを結合（スタブを実モジュールに置き換え）\n  - 注文コントローラから商品管理モジュールにcheckStock()を呼び出す\n  - データベースアクセスモジュールは、まだスタブで代用\n  - テストケース: 在庫が十分な場合、在庫が不足している場合をテスト\n\n③第3段階: データベースアクセスモジュールを結合（スタブを実モジュールに置き換え）\n  - 商品管理モジュールからデータベースアクセスモジュールにgetStock()を呼び出す\n  - テストケース: データベースから正しく在庫数が取得できるか確認\n\n【ボトムアップテストの手順】\n①第1段階: データベースアクセスモジュールのテスト\n  - ドライバ（テストデータを渡す疑似モジュール）から、getStock()を呼び出す\n  - テストケース: データベースから正しく在庫数が取得できるか確認\n\n②第2段階: 商品管理モジュールを結合\n  - ドライバから、商品管理モジュールのcheckStock()を呼び出す\n  - 商品管理モジュールは、データベースアクセスモジュール（実モジュール）を呼び出す\n  - テストケース: 在庫が十分な場合、在庫が不足している場合をテスト\n\n③第3段階: 注文コントローラを結合\n  - ドライバから、注文コントローラのcreateOrder()を呼び出す\n  - 注文コントローラは、商品管理モジュール（実モジュール）を呼び出す\n  - テストケース: 注文が正しく登録されるか確認\n\n④第4段階: 注文画面を結合\n  - 実際の注文画面から、注文コントローラ（実モジュール）を呼び出す\n  - 全てのモジュールが実モジュールになり、結合テストが完了\n  - テストケース: ユーザーが注文ボタンをクリック → 注文が完了するまでの一連の流れを確認\n\n【トップダウンテストとボトムアップテストの比較】\n- トップダウンテスト: 上位モジュール（UI）から開発できる。早期に画面を確認できる。スタブの作成が必要。\n- ボトムアップテスト: 下位モジュール（データベースアクセス）から開発できる。基盤部分の品質を早期に確保できる。ドライバの作成が必要。\n\n実際のプロジェクトでは、トップダウンテストとボトムアップテストを組み合わせる（サンドイッチテスト）ことが多いです。"
        },
        {
          "type": "text",
          "content": "**システムテスト（System Test）**とは、システム全体が要件定義を満たすかを検証するテストです。テスト担当者が実施し、主にブラックボックステスト技法を使用します。システムテストでは、①機能テスト：全ての機能が正しく動作するか確認、②性能テスト：応答時間、スループットが要件を満たすか確認、③セキュリティテスト：脆弱性がないか確認、④使いやすさテスト（ユーザビリティテスト）：ユーザーが使いやすいか確認、などを実施します。"
        },
        {
          "type": "text",
          "content": "**受入テスト（Acceptance Test、運用テスト）**とは、本番環境に近い環境で、ユーザー（発注者）が実際の業務フローを実行し、システムが実際の業務で使えるかを確認するテストです。受入テストに合格すれば、システムが「受け入れ」られ、本番稼働に進みます。受入テストは、ユーザーが主体となって実施し、実際の業務データ（個人情報はマスキング）を使用します。"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "テストレベルの重要性",
          "content": "テストは、単体テスト→結合テスト→システムテスト→受入テストの順に実施し、各段階でバグを発見・修正することが重要です。一般的に、バグの修正コストは、発見が遅れるほど高くなります。単体テストでバグを発見すれば、該当モジュールのみ修正すればよいですが、受入テスト（本番稼働後）でバグを発見すると、大規模な修正が必要になり、コストが100倍以上になることもあります。各テストレベルで網羅的にテストし、品質を確保することが重要です。"
        }
      ]
    },
    {
      "id": 5,
      "title": "回帰テストとその他のテスト技法",
      "sections": [
        {
          "type": "text",
          "content": "**回帰テスト（Regression Test、リグレッションテスト、退行テスト）**とは、プログラムを修正（バグ修正、機能追加）した後、修正によって既存の機能に悪影響がないか（デグレードが発生していないか）を確認するテストです。プログラムの一部を修正すると、予期せず別の部分に影響が出ることがあります（デグレード、退行）。回帰テストにより、修正による副作用を発見できます。回帰テストでは、過去に実施したテストケースを再実行します。"
        },
        {
          "type": "example",
          "title": "回帰テストの具体例：ECサイトのバグ修正",
          "content": "【状況】\nECサイトの商品検索機能にバグが発見されました。\nバグ: 価格帯を指定すると、検索結果が0件になる\n原因: 価格帯の比較演算子が間違っていた（>= を > に修正）\n\n【バグ修正】\nプログラマが、商品検索関数のコードを修正しました。\n\n修正前:\n```\nif (price > min_price && price < max_price) {\n    // 商品を検索結果に追加\n}\n```\n\n修正後:\n```\nif (price >= min_price && price <= max_price) {\n    // 商品を検索結果に追加\n}\n```\n\n【回帰テストの実施】\n①修正した機能のテスト:\n  - 価格帯50,000～100,000円で検索 → 価格が範囲内の商品が返ってくるか確認\n  - 境界値（50,000円、100,000円）をテスト → 正しく検索されるか確認\n  - バグが修正されたことを確認\n\n②既存機能のテスト（回帰テスト）:\n  - キーワード検索 → 修正前と同じ結果が返ってくるか確認\n  - カテゴリ検索 → 修正前と同じ結果が返ってくるか確認\n  - 注文機能 → 修正前と同じく注文できるか確認\n  - カート機能 → 修正前と同じくカートに追加できるか確認\n  - 過去のテストケース（100ケース）を再実行し、全て成功することを確認\n\n③回帰テストの結果:\n  - 全てのテストケースが成功 → 修正による副作用がないことを確認\n  - もし失敗したテストケースがあれば → デグレード（既存機能の劣化）が発生 → 再修正が必要\n\n【回帰テストの自動化】\n回帰テストは、毎回同じテストケースを実行するため、手動で実施すると時間がかかります。そのため、テスト自動化ツール（Selenium、JUnitなど）を使用し、回帰テストを自動化することが推奨されます。自動化により、回帰テストを頻繁に実行でき、品質を確保できます。特に、アジャイル開発やDevOpsでは、1日に複数回リリースするため、回帰テストの自動化が不可欠です。"
        },
        {
          "type": "text",
          "content": "その他の重要なテスト技法として、①**探索的テスト（Exploratory Testing）**：テストケースを事前に作成せず、テスト実行中に探索的にテストする技法。仕様が不明確な場合や、予期しないバグを発見したい場合に有効。②**α（アルファ）テスト**：開発者の環境で、開発チーム以外の社員がテストする（社内テスト）。③**β（ベータ）テスト**：実際のユーザー（限定公開）にテストしてもらう（社外テスト）。フィードバックを得て、品質を改善。④**煙テスト（Smoke Test）**：システムの主要機能が動作するかを簡易的にテスト。ビルド後、すぐに実施し、重大なバグがないか確認。⑤**負荷テスト（Load Test）**：同時アクセス数を増やし、システムが要件を満たすか確認（例: 1,000人同時アクセスで応答時間が1秒以内か）。⑥**ストレステスト（Stress Test）**：システムの限界を超える負荷をかけ、どこまで耐えられるかを確認（例: 10,000人同時アクセスでもシステムがダウンしないか）。"
        },
        {
          "type": "table",
          "headers": ["テスト技法", "目的", "実施タイミング"],
          "rows": [
            ["回帰テスト", "修正による副作用（デグレード）がないか確認", "バグ修正、機能追加の後"],
            ["探索的テスト", "予期しないバグを発見", "仕様が不明確な場合"],
            ["αテスト", "社内でのテスト", "システムテストの後"],
            ["βテスト", "実際のユーザーにテストしてもらう", "αテストの後"],
            ["煙テスト", "主要機能が動作するか簡易的にテスト", "ビルド後すぐ"],
            ["負荷テスト", "同時アクセス数に耐えられるか確認", "システムテスト"],
            ["ストレステスト", "限界を超える負荷に耐えられるか確認", "システムテスト"]
          ]
        },
        {
          "type": "example",
          "title": "実際のプロジェクトにおけるテスト技法の使い分け",
          "content": "【プロジェクト: ECサイトの開発】\n\n①単体テスト（開発者）:\n  - ホワイトボックステスト（判定条件網羅80%以上）\n  - 商品検索関数、注文処理関数などをテスト\n  - テスト自動化（JUnit）で、毎日実行\n\n②結合テスト（開発者・テスト担当）:\n  - ブラックボックステスト（同値分割、境界値分析）\n  - 注文画面 + 注文コントローラ + 商品管理モジュールを結合してテスト\n  - トップダウンテストで実施\n\n③システムテスト（テスト担当者）:\n  - 機能テスト: 全ての機能（商品検索、注文、決済、管理者機能）をテスト\n  - 性能テスト: 同時アクセス数1,000人で応答時間が1秒以内か確認（負荷テスト）\n  - セキュリティテスト: SQLインジェクション、XSSなどの脆弱性をテスト\n  - 使いやすさテスト: スマートフォンでも使いやすいか確認\n\n④受入テスト（ユーザー）:\n  - 実際のユーザー（発注者）が、実際の業務フロー（商品検索→カート追加→注文→決済）を実行\n  - 問題がなければ「受け入れ」を承認\n\n⑤回帰テスト（開発者・テスト担当）:\n  - バグ修正の後、過去のテストケース（1,000ケース）を再実行\n  - テスト自動化（Selenium）で、毎日実行\n\n⑥βテスト（実際のユーザー）:\n  - 限定公開（100人のユーザー）にテストしてもらう\n  - フィードバックを得て、バグ修正、UI改善を実施\n\n⑦本番稼働:\n  - 煙テスト: 本番環境で、主要機能（トップページ、商品検索、注文）が動作するか確認\n  - 監視ツールで、サーバの負荷、エラーログを監視\n\nこのように、テスト技法を段階的に組み合わせることで、品質を確保しながら、効率的にテストを実施できます。"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "テスト技法の選択とテスト自動化",
          "content": "テスト技法は、テストレベル、品質要件、コストに応じて選択します。一般的には、①単体テスト: ホワイトボックステスト（命令網羅、判定条件網羅）、②結合テスト・システムテスト: ブラックボックステスト（同値分割、境界値分析、デシジョンテーブル）、③修正後: 回帰テスト、の組み合わせが推奨されます。また、テストの効率化のために、テスト自動化ツール（JUnit、Selenium、JMeterなど）を使用し、単体テスト、回帰テスト、負荷テストを自動化することが重要です。自動化により、テストを頻繁に実行でき、品質を継続的に確保できます（継続的インテグレーション、CI）。"
        }
      ]
    }
  ]
}
