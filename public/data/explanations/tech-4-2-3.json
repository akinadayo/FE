{
  "topicId": "tech-4-2-3",
  "title": "オブジェクト指向",
  "pages": [
    {
      "id": 1,
      "title": "オブジェクト指向とクラス・インスタンス",
      "sections": [
        {
          "type": "text",
          "content": "**オブジェクト指向プログラミング（Object-Oriented Programming、OOP）**とは、データ（属性）と処理（メソッド）をまとめた**オブジェクト**を中心にプログラムを設計・実装する手法です。オブジェクト指向の主な特徴は、①**カプセル化（Encapsulation）**、②**継承（Inheritance）**、③**ポリモーフィズム（Polymorphism）**、の3つです。オブジェクト指向の利点は、①再利用性が高い（既存のクラスを再利用できる）、②保守性が高い（変更の影響範囲が限定される）、③拡張性が高い（新しい機能を追加しやすい）、です。代表的な言語として、Java、C++、Python があります。"
        },
        {
          "type": "text",
          "content": "**クラス（Class）**とは、オブジェクトの設計図（テンプレート）です。クラスには、データを表す**属性（フィールド、プロパティ）**と、処理を表す**メソッド（関数）**が定義されます。**インスタンス（Instance）**とは、クラスを基に生成された実体（オブジェクト）です。クラスが「設計図」であり、インスタンスが「設計図を基に作られた製品」に相当します。例えば、「車」というクラスを定義し、そのクラスから「佐藤さんの車」「田中さんの車」という複数のインスタンスを生成できます。"
        },
        {
          "type": "example",
          "title": "クラスとインスタンスの具体例：車クラス",
          "content": "【クラス定義（Java）】\n```java\npublic class Car {\n    // 属性（フィールド）\n    String color;      // 色\n    int speed;         // 速度\n    String owner;      // 所有者\n    \n    // メソッド\n    public void accelerate() {\n        speed += 10;\n        System.out.println(\"加速しました。現在の速度: \" + speed + \"km/h\");\n    }\n    \n    public void brake() {\n        speed -= 10;\n        System.out.println(\"減速しました。現在の速度: \" + speed + \"km/h\");\n    }\n}\n```\n\n【インスタンス生成と操作】\n```java\n// 佐藤さんの車（インスタンス1）\nCar satoCar = new Car();\nsatoCar.color = \"赤\";\nsatoCar.speed = 0;\nsatoCar.owner = \"佐藤\";\nsatoCar.accelerate();  // 出力: 加速しました。現在の速度: 10km/h\n\n// 田中さんの車（インスタンス2）\nCar tanakaCar = new Car();\ntanakaCar.color = \"青\";\ntanakaCar.speed = 0;\ntanakaCar.owner = \"田中\";\ntanakaCar.accelerate();  // 出力: 加速しました。現在の速度: 10km/h\n```\n\n【説明】\n①クラス（Car）：車の設計図。属性（color, speed, owner）とメソッド（accelerate, brake）を定義。\n②インスタンス（satoCar, tanakaCar）：クラスを基に生成された実体。それぞれ独立した属性値を持つ。\n③satoCar.accelerate() を呼び出すと、satoCar の speed が 10 増加（tanakaCar の speed は変わらない）。"
        },
        {
          "type": "table",
          "headers": ["用語", "説明", "具体例"],
          "rows": [
            ["クラス（Class）", "オブジェクトの設計図", "Car クラス（車の設計図）"],
            ["インスタンス（Instance）", "クラスを基に生成された実体", "satoCar（佐藤さんの車）、tanakaCar（田中さんの車）"],
            ["属性（フィールド）", "オブジェクトのデータ", "color（色）、speed（速度）、owner（所有者）"],
            ["メソッド", "オブジェクトの処理", "accelerate()（加速）、brake()（減速）"]
          ]
        }
      ]
    },
    {
      "id": 2,
      "title": "カプセル化（情報隠蔽）",
      "sections": [
        {
          "type": "text",
          "content": "**カプセル化（Encapsulation）**とは、データ（属性）と処理（メソッド）を1つのクラスにまとめ、外部から直接アクセスできないように隠蔽する仕組みです。カプセル化により、**情報隠蔽（Information Hiding）**が実現されます。情報隠蔽の目的は、①データの不正な変更を防ぐ、②クラス内部の実装を隠し、インターフェース（公開メソッド）のみを外部に公開する、③変更の影響範囲を限定する、です。カプセル化を実現するために、**アクセス修飾子（public, private, protected）**を使います。"
        },
        {
          "type": "table",
          "headers": ["アクセス修飾子", "説明", "アクセス可能範囲"],
          "rows": [
            ["public", "どこからでもアクセス可能", "クラス内、同じパッケージ、サブクラス、外部クラス"],
            ["private", "クラス内部のみアクセス可能", "クラス内のみ"],
            ["protected", "同じパッケージとサブクラスからアクセス可能", "クラス内、同じパッケージ、サブクラス"],
            ["（なし、package-private）", "同じパッケージ内からアクセス可能", "クラス内、同じパッケージ"]
          ]
        },
        {
          "type": "example",
          "title": "カプセル化の具体例：銀行口座クラス",
          "content": "【カプセル化なし（問題あり）】\n```java\npublic class BankAccount {\n    public int balance;  // 残高（public: 外部から直接アクセス可能）\n}\n\n// 外部からの操作\nBankAccount account = new BankAccount();\naccount.balance = 10000;  // 初期残高\naccount.balance = -5000;  // 問題: 残高がマイナスになる（不正な変更）\n```\n→ 問題: balance が public のため、外部から直接変更でき、残高がマイナスになる不正な操作が可能。\n\n【カプセル化あり（問題解決）】\n```java\npublic class BankAccount {\n    private int balance;  // 残高（private: 外部から直接アクセス不可）\n    \n    // 残高を取得（getter）\n    public int getBalance() {\n        return balance;\n    }\n    \n    // 預金（deposit）\n    public void deposit(int amount) {\n        if (amount > 0) {\n            balance += amount;\n            System.out.println(amount + \"円を預金しました。残高: \" + balance + \"円\");\n        } else {\n            System.out.println(\"エラー: 預金額は正の数でなければなりません。\");\n        }\n    }\n    \n    // 引き出し（withdraw）\n    public void withdraw(int amount) {\n        if (amount > 0 && amount <= balance) {\n            balance -= amount;\n            System.out.println(amount + \"円を引き出しました。残高: \" + balance + \"円\");\n        } else {\n            System.out.println(\"エラー: 引き出し額が不正です。\");\n        }\n    }\n}\n\n// 外部からの操作\nBankAccount account = new BankAccount();\naccount.deposit(10000);   // 出力: 10000円を預金しました。残高: 10000円\naccount.withdraw(5000);   // 出力: 5000円を引き出しました。残高: 5000円\naccount.withdraw(10000);  // 出力: エラー: 引き出し額が不正です。\n// account.balance = -5000;  // コンパイルエラー: balance は private のため直接アクセス不可\n```\n→ 解決: balance を private にし、deposit と withdraw メソッド（public）経由でのみ変更可能に。メソッド内で入力値をチェックし、不正な操作を防ぐ。"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "カプセル化の利点",
          "content": "①データの保護：不正な変更を防ぐ（例: 残高がマイナスにならない）\n②変更の影響範囲を限定：クラス内部の実装を変更しても、外部には影響しない（例: balance の型を int から double に変更しても、getter/setter のシグネチャは変わらない）\n③インターフェースの明確化：公開メソッド（public）のみが外部に公開され、使い方が明確\n\nカプセル化のベストプラクティス：属性は private、メソッドは public（必要に応じて）"
        }
      ]
    },
    {
      "id": 3,
      "title": "継承（汎化と特化）",
      "sections": [
        {
          "type": "text",
          "content": "**継承（Inheritance）**とは、既存のクラス（**親クラス、スーパークラス、基底クラス**）の属性とメソッドを引き継いで、新しいクラス（**子クラス、サブクラス、派生クラス**）を定義する仕組みです。継承により、コードの再利用性が高まります。継承には、①**汎化（Generalization）**：複数のクラスから共通部分を抽出して親クラスを作成、②**特化（Specialization）**：親クラスを継承して、子クラスに固有の属性やメソッドを追加、という2つの方向があります。Java では extends キーワードを使って継承を実現します。"
        },
        {
          "type": "example",
          "title": "継承の具体例：動物クラスの階層",
          "content": "【親クラス: Animal（動物）】\n```java\npublic class Animal {\n    protected String name;  // 名前（protected: サブクラスからアクセス可能）\n    \n    public void eat() {\n        System.out.println(name + \"が食べています。\");\n    }\n    \n    public void sleep() {\n        System.out.println(name + \"が寝ています。\");\n    }\n}\n```\n\n【子クラス1: Dog（犬）】\n```java\npublic class Dog extends Animal {  // Animal を継承\n    public void bark() {  // Dog 固有のメソッド\n        System.out.println(name + \"がワンワン吠えています。\");\n    }\n}\n```\n\n【子クラス2: Cat（猫）】\n```java\npublic class Cat extends Animal {  // Animal を継承\n    public void meow() {  // Cat 固有のメソッド\n        System.out.println(name + \"がニャーニャー鳴いています。\");\n    }\n}\n```\n\n【使用例】\n```java\nDog dog = new Dog();\ndog.name = \"ポチ\";\ndog.eat();   // 出力: ポチが食べています。（Animal から継承）\ndog.sleep(); // 出力: ポチが寝ています。（Animal から継承）\ndog.bark();  // 出力: ポチがワンワン吠えています。（Dog 固有）\n\nCat cat = new Cat();\ncat.name = \"タマ\";\ncat.eat();   // 出力: タマが食べています。（Animal から継承）\ncat.sleep(); // 出力: タマが寝ています。（Animal から継承）\ncat.meow();  // 出力: タマがニャーニャー鳴いています。（Cat 固有）\n```\n\n【説明】\n①親クラス（Animal）：全ての動物に共通の属性（name）とメソッド（eat, sleep）を定義\n②子クラス（Dog, Cat）：Animal を継承し、親クラスの属性とメソッドを引き継ぐ + 固有のメソッド（bark, meow）を追加\n③Dog と Cat は、eat と sleep メソッドを再定義せずに利用可能（コードの再利用）"
        },
        {
          "type": "table",
          "headers": ["用語", "説明", "具体例"],
          "rows": [
            ["親クラス（スーパークラス）", "継承される側のクラス", "Animal（動物）"],
            ["子クラス（サブクラス）", "継承する側のクラス", "Dog（犬）、Cat（猫）"],
            ["汎化（Generalization）", "複数のクラスから共通部分を抽出", "Dog と Cat から Animal を抽出"],
            ["特化（Specialization）", "親クラスを継承して固有の機能を追加", "Animal を継承して Dog に bark メソッドを追加"]
          ]
        },
        {
          "type": "highlight",
          "icon": "🔧",
          "title": "オーバーライド（上書き）",
          "content": "子クラスで、親クラスのメソッドを再定義することを**オーバーライド（Override）**と呼びます。\n\n例：\n```java\npublic class Dog extends Animal {\n    @Override\n    public void eat() {  // Animal の eat メソッドを上書き\n        System.out.println(name + \"がドッグフードを食べています。\");\n    }\n}\n\nDog dog = new Dog();\ndog.name = \"ポチ\";\ndog.eat();  // 出力: ポチがドッグフードを食べています。（上書きされたメソッドが呼ばれる）\n```\n\nオーバーライドにより、子クラスで親クラスのメソッドの振る舞いを変更できます。"
        }
      ]
    },
    {
      "id": 4,
      "title": "ポリモーフィズム（多態性）",
      "sections": [
        {
          "type": "text",
          "content": "**ポリモーフィズム（Polymorphism、多態性）**とは、「同じメソッド名でも、オブジェクトの型によって異なる処理が実行される」という性質です。ポリモーフィズムにより、異なるクラスのオブジェクトを統一的に扱えます。ポリモーフィズムには、①**オーバーロード（Overload）**：同じメソッド名で、引数の型や個数が異なるメソッドを複数定義、②**オーバーライド（Override）**：子クラスで親クラスのメソッドを再定義、の2種類があります。オーバーライドによるポリモーフィズムが、オブジェクト指向の強力な特徴です。"
        },
        {
          "type": "example",
          "title": "ポリモーフィズムの具体例：動物の鳴き声",
          "content": "【親クラス: Animal】\n```java\npublic class Animal {\n    protected String name;\n    \n    public void makeSound() {  // 鳴き声を出す\n        System.out.println(name + \"が鳴いています。\");\n    }\n}\n```\n\n【子クラス: Dog】\n```java\npublic class Dog extends Animal {\n    @Override\n    public void makeSound() {  // オーバーライド\n        System.out.println(name + \"がワンワン鳴いています。\");\n    }\n}\n```\n\n【子クラス: Cat】\n```java\npublic class Cat extends Animal {\n    @Override\n    public void makeSound() {  // オーバーライド\n        System.out.println(name + \"がニャーニャー鳴いています。\");\n    }\n}\n```\n\n【ポリモーフィズムの活用】\n```java\n// Animal 型の変数に Dog や Cat のインスタンスを代入可能（アップキャスト）\nAnimal animal1 = new Dog();\nanimal1.name = \"ポチ\";\nanimal1.makeSound();  // 出力: ポチがワンワン鳴いています。（Dog の makeSound が呼ばれる）\n\nAnimal animal2 = new Cat();\nanimal2.name = \"タマ\";\nanimal2.makeSound();  // 出力: タマがニャーニャー鳴いています。（Cat の makeSound が呼ばれる）\n\n// 配列で複数の動物を統一的に扱う\nAnimal[] animals = {new Dog(), new Cat(), new Dog()};\nanimals[0].name = \"ポチ\";\nanimals[1].name = \"タマ\";\nanimals[2].name = \"シロ\";\n\nfor (Animal animal : animals) {\n    animal.makeSound();  // 各オブジェクトの実際の型に応じたメソッドが呼ばれる\n}\n// 出力:\n// ポチがワンワン鳴いています。\n// タマがニャーニャー鳴いています。\n// シロがワンワン鳴いています。\n```\n\n【説明】\n①Animal 型の変数（animal1, animal2）に、Dog や Cat のインスタンスを代入可能（親クラス型の変数に子クラスのインスタンスを代入できる）\n②animal1.makeSound() を呼び出すと、実際のオブジェクト（Dog）の makeSound メソッドが呼ばれる（動的束縛）\n③配列 animals で、Dog と Cat を統一的に扱える（同じ Animal 型として扱う）"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "ポリモーフィズムの利点",
          "content": "①拡張性：新しい動物クラス（例: Bird）を追加しても、既存のコード（for ループ）を変更せずに対応できる\n②統一的な処理：異なるクラスのオブジェクトを同じインターフェース（makeSound メソッド）で扱える\n③コードの簡潔化：if-else で型を判定する必要がない\n\n例: 新しい動物 Bird を追加\n```java\npublic class Bird extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(name + \"がチュンチュン鳴いています。\");\n    }\n}\n\nAnimal[] animals = {new Dog(), new Cat(), new Bird()};\nfor (Animal animal : animals) {\n    animal.makeSound();  // Bird も含めて統一的に処理\n}\n```\n→ 既存のコード（for ループ）を変更せずに、新しい動物を追加できる"
        }
      ]
    },
    {
      "id": 5,
      "title": "集約と分解、その他の概念",
      "sections": [
        {
          "type": "text",
          "content": "**集約（Aggregation）**とは、複数のオブジェクトを組み合わせて、1つの大きなオブジェクトを構成する関係です。例えば、「車」は「エンジン」「タイヤ」「ハンドル」などのオブジェクトで構成されます。集約には、①**コンポジション（Composition、強い集約）**：部品が全体に強く依存し、全体が削除されると部品も削除される、②**アグリゲーション（Aggregation、弱い集約）**：部品が全体に弱く依存し、全体が削除されても部品は残る、の2種類があります。**分解（Decomposition）**とは、複雑なシステムを小さな部品（クラス）に分割することです。"
        },
        {
          "type": "example",
          "title": "集約の具体例：車と部品",
          "content": "【コンポジション（強い集約）】\n```java\npublic class Engine {  // エンジン\n    public void start() {\n        System.out.println(\"エンジンが始動しました。\");\n    }\n}\n\npublic class Car {\n    private Engine engine;  // Car が Engine を持つ（コンポジション）\n    \n    public Car() {\n        engine = new Engine();  // Car のコンストラクタで Engine を生成\n    }\n    \n    public void start() {\n        engine.start();\n        System.out.println(\"車が発進しました。\");\n    }\n}\n\nCar car = new Car();\ncar.start();\n// 出力:\n// エンジンが始動しました。\n// 車が発進しました。\n```\n→ コンポジション: Car が Engine を内部で生成・管理。Car が削除されると Engine も削除される（強い依存関係）。\n\n【アグリゲーション（弱い集約）】\n```java\npublic class Driver {  // 運転手\n    private String name;\n    public Driver(String name) {\n        this.name = name;\n    }\n    public String getName() {\n        return name;\n    }\n}\n\npublic class Car {\n    private Driver driver;  // Car が Driver を持つ（アグリゲーション）\n    \n    public void setDriver(Driver driver) {  // 外部から Driver を設定\n        this.driver = driver;\n    }\n    \n    public void drive() {\n        System.out.println(driver.getName() + \"が運転しています。\");\n    }\n}\n\nDriver sato = new Driver(\"佐藤\");\nCar car = new Car();\ncar.setDriver(sato);  // 外部で生成した Driver を Car に設定\ncar.drive();  // 出力: 佐藤が運転しています。\n```\n→ アグリゲーション: Driver は外部で生成され、Car に設定される。Car が削除されても Driver は残る（弱い依存関係）。"
        },
        {
          "type": "table",
          "headers": ["概念", "説明", "具体例"],
          "rows": [
            ["集約（Aggregation）", "複数のオブジェクトを組み合わせて1つの大きなオブジェクトを構成", "車 = エンジン + タイヤ + ハンドル"],
            ["コンポジション（Composition）", "強い集約。部品が全体に強く依存", "車とエンジン（車が削除されるとエンジンも削除）"],
            ["アグリゲーション（Aggregation）", "弱い集約。部品が全体に弱く依存", "車と運転手（車が削除されても運転手は残る）"],
            ["分解（Decomposition）", "複雑なシステムを小さな部品に分割", "車を エンジン、タイヤ、ハンドル に分解"]
          ]
        },
        {
          "type": "highlight",
          "icon": "📌",
          "title": "その他のオブジェクト指向概念",
          "content": "①抽象クラス（Abstract Class）：インスタンスを生成できないクラス。子クラスで実装を強制するための設計図。\n例：abstract class Animal { abstract void makeSound(); }\n\n②インターフェース（Interface）：抽象メソッドのみを定義する「契約」。複数のクラスで共通のメソッドを強制。\n例：interface Flyable { void fly(); } → Bird と Airplane が実装\n\n③コンストラクタ（Constructor）：インスタンス生成時に呼ばれる特殊なメソッド。初期化処理を記述。\n例：public Car(String color) { this.color = color; }\n\n④ガベージコレクション（Garbage Collection）：不要になったオブジェクトを自動的にメモリから削除する仕組み（Java、Pythonなど）。"
        }
      ]
    }
  ]
}
