{
  "topicId": "tech-4-2-2",
  "title": "プログラミング",
  "pages": [
    {
      "id": 1,
      "title": "プログラミング言語の世代と分類",
      "sections": [
        {
          "type": "text",
          "content": "**プログラミング言語**とは、コンピュータに命令を与えるための人工言語です。プログラミング言語は、**低級言語（Low-level Language）**と**高級言語（High-level Language）**に大別されます。低級言語は、CPUが直接理解できる機械語やアセンブリ言語で、ハードウェアに近い処理を記述できますが、人間にとっては理解しづらいです。高級言語は、人間にとって理解しやすい英語に近い構文で記述でき、C言語、Java、Python などがあります。高級言語で書かれたプログラム（ソースコード）は、コンパイラやインタプリタによって機械語に変換されて実行されます。"
        },
        {
          "type": "table",
          "headers": ["世代", "言語", "特徴", "具体例"],
          "rows": [
            ["第1世代", "機械語（Machine Language）", "0と1のビット列。CPUが直接実行できる。人間には理解困難。", "10110000 01100001"],
            ["第2世代", "アセンブリ言語（Assembly Language）", "機械語を人間が読みやすい記号（ニーモニック）で表現。MOV、ADD など。", "MOV AL, 61h\nADD AL, BL"],
            ["第3世代", "高級言語（High-level Language）", "人間が理解しやすい英語に近い構文。C、Java、Python など。", "int x = 5;\nx = x + 10;"],
            ["第4世代", "4GL（Fourth-Generation Language）", "さらに高レベル。SQL、Excel マクロなど。", "SELECT * FROM users WHERE age >= 20;"]
          ]
        },
        {
          "type": "example",
          "title": "同じ処理を異なる世代の言語で記述",
          "content": "【処理内容】\n変数 x に 5 を代入し、x に 10 を加算する。\n\n【機械語（第1世代）】\n10110000 00000101  （MOV AL, 5 に相当）\n00000100 00001010  （ADD AL, 10 に相当）\n→ 人間には理解困難\n\n【アセンブリ言語（第2世代）】\nMOV AL, 5   ; AL レジスタに 5 を代入\nADD AL, 10  ; AL レジスタに 10 を加算\n→ 機械語より読みやすいが、CPUの命令を直接記述するため、まだ難しい\n\n【C言語（第3世代）】\nint x = 5;   // x に 5 を代入\nx = x + 10;  // x に 10 を加算\n→ 人間が理解しやすい英語に近い構文\n\n【Python（第3世代）】\nx = 5       # x に 5 を代入\nx = x + 10  # x に 10 を加算\n→ C言語よりさらに簡潔"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "低級言語 vs 高級言語",
          "content": "低級言語（機械語、アセンブリ言語）：\n①CPUに近い（ハードウェアを直接制御できる）\n②実行速度が速い（機械語に変換する手間が少ない）\n③記述が難しい（人間にとって理解困難）\n④移植性が低い（CPUごとに命令セットが異なる）\n\n高級言語（C、Java、Python など）：\n①人間に近い（英語に近い構文で理解しやすい）\n②実行速度がやや遅い（機械語に変換する手間がかかる）\n③記述が容易（人間にとって理解しやすい）\n④移植性が高い（異なるCPUでも同じコードが動く）"
        }
      ]
    },
    {
      "id": 2,
      "title": "コンパイラとインタプリタ",
      "sections": [
        {
          "type": "text",
          "content": "高級言語で書かれたプログラム（**ソースコード**）は、CPUが直接実行できないため、機械語に変換する必要があります。変換方法には、**コンパイラ方式**と**インタプリタ方式**の2つがあります。**コンパイラ（Compiler）**は、ソースコード全体を事前に機械語（オブジェクトコード）に変換し、その後、実行します。**インタプリタ（Interpreter）**は、ソースコードを1行ずつ読み取り、その場で機械語に変換して実行します。コンパイラ方式は実行速度が速いですが、インタプリタ方式は開発が容易です。"
        },
        {
          "type": "table",
          "headers": ["項目", "コンパイラ方式", "インタプリタ方式"],
          "rows": [
            ["変換タイミング", "事前に全体を変換（コンパイル時）", "実行時に1行ずつ変換"],
            ["実行速度", "速い（事前に機械語に変換済み）", "遅い（毎回変換が必要）"],
            ["開発効率", "やや低い（コンパイルに時間がかかる）", "高い（すぐに実行できる）"],
            ["デバッグ", "やや難しい（コンパイルが必要）", "容易（すぐに実行して確認できる）"],
            ["具体例", "C、C++、Java（バイトコードにコンパイル）", "Python、Ruby、JavaScript"]
          ]
        },
        {
          "type": "example",
          "title": "コンパイラ方式 vs インタプリタ方式の処理フロー",
          "content": "【コンパイラ方式（C言語の例）】\nステップ1：ソースコード（main.c）を作成\n```c\n#include <stdio.h>\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\n```\n\nステップ2：コンパイラ（gcc）でコンパイル\ngcc main.c -o main.exe\n→ ソースコード全体を機械語（main.exe）に変換（時間がかかる）\n\nステップ3：実行\n./main.exe\n→ 機械語を直接実行（速い）\n\n【インタプリタ方式（Python の例）】\nステップ1：ソースコード（main.py）を作成\n```python\nprint(\"Hello, World!\")\n```\n\nステップ2：実行（コンパイル不要）\npython main.py\n→ インタプリタ（python）がソースコードを1行ずつ読み取り、その場で機械語に変換して実行（コンパイル時間が不要だが、実行速度がやや遅い）\n\n【違いのまとめ】\nコンパイラ方式：「コンパイル（翻訳）→ 実行」の2段階。実行速度が速いが、コンパイルに時間がかかる。\nインタプリタ方式：「実行（翻訳と実行を同時）」の1段階。開発が容易だが、実行速度がやや遅い。"
        },
        {
          "type": "highlight",
          "icon": "🔧",
          "title": "中間コード方式（Java、C#）",
          "content": "Java や C# は、コンパイラとインタプリタの両方の特徴を持つ「中間コード方式」を採用しています。\n\nJava の処理フロー：\n①ソースコード（.java）をコンパイラ（javac）でバイトコード（.class）に変換（中間コード）\n②JVM（Java仮想マシン）がバイトコードを1行ずつ解釈して実行（またはJITコンパイルで機械語に変換）\n\n利点：\n①移植性が高い（バイトコードはどのOSでも実行可能）\n②コンパイラ方式とインタプリタ方式の長所を両立"
        }
      ]
    },
    {
      "id": 3,
      "title": "ビルドプロセス：プリプロセッサ、コンパイラ、リンカ、ローダ",
      "sections": [
        {
          "type": "text",
          "content": "C言語などのコンパイラ言語では、ソースコードから実行可能ファイルを生成するまでに、①**プリプロセッサ（Preprocessor）**、②**コンパイラ（Compiler）**、③**リンカ（Linker）**、④**ローダ（Loader）**、の4つの処理が必要です。プリプロセッサはソースコードの前処理（#include や #define の展開）、コンパイラはソースコードをオブジェクトコード（機械語）に変換、リンカは複数のオブジェクトコードを結合して実行可能ファイルを生成、ローダは実行可能ファイルをメモリに読み込んで実行、をそれぞれ担当します。"
        },
        {
          "type": "example",
          "title": "C言語のビルドプロセスの具体例",
          "content": "【ソースコード: main.c】\n```c\n#include <stdio.h>  // 標準入出力ライブラリをインクルード\n#define PI 3.14     // マクロ定義\n\nint main() {\n    printf(\"円周率: %f\\n\", PI);\n    return 0;\n}\n```\n\n【ステップ1: プリプロセッサ（前処理）】\n処理内容：#include や #define を展開\n入力：main.c\n出力：main.i（前処理済みソースコード）\n\n展開後の main.i（簡略化）：\n```c\n// <stdio.h> の内容（数千行）が展開される\n// #define PI 3.14 が展開され、PI が 3.14 に置換される\nint main() {\n    printf(\"円周率: %f\\n\", 3.14);  // PI が 3.14 に置換\n    return 0;\n}\n```\n\n【ステップ2: コンパイラ（翻訳）】\n処理内容：前処理済みソースコードをオブジェクトコード（機械語）に変換\n入力：main.i\n出力：main.o（オブジェクトコード）\n\nmain.o（機械語、バイナリファイル）：\n01010101 10001001 11100101 ...（人間には読めない）\n\n【ステップ3: リンカ（結合）】\n処理内容：複数のオブジェクトコードとライブラリを結合して実行可能ファイルを生成\n入力：main.o + 標準ライブラリ（printf 関数など）\n出力：main.exe（実行可能ファイル）\n\nリンカの役割：\n①main.o の中で使われている printf 関数を、標準ライブラリから探して結合\n②複数のオブジェクトコードがあれば、それらを結合\n\n【ステップ4: ローダ（読み込み）】\n処理内容：実行可能ファイルをメモリに読み込んで実行\n入力：main.exe\n出力：プログラムの実行\n\nローダの役割：\n①main.exe をメモリの適切な位置に配置\n②プログラムのエントリポイント（main 関数）から実行を開始"
        },
        {
          "type": "table",
          "headers": ["ステップ", "ツール", "入力", "出力", "役割"],
          "rows": [
            ["1. 前処理", "プリプロセッサ", "main.c", "main.i", "#include や #define を展開"],
            ["2. 翻訳", "コンパイラ", "main.i", "main.o", "ソースコードをオブジェクトコード（機械語）に変換"],
            ["3. 結合", "リンカ", "main.o + ライブラリ", "main.exe", "複数のオブジェクトコードを結合して実行可能ファイルを生成"],
            ["4. 読み込み", "ローダ", "main.exe", "メモリ上のプログラム", "実行可能ファイルをメモリに読み込んで実行"]
          ]
        },
        {
          "type": "highlight",
          "icon": "📌",
          "title": "ビルドプロセスの要点",
          "content": "①プリプロセッサ：#include（ヘッダファイルの内容を挿入）、#define（マクロ定義を展開）\n②コンパイラ：ソースコード → オブジェクトコード（.o、.obj）\n③リンカ：複数のオブジェクトコード + ライブラリ → 実行可能ファイル（.exe）\n④ローダ：実行可能ファイル → メモリに読み込んで実行\n\n重要：複数のソースファイル（main.c、func.c）がある場合、それぞれをコンパイルしてオブジェクトコード（main.o、func.o）を生成し、リンカで結合します。"
        }
      ]
    },
    {
      "id": 4,
      "title": "構造化プログラミング",
      "sections": [
        {
          "type": "text",
          "content": "**構造化プログラミング（Structured Programming）**とは、プログラムを「順次」「選択」「反復」の3つの基本構造の組み合わせで記述する手法です。構造化プログラミングの目的は、プログラムの可読性（読みやすさ）と保守性（修正しやすさ）を向上させることです。1960年代まで、プログラムは goto 文を多用したスパゲッティコード（複雑に絡み合ったコード）でしたが、1968年にダイクストラが構造化プログラミングを提唱し、goto 文を使わずに3つの基本構造だけでプログラムを記述することで、プログラムが格段に読みやすくなりました。"
        },
        {
          "type": "table",
          "headers": ["基本構造", "説明", "制御構造", "具体例（C言語）"],
          "rows": [
            ["順次（Sequence）", "命令を上から順番に実行", "なし", "a = 5;\nb = 10;\nc = a + b;"],
            ["選択（Selection）", "条件によって処理を分岐", "if-else、switch", "if (x > 0) {\n    printf(\"正の数\");\n} else {\n    printf(\"0または負の数\");\n}"],
            ["反復（Iteration）", "条件を満たす間、処理を繰り返す", "while、for", "for (int i = 0; i < 10; i++) {\n    printf(\"%d\\n\", i);\n}"]
          ]
        },
        {
          "type": "example",
          "title": "構造化プログラミングの具体例：1から10までの合計を計算",
          "content": "【goto 文を使った非構造化プログラム（スパゲッティコード）】\n```c\nint sum = 0;\nint i = 1;\n\nLOOP:\n    sum = sum + i;\n    i = i + 1;\n    if (i <= 10) goto LOOP;  // goto 文で LOOP にジャンプ\n\nprintf(\"合計: %d\\n\", sum);\n```\n→ goto 文でジャンプするため、処理の流れが複雑で読みづらい\n\n【構造化プログラミング（for ループ）】\n```c\nint sum = 0;\nfor (int i = 1; i <= 10; i++) {  // 反復構造（for ループ）\n    sum = sum + i;               // 順次構造\n}\nprintf(\"合計: %d\\n\", sum);\n```\n→ goto 文を使わず、for ループ（反復構造）で記述。処理の流れが明確で読みやすい\n\n【構造化プログラミングの利点】\n①可読性：処理の流れが上から下へ一直線で、読みやすい\n②保守性：修正が容易（goto 文がないため、どこから処理が飛んでくるか心配不要）\n③デバッグ：バグが見つけやすい"
        },
        {
          "type": "highlight",
          "icon": "💡",
          "title": "構造化プログラミングの原則",
          "content": "①単一入口・単一出口：関数やループは1つの入口と1つの出口を持つ\n②goto 文の禁止：goto 文を使わず、順次・選択・反復の3つの基本構造だけで記述\n③モジュール化：プログラムを小さな関数（モジュール）に分割し、再利用性を高める\n\n構造化プログラミングは、現代のプログラミング言語（C、Java、Python など）の基礎となっています。"
        }
      ]
    },
    {
      "id": 5,
      "title": "プログラミング言語のパラダイム",
      "sections": [
        {
          "type": "text",
          "content": "**プログラミングパラダイム（Programming Paradigm）**とは、プログラムを記述する際の考え方や手法のことです。主なパラダイムとして、①**手続き型プログラミング（Procedural Programming）**、②**オブジェクト指向プログラミング（Object-Oriented Programming、OOP）**、③**関数型プログラミング（Functional Programming）**、があります。手続き型は処理の手順を記述、オブジェクト指向はデータと処理をまとめたオブジェクトを操作、関数型は関数の組み合わせで記述、という違いがあります。"
        },
        {
          "type": "table",
          "headers": ["パラダイム", "考え方", "具体例", "特徴"],
          "rows": [
            ["手続き型", "処理の手順を記述", "C、Pascal", "順次・選択・反復の組み合わせ。変数の値を変更しながら処理を進める。"],
            ["オブジェクト指向", "データと処理をまとめたオブジェクトを操作", "Java、C++、Python", "カプセル化、継承、ポリモーフィズムの3つの特徴。再利用性が高い。"],
            ["関数型", "関数の組み合わせで記述", "Haskell、Lisp、Scala", "副作用（変数の変更など）を避ける。数学的な関数として記述。"],
            ["宣言型", "「何をするか」を記述（「どうやるか」は記述しない）", "SQL、HTML", "例：SELECT * FROM users WHERE age >= 20;（年齢20歳以上のユーザーを取得）"]
          ]
        },
        {
          "type": "example",
          "title": "同じ処理を異なるパラダイムで記述：1から10までの合計を計算",
          "content": "【手続き型（C言語）】\n```c\nint sum = 0;\nfor (int i = 1; i <= 10; i++) {\n    sum = sum + i;  // 変数 sum を変更しながら処理を進める\n}\nprintf(\"%d\\n\", sum);\n```\n→ 処理の手順を順次記述\n\n【オブジェクト指向（Java）】\n```java\npublic class Calculator {\n    public int sum(int start, int end) {\n        int result = 0;\n        for (int i = start; i <= end; i++) {\n            result = result + i;\n        }\n        return result;\n    }\n}\n\nCalculator calc = new Calculator();\nSystem.out.println(calc.sum(1, 10));\n```\n→ データ（start, end）と処理（sum メソッド）をまとめた Calculator クラス（オブジェクト）を操作\n\n【関数型（Python）】\n```python\nfrom functools import reduce\nresult = reduce(lambda x, y: x + y, range(1, 11))\nprint(result)\n```\n→ 関数（lambda）の組み合わせで記述。変数の変更を避ける。\n\n【宣言型（SQL風）】\n仮想的な例：\nSELECT SUM(value) FROM (VALUES 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n→ 「何をするか」（1から10の合計）だけを記述。「どうやるか」（ループで加算）は記述しない。"
        },
        {
          "type": "highlight",
          "icon": "📌",
          "title": "現代のプログラミング言語",
          "content": "現代のプログラミング言語は、複数のパラダイムをサポートする「マルチパラダイム言語」が主流です。\n\n例：Python\n①手続き型：for ループで処理を記述\n②オブジェクト指向：class を使ってオブジェクトを定義\n③関数型：lambda や map、reduce を使って関数を組み合わせる\n\nプログラマは、問題に応じて最適なパラダイムを選択できます。"
        }
      ]
    }
  ]
}
