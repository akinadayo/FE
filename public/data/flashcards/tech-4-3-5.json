{
  "topicId": "tech-4-3-5",
  "title": "アルゴリズムの計算量",
  "flashcards": [
    {
      "id": "tech-4-3-5-fc-1",
      "front": "時間計算量と空間計算量の違いは？各々何を評価する？",
      "back": "①時間計算量（Time Complexity）：\nアルゴリズムの実行にかかる時間（処理ステップ数）を評価。データ数nが大きくなったときの処理回数の増加傾向を見る。\n例：線形探索でn個のデータを全て確認 → O(n)\n\n②空間計算量（Space Complexity）：\nアルゴリズムが使用するメモリの量を評価。配列のコピーや再帰呼び出しのスタックなど。\n例：n個の配列をコピー → O(n)、一時変数のみ → O(1)\n\n基本情報技術者試験では、主に時間計算量が重要。空間計算量は、メモリが限られている環境で考慮する。",
      "importance": 5
    },
    {
      "id": "tech-4-3-5-fc-2",
      "front": "オーダ記法で定数項や係数を無視する理由は？具体例で説明せよ。",
      "back": "理由：データ数nが十分に大きいとき、定数項や係数の影響は無視できるほど小さくなるため。\n\n【具体例】\nアルゴリズムA：処理ステップ数 10n\nアルゴリズムB：処理ステップ数 n²\n\nn=5のとき：\n- A = 50、B = 25（Bの方が速い）\n\nn=1000のとき：\n- A = 10,000、B = 1,000,000（Aの方が100倍速い）\n\nnが大きくなると、係数（10）より、増加の傾向（nかn²か）の方が圧倒的に重要になる。そのため、オーダ記法では係数を無視して、O(n) vs O(n²)と表現する。",
      "importance": 5
    },
    {
      "id": "tech-4-3-5-fc-3",
      "front": "主要な6つのオーダを効率の良い順に並べよ。各オーダの具体例も答えよ。",
      "back": "効率の良い順（処理が速い順）：\nO(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2^n)\n\n①O(1) - 定数時間：配列の要素へのアクセス（array[5]）\n②O(log n) - 対数時間：2分探索（ソート済み配列から探索）\n③O(n) - 線形時間：線形探索、配列の全要素の合計\n④O(n log n) - 線形対数時間：マージソート、クイックソート（平均）\n⑤O(n²) - 2次時間：バブルソート、選択ソート、挿入ソート\n⑥O(2^n) - 指数時間：全探索、フィボナッチ数列（単純再帰）\n\nO(n²)以下は実用的だが、O(2^n)はnが少し大きくなると実行不可能。",
      "importance": 5
    },
    {
      "id": "tech-4-3-5-fc-4",
      "front": "2分探索の時間計算量がO(log n)になる理由を説明せよ。n=1000の場合、最悪で何回の比較が必要？",
      "back": "【理由】\n2分探索では、毎回探索範囲が半分になる。\n- 1回目：n個\n- 2回目：n/2個\n- 3回目：n/4個\n- k回目：n/(2^k)個\n\n探索範囲が1個になるまでの回数kは、\nn/(2^k) = 1 → 2^k = n → k = log₂ n\n\nよって、時間計算量はO(log n)\n\n【n=1000の場合】\nlog₂ 1000 ≈ 10回（2^10 = 1024）\n最悪で約10回の比較で見つかる。\n\n線形探索（O(n)）では最悪1000回必要なので、2分探索は約100倍高速。ただし、前提として配列がソート済みである必要がある。",
      "importance": 5
    },
    {
      "id": "tech-4-3-5-fc-5",
      "front": "以下のループの時間計算量を求めよ：\nfor i = 1 to n:\n  for j = 1 to i:\n    処理",
      "back": "【ループ回数の計算】\niが1のとき、内側のループは1回\niが2のとき、内側のループは2回\niが3のとき、内側のループは3回\n...\niがnのとき、内側のループはn回\n\n合計：1 + 2 + 3 + ... + n = n(n+1)/2 = (n² + n)/2\n\n【時間計算量】\nO(n²)（最も影響の大きい項n²のみを残す、定数項と係数は無視）\n\n例：\n- n=10のとき：55回\n- n=100のとき：5,050回\n- n=1000のとき：500,500回\n\nnが10倍になると、処理回数は約100倍（10²倍）になる。",
      "importance": 4
    },
    {
      "id": "tech-4-3-5-fc-6",
      "front": "最良・平均・最悪ケースとは？システム設計でどのケースを想定すべきか？",
      "back": "①最良ケース（Best Case）：最も効率的に動作する入力データの場合\n例：線形探索で、目的の値が先頭にある → O(1)\n\n②平均ケース（Average Case）：様々な入力データの平均的な場合\n例：線形探索で、目的の値が配列の中央付近にある → O(n)\n\n③最悪ケース（Worst Case）：最も非効率に動作する入力データの場合\n例：線形探索で、目的の値が最後にある、または見つからない → O(n)\n\n【システム設計では最悪ケースを想定】\nシステムの性能を保証するため、最悪ケースでも許容範囲内の性能を発揮するアルゴリズムを選択する。「平均では速いが、最悪で極端に遅い」アルゴリズムは避ける。",
      "importance": 5
    },
    {
      "id": "tech-4-3-5-fc-7",
      "front": "クイックソートの最良・平均・最悪ケースの計算量は？最悪ケースはいつ発生する？",
      "back": "①最良ケース：O(n log n)\nピボットが毎回配列を均等に2分割する場合\n\n②平均ケース：O(n log n)\nランダムなデータの場合、ピボットの選択がある程度均等\n\n③最悪ケース：O(n²)\nピボットが毎回最小値または最大値になる場合\n例：すでにソート済みの配列で、先頭をピボットに選ぶと、毎回1個ずつしか減らない\n\n【最悪ケースの回避方法】\n- ピボットをランダムに選択\n- 中央値をピボットに選択\n- 3点の中央値をピボットに選択（先頭、中央、末尾の3つから中央値）\n\nこれらの工夫により、最悪ケースO(n²)の確率を極めて低くできる。",
      "importance": 4
    },
    {
      "id": "tech-4-3-5-fc-8",
      "front": "挿入ソートの最良・平均・最悪ケースの計算量は？どんなデータに適している？",
      "back": "①最良ケース：O(n)\nすでにソート済みの配列の場合、内側のwhileループは実行されない（比較は1回のみ）\n\n②平均ケース：O(n²)\nランダムなデータの場合、平均で約i/2回の比較・シフト\n\n③最悪ケース：O(n²)\n逆順にソートされた配列の場合、毎回i回の比較・シフト\n\n【適しているデータ】\n- すでにソート済み、またはほぼソート済みのデータ → O(n)で高速\n- データ数が少ない場合（n < 100）→ 実装がシンプル\n\n【適していないデータ】\n- ランダムなデータ、または逆順のデータ → O(n²)で遅い\n- データ数が多い場合（n >= 1000）→ マージソートやクイックソートの方が高速",
      "importance": 4
    },
    {
      "id": "tech-4-3-5-fc-9",
      "front": "マージソートとクイックソートの時間計算量と空間計算量を比較せよ。各々の利点は？",
      "back": "【マージソート】\n時間計算量：O(n log n)（最良・平均・最悪すべて）\n空間計算量：O(n)（追加メモリ必要）\n利点：\n- 安定ソート（同じ値の順序を保持）\n- 最悪ケースでもO(n log n)で安定して高速\n\n【クイックソート】\n時間計算量：O(n log n)（最良・平均）、O(n²)（最悪）\n空間計算量：O(log n)（再帰呼び出しのスタック）\n利点：\n- 平均ケースで最も高速（実測値）\n- メモリ使用量が少ない\n\n【使い分け】\n- 安定性が必要 → マージソート\n- メモリが限られている → クイックソート\n- 最悪ケースでも安定した性能が必要 → マージソート\n- 平均的な性能を重視 → クイックソート",
      "importance": 4
    },
    {
      "id": "tech-4-3-5-fc-10",
      "front": "線形探索と2分探索の計算量を比較せよ。n=100万件のデータで、各々最悪で何回の比較が必要？",
      "back": "【線形探索】\n時間計算量：O(n)\n配列の先頭から順番に探索。未ソートのデータでも使用可能。\nn=100万件の場合、最悪で100万回の比較が必要。\n\n【2分探索】\n時間計算量：O(log n)\n毎回探索範囲を半分にする。前提：ソート済みの配列。\nn=100万件の場合、最悪で約20回の比較（2^20 = 1,048,576）。\n\n【比較】\n2分探索は線形探索の約50,000倍高速。\nただし、2分探索は「ソート済み」が前提。\n\n【使い分け】\n- データがソート済み → 2分探索（O(log n)）\n- データが未ソートで、探索回数が少ない → 線形探索（O(n)）\n- データが未ソートで、探索回数が多い → 事前にソート（O(n log n)）+ 2分探索",
      "importance": 5
    },
    {
      "id": "tech-4-3-5-fc-11",
      "front": "以下のアルゴリズムの時間計算量を求めよ：\nwhile n > 1:\n  n = n / 2",
      "back": "【ループ回数の計算】\n毎回nが半分になる。\n- 1回目：n\n- 2回目：n/2\n- 3回目：n/4\n- k回目：n/(2^k)\n\nループが終了する条件：n/(2^k) = 1 → 2^k = n → k = log₂ n\n\n【時間計算量】\nO(log n)\n\n例：\n- n=1000のとき：約10回のループ（2^10 = 1024）\n- n=100万のとき：約20回のループ（2^20 = 1,048,576）\n\n「毎回、値が半分になる（または2倍になる）」→ O(log n)と覚える。\n2分探索、完全2分木の深さなどもO(log n)。",
      "importance": 4
    },
    {
      "id": "tech-4-3-5-fc-12",
      "front": "フィボナッチ数列を単純再帰で計算すると、時間計算量がO(2^n)になる理由は？改善方法は？",
      "back": "【理由】\nfibonacci(n) = fibonacci(n-1) + fibonacci(n-2)で計算する場合、\n- fibonacci(5)は、fibonacci(4)とfibonacci(3)を計算\n- fibonacci(4)は、fibonacci(3)とfibonacci(2)を計算\n- fibonacci(3)が2回計算される（重複）\n\nこの重複計算が指数的に増加し、呼び出し回数は約2^n回になる。\n\n例：\n- n=10のとき：約1,024回\n- n=20のとき：約104万回\n- n=30のとき：約10億回\n\n【改善方法：メモ化（動的計画法）】\n一度計算した結果を配列に保存し、再利用する。\n```\nmemo = array[0 to n]  // -1で初期化\nfunction fibonacci(n):\n    if memo[n] != -1:\n        return memo[n]  // 既に計算済み\n    if n == 0 or n == 1:\n        return n\n    memo[n] = fibonacci(n-1) + fibonacci(n-2)\n    return memo[n]\n```\n各fibonacci(i)は1回だけ計算 → 時間計算量O(n)に改善。",
      "importance": 3
    }
  ]
}
