{
  "topicId": "tech-4-3-2",
  "title": "データ構造",
  "flashcards": [
    {
      "id": "tech-4-3-2-fc-1",
      "front": "配列と連結リストの違いは？それぞれの利点・欠点は？",
      "back": "【配列（Array）】\n利点:\n①ランダムアクセスが高速（O(1)、添え字で直接アクセス）\n②メモリ領域が連続 → キャッシュ効率が良い\n欠点:\n①固定サイズ（後から変更不可）\n②挿入・削除が遅い（O(n)、要素を移動する必要がある）\n\n【連結リスト（Linked List）】\n利点:\n①可変サイズ（要素の追加・削除が容易）\n②挿入・削除が高速（O(1)、ただし挿入位置が既知の場合）\n欠点:\n①ランダムアクセス不可（n番目の要素にアクセスするにはO(n)）\n②ポインタ用のメモリが必要（配列よりメモリ使用量が多い）\n\n使い分け: ①ランダムアクセスが多い→配列、②挿入・削除が多い→連結リスト",
      "importance": 5
    },
    {
      "id": "tech-4-3-2-fc-2",
      "front": "スタック（Stack）とキュー（Queue）の違いは？応用例は？",
      "back": "【スタック（Stack）】\n取り出し順序: LIFO（Last In First Out、後入れ先出し）\n操作: push（追加）、pop（取り出し）\n応用例:\n①関数呼び出しの管理（コールスタック）\n②括弧の対応チェック\n③逆ポーランド記法の計算\n④DFS（深さ優先探索）\n\n【キュー（Queue）】\n取り出し順序: FIFO（First In First Out、先入れ先出し）\n操作: enqueue（追加）、dequeue（取り出し）\n応用例:\n①印刷ジョブの管理（プリンタキュー）\n②タスクスケジューリング（プロセス管理）\n③BFS（幅優先探索）\n④キャッシュのLRU（Least Recently Used）管理\n\nスタックは「最後に入れたものを先に取り出す」、キューは「先に入れたものを先に取り出す」",
      "importance": 5
    },
    {
      "id": "tech-4-3-2-fc-3",
      "front": "関数呼び出しでスタックがどう使われるか？具体例は？",
      "back": "関数呼び出し時、戻り先のアドレス、ローカル変数などをスタックに積む（コールスタック）。\n\n【例】\n```\ndef funcA():\n  funcB()\n\ndef funcB():\n  funcC()\n\ndef funcC():\n  print(\"C\")\n\nfuncA()\n```\n\n【コールスタックの変化】\n①funcA呼び出し → スタック: [funcA]\n②funcB呼び出し → スタック: [funcA, funcB]\n③funcC呼び出し → スタック: [funcA, funcB, funcC]\n④funcC終了 → pop → スタック: [funcA, funcB]\n⑤funcB終了 → pop → スタック: [funcA]\n⑥funcA終了 → pop → スタック: []\n\nスタックオーバーフロー（Stack Overflow）は、再帰呼び出しが深すぎてスタックが溢れるエラー。",
      "importance": 5
    },
    {
      "id": "tech-4-3-2-fc-4",
      "front": "2分探索木（Binary Search Tree）とは？性質と計算量は？",
      "back": "2分探索木（BST）は、以下の性質を満たす2分木:\n①各ノードの左の子孫 < そのノード\n②各ノードの右の子孫 > そのノード\n\n【計算量】\n平均: 検索・挿入・削除 O(log n)\n最悪: 検索・挿入・削除 O(n)（木が一直線になった場合）\n\n【中順走査（In-order）】\n左 → 根 → 右の順で走査すると、データが昇順に取得できる\n\n【例】\n```\n    50\n   /  \\\n  30   70\n /  \\  /  \\\n20  40 60 80\n```\n中順走査: 20, 30, 40, 50, 60, 70, 80（昇順）\n\n【欠点】\nデータが昇順で挿入されると、木が一直線になり計算量がO(n)に悪化\n→ AVL木、赤黒木などの平衡2分探索木で解決",
      "importance": 5
    },
    {
      "id": "tech-4-3-2-fc-5",
      "front": "2分木の走査方法3種類は？各走査の順序は？",
      "back": "【前順走査（Pre-order）】\n順序: 根 → 左 → 右\n用途: 木のコピー、式の前置記法\n\n【中順走査（In-order）】\n順序: 左 → 根 → 右\n用途: 2分探索木の昇順取得\n\n【後順走査（Post-order）】\n順序: 左 → 右 → 根\n用途: 木の削除、式の後置記法\n\n【例】\n```\n    A\n   / \\\n  B   C\n / \\\n D  E\n```\n前順: A, B, D, E, C\n中順: D, B, E, A, C\n後順: D, E, B, C, A\n\n2分探索木では、中順走査で昇順にデータを取得できる！",
      "importance": 4
    },
    {
      "id": "tech-4-3-2-fc-6",
      "front": "ヒープ（Heap）とは？最大ヒープと最小ヒープの違いは？応用例は？",
      "back": "ヒープは、以下の性質を満たす完全2分木:\n\n【最大ヒープ（Max Heap）】\n親ノード ≥ 子ノード（根が最大値）\n\n【最小ヒープ（Min Heap）】\n親ノード ≤ 子ノード（根が最小値）\n\n【計算量】\n挿入: O(log n)\n最大値（最小値）の取り出し: O(log n)\n\n【応用例】\n①優先度付きキュー（Priority Queue）\n  - タスクスケジューリング（優先度が高いタスクを先に処理）\n  - ネットワークパケットの優先制御\n②ヒープソート（整列アルゴリズム、O(n log n)）\n③ダイクストラ法（最短経路探索）\n\nヒープは、配列で効率的に実装できる（親のインデックスi、左の子2i+1、右の子2i+2）",
      "importance": 5
    },
    {
      "id": "tech-4-3-2-fc-7",
      "front": "ハッシュテーブル（Hash Table）とは？衝突の解決方法は？",
      "back": "ハッシュテーブルは、キー（Key）と値（Value）のペアを格納するデータ構造。ハッシュ関数でキー→インデックス（ハッシュ値）に変換し、配列に格納。\n\n【計算量】\n平均: 検索・挿入・削除 O(1)\n最悪: O(n)（衝突が多い場合）\n\n【衝突（Collision）】\n異なるキーが同じハッシュ値になること\n\n【衝突の解決方法】\n①チェイン法（Chaining）:\n  同じハッシュ値のデータを連結リストで管理\n  例: 配列[1] → 太郎 → 美咲\n\n②オープンアドレス法（Open Addressing）:\n  別の空きスロットを探す\n  - 線形探査法: 1つずつ探す\n  - 2次探査法: 1², 2², 3²,...と探す\n\n【良いハッシュ関数の条件】\n①計算が高速\n②衝突が少ない（均等に分散）\n③決定的（同じキー→同じハッシュ値）",
      "importance": 5
    },
    {
      "id": "tech-4-3-2-fc-8",
      "front": "グラフ（Graph）の表現方法2種類は？それぞれの特徴は？",
      "back": "【隣接行列（Adjacency Matrix）】\n2次元配列でノード間の接続を表現\n\nメモリ: O(V²)（Vはノード数）\n辺の存在確認: O(1)\n全隣接ノード取得: O(V)\n適した用途: 密なグラフ（辺が多い）\n\n例:\n```\n   A B C\nA [0 1 1]\nB [1 0 0]\nC [1 0 0]\n```\n\n【隣接リスト（Adjacency List）】\n各ノードに接続されたノードをリストで表現\n\nメモリ: O(V+E)（Eは辺の数）\n辺の存在確認: O(V)\n全隣接ノード取得: O(次数)\n適した用途: 疎なグラフ（辺が少ない）\n\n例:\n```\nA: [B, C]\nB: [A]\nC: [A]\n```\n\n実際のプログラムでは、辺が少ないグラフが多いため、隣接リストが一般的。",
      "importance": 4
    },
    {
      "id": "tech-4-3-2-fc-9",
      "front": "幅優先探索（BFS）と深さ優先探索（DFS）の違いは？使用するデータ構造は？",
      "back": "【幅優先探索（BFS: Breadth-First Search）】\n使用データ構造: キュー（Queue）\n探索順序: 近い順に探索（根から距離1→2→3...）\n用途:\n①最短経路探索（重みなしグラフ）\n②レベル順の走査\n\n【深さ優先探索（DFS: Depth-First Search）】\n使用データ構造: スタック（Stack）または再帰\n探索順序: 深い方向に探索（行けるところまで行く）\n用途:\n①経路の存在確認\n②トポロジカルソート\n③迷路の探索\n\n【例: グラフAから探索】\n```\n  A\n / \\\nB   C\n|   |\nD   E\n```\nBFS: A → B → C → D → E\nDFS: A → B → D → C → E\n\nBFSはキュー、DFSはスタックを使用！",
      "importance": 4
    },
    {
      "id": "tech-4-3-2-fc-10",
      "front": "データ構造の選択基準は？用途別の推奨は？",
      "back": "【選択基準】\n①操作の頻度: 検索・挿入・削除のどれが多いか\n②データの性質: 順序が必要か、重複があるか\n③メモリ制約: メモリ使用量を最小化したいか\n④計算量: 時間計算量を最小化したいか\n\n【用途別の推奨】\n①辞書（キー→値、検索が多い）→ ハッシュテーブル（O(1)）\n②優先度付きキュー → ヒープ（O(log n)）\n③順序付きデータ → 2分探索木（中順走査で昇順）\n④FIFO処理（印刷ジョブ）→ キュー\n⑤LIFO処理（関数呼び出し）→ スタック\n⑥ネットワーク（複雑な関係性）→ グラフ\n⑦小規模・固定サイズ → 配列（シンプル）\n\n要件に応じて、最適なデータ構造を選択することが重要！",
      "importance": 5
    },
    {
      "id": "tech-4-3-2-fc-11",
      "front": "配列で実装したスタックとキューの操作の計算量は？注意点は？",
      "back": "【配列で実装したスタック】\npush（末尾に追加）: O(1)\npop（末尾から削除）: O(1)\n\n配列の末尾を使用するため、高速。\n\n【配列で実装したキュー（単純実装）】\nenqueue（末尾に追加）: O(1)\ndequeue（先頭から削除）: O(n)（要素を前に詰める必要がある）\n\n【配列で実装したキュー（環状配列）】\nenqueue（末尾に追加）: O(1)\ndequeue（先頭から削除）: O(1)\n\n環状配列（Circular Queue）を使用すると、先頭と末尾のインデックスを管理し、配列を環状に使用できる。末尾が配列の終端に達したら、配列の先頭に戻る。\n\n【注意点】\n配列で実装する場合、サイズが固定されるため、要素数が上限を超えるとエラー（オーバーフロー）が発生する。可変サイズが必要な場合、連結リストで実装する。",
      "importance": 3
    },
    {
      "id": "tech-4-3-2-fc-12",
      "front": "ハッシュテーブルと2分探索木の使い分けは？",
      "back": "【ハッシュテーブル】\n計算量: 検索・挿入・削除 平均O(1)\n順序: なし（データが順序を持たない）\n用途:\n①順序不要、高速検索が必要\n②キー→値の対応（辞書、連想配列）\n例: ユーザーID→ユーザー情報\n\n【2分探索木】\n計算量: 検索・挿入・削除 平均O(log n)\n順序: あり（中順走査で昇順取得）\n用途:\n①順序が必要（範囲検索、ソート）\n②最小値・最大値の取得\n例: 商品を価格順に表示、範囲検索（1000円～5000円の商品）\n\n【使い分け】\n①順序不要、高速検索 → ハッシュテーブル\n②順序が必要、範囲検索 → 2分探索木\n\nPythonのDict（ハッシュテーブル）は順序を持たないが、TreeMap（2分探索木）は順序を持つ。",
      "importance": 4
    }
  ]
}
