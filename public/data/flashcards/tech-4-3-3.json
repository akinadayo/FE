{
  "topicId": "tech-4-3-3",
  "title": "探索アルゴリズム",
  "flashcards": [
    {
      "id": "tech-4-3-3-fc-1",
      "front": "線形探索（逐次探索）の手順と計算量は？",
      "back": "手順:\n①配列の先頭（インデックス0）から順番に、目的の値と比較\n②一致したら、そのインデックスを返す\n③配列の最後まで調べても見つからなかったら、「見つからない」を返す\n\n計算量:\n- 最良の場合: O(1)（先頭にある場合、1回の比較）\n- 平均の場合: O(n/2) ≈ O(n)（平均n/2回の比較）\n- 最悪の場合: O(n)（最後にある、または見つからない場合、n回の比較）\n\n前提条件: なし（データが未整列でもOK）\n\n例: 配列[15, 8, 23, 42, 5]から23を探す → インデックス0、1、2の順に比較 → 3回で見つかる",
      "importance": 5
    },
    {
      "id": "tech-4-3-3-fc-2",
      "front": "2分探索（二分探索）の手順と前提条件は？",
      "back": "手順:\n①配列の中央の要素と目的の値を比較\n②一致したら、そのインデックスを返す\n③目的の値が中央の要素より小さい → 左半分を探索（右半分は除外）\n④目的の値が中央の要素より大きい → 右半分を探索（左半分は除外）\n⑤①～④を繰り返す\n⑥探索範囲がなくなったら「見つからない」を返す\n\n前提条件: データが整列済みである必要（昇順または降順）\n\n計算量:\n- 最良の場合: O(1)（中央にある場合、1回の比較）\n- 平均・最悪の場合: O(log n)（最大log₂ n回の比較）\n\n例: n=1,000の配列では、最大10回の比較で済む（2¹⁰=1,024）",
      "importance": 5
    },
    {
      "id": "tech-4-3-3-fc-3",
      "front": "2分探索の比較回数を計算せよ：①n=16、②n=1,000、③n=1,000,000",
      "back": "2分探索の最悪の比較回数 = log₂ n 回（切り上げ）\n\n①n=16の場合:\nlog₂ 16 = 4 → 最悪4回\n（探索の流れ: 16 → 8 → 4 → 2 → 1）\n\n②n=1,000の場合:\nlog₂ 1,000 ≈ 9.97 → 切り上げて10回\n（2¹⁰ = 1,024 > 1,000 なので、最大10回で探索できる）\n\n③n=1,000,000の場合:\nlog₂ 1,000,000 ≈ 19.93 → 切り上げて20回\n（2²⁰ = 1,048,576 > 1,000,000 なので、最大20回で探索できる）\n\n線形探索ではn回かかるため、2分探索は圧倒的に高速！",
      "importance": 5
    },
    {
      "id": "tech-4-3-3-fc-4",
      "front": "ハッシュ探索の原理と計算量は？衝突とは？",
      "back": "原理:\n①キーをハッシュ関数に渡し、インデックスを計算（例: h(社員番号) = 社員番号 mod 10）\n②計算したインデックスの位置にデータを格納（格納時）\n③計算したインデックスの位置からデータを取得（探索時）\n\n計算量:\n- 衝突がない場合: O(1)（1回の計算でデータにアクセス）\n- 衝突がある場合: O(m)（mは衝突したデータ数）\n\n衝突（Collision）:\n異なるキーに対して、ハッシュ関数が同じインデックスを返すこと。\n例: 社員番号1025と2025は、どちらもh(x) = x mod 10 = 5\n\n衝突の解決方法:\n①チェイン法: 同じインデックスに複数のデータをリストで格納\n②オープンアドレス法: 衝突した場合、次の空いている位置に格納",
      "importance": 5
    },
    {
      "id": "tech-4-3-3-fc-5",
      "front": "ハッシュ探索のチェイン法とオープンアドレス法の違いは？",
      "back": "【チェイン法（連鎖法）】\n同じインデックスに複数のデータを、連結リストで格納。\n\n例: インデックス5に社員A（1025）と社員D（2025）を格納\n→ インデックス5: [社員A] → [社員D]（連結リスト）\n\n探索時: リストを先頭から順番に調べる（線形探索、O(m)）\n\n【オープンアドレス法（線形探査法）】\n衝突した場合、次の空いている位置（インデックス+1、+2、...）に格納。\n\n例: インデックス5に社員A、衝突したら次の空いている位置6に社員Dを格納\n→ インデックス5: 社員A、インデックス6: 社員D\n\n探索時: インデックス5を確認 → 不一致 → インデックス6を確認（O(m)）\n\n【使い分け】\nチェイン法: 衝突が多い場合に適している\nオープンアドレス法: メモリ効率が良い",
      "importance": 4
    },
    {
      "id": "tech-4-3-3-fc-6",
      "front": "ハッシュ探索の負荷率とは？理想的な負荷率は？",
      "back": "負荷率（Load Factor） = データ数 ÷ ハッシュテーブルのサイズ\n\n例:\nハッシュテーブルのサイズ: 10\nデータ数: 7\n負荷率 = 7 ÷ 10 = 0.7\n\n【負荷率と性能】\n- 負荷率 < 0.7: 衝突が少なく、高速（O(1)に近い）\n- 負荷率 ≈ 1.0: 衝突が多発、性能低下\n- 負荷率 > 1.0: 全てのデータが衝突、最悪O(n)\n\n【推奨】\n負荷率を0.7以下に保つことが推奨される。負荷率が高くなったら、ハッシュテーブルのサイズを拡大し、全てのデータを再配置（リハッシュ）する。\n\n例: サイズ10のテーブルに7件のデータ → 負荷率0.7\n8件目を追加する場合 → サイズを20に拡大し、全データを再配置",
      "importance": 4
    },
    {
      "id": "tech-4-3-3-fc-7",
      "front": "2分探索木での探索の手順は？計算量は？",
      "back": "2分探索木（Binary Search Tree）:\n各ノードが最大2つの子ノード（左の子、右の子）を持ち、左の子 < 親 < 右の子、という関係が成り立つ。\n\n探索の手順:\n①ルート（根）から開始\n②目的の値と現在のノードのキーを比較\n③一致したら終了\n④目的の値が小さい → 左の子に移動\n⑤目的の値が大きい → 右の子に移動\n⑥②～⑤を繰り返す\n\n計算量:\n- 平均の場合: O(log n)（木の高さがlog n）\n- 最悪の場合: O(n)（木のバランスが悪い、一直線になる場合）\n\nバランスを保つために、AVL木、赤黒木などの自己平衡木が使われる。",
      "importance": 5
    },
    {
      "id": "tech-4-3-3-fc-8",
      "front": "深さ優先探索（DFS）と幅優先探索（BFS）の違いは？",
      "back": "【深さ優先探索（DFS: Depth-First Search）】\nできるだけ深く（下に）探索してから、隣の枝を探索。\n\nデータ構造: スタック（または再帰）\n\n探索順序（例）:\n木: A → B → D → E → C → F\n\n用途: 迷路の探索、ファイルシステムの全検索\n\n【幅優先探索（BFS: Breadth-First Search）】\n同じ階層（同じ深さ）のノードを全て探索してから、次の階層を探索。\n\nデータ構造: キュー\n\n探索順序（例）:\n木: A → B → C → D → E → F\n\n用途: 最短経路の探索、SNSの友達の友達を探す\n\n【計算量】\nどちらもO(n)（nはノード数、全てのノードを訪問）",
      "importance": 5
    },
    {
      "id": "tech-4-3-3-fc-9",
      "front": "探索アルゴリズムの選択基準は？各アルゴリズムに適した場面は？",
      "back": "①データが未整列 → 線形探索\n例: 小規模なデータ、整列のコストを払いたくない場合\n\n②データが整列済み、大規模 → 2分探索\n例: 1,000,000件の整列済み配列、探索頻度が高い\n\n③探索頻度が超高い、メモリに余裕あり → ハッシュ探索\n例: 100,000件の社員データ、1秒間に10,000回の探索\n\n④階層構造、動的に変化 → 木探索（2分探索木）\n例: ファイルシステムのディレクトリ構造、頻繁にファイルの追加・削除\n\n⑤探索頻度が低い、データ数が少ない → 線形探索\n例: データ数が10件以下、シンプルで実装が楽",
      "importance": 5
    },
    {
      "id": "tech-4-3-3-fc-10",
      "front": "n=1,000のデータで、線形探索と2分探索の比較回数を比較せよ（最悪の場合）",
      "back": "【線形探索】\n最悪の場合、配列の最後まで調べる。\n比較回数 = n = 1,000回\n\n【2分探索】\n最悪の場合、log₂ n回の比較が必要。\nlog₂ 1,000 ≈ 9.97 → 切り上げて10回\n（2¹⁰ = 1,024 > 1,000 なので、最大10回で探索できる）\n\n【比較】\n線形探索: 1,000回\n2分探索: 10回\n→ 2分探索は線形探索の100分の1の比較回数で済む！\n\nただし、2分探索にはデータが整列済みである必要がある。整列にはO(n log n)の時間がかかる（クイックソート、マージソートなど）。",
      "importance": 5
    },
    {
      "id": "tech-4-3-3-fc-11",
      "front": "ハッシュ関数h(x) = x mod 7で、キー15, 22, 8, 29, 36を格納したときのハッシュテーブルは？",
      "back": "ハッシュ関数: h(x) = x mod 7（xを7で割った余り）\n\n【計算】\n①h(15) = 15 mod 7 = 1 → インデックス1に格納\n②h(22) = 22 mod 7 = 1 → インデックス1に衝突！（チェイン法またはオープンアドレス法で解決）\n③h(8) = 8 mod 7 = 1 → インデックス1に衝突！\n④h(29) = 29 mod 7 = 1 → インデックス1に衝突！\n⑤h(36) = 36 mod 7 = 1 → インデックス1に衝突！\n\n【チェイン法の場合】\nインデックス1: [15] → [22] → [8] → [29] → [36]（連結リスト）\n\n【問題点】\n全てのキーがインデックス1に衝突してしまい、性能が悪い（O(n)）。ハッシュ関数の設計が悪い例。良いハッシュ関数は、キーを均等に分散させる必要がある。",
      "importance": 4
    },
    {
      "id": "tech-4-3-3-fc-12",
      "front": "探索アルゴリズムの計算量の比較表を埋めよ（n=1,000,000の場合）",
      "back": "【n=1,000,000の場合の比較回数】\n\n①線形探索:\n- 最良の場合: 1回（先頭にある場合）\n- 平均の場合: 500,000回（n/2）\n- 最悪の場合: 1,000,000回（n回）\n\n②2分探索:\n- 最良の場合: 1回（中央にある場合）\n- 平均・最悪の場合: 20回（log₂ n ≈ 19.93 → 20回）\n\n③ハッシュ探索:\n- 衝突がない場合: 1回（O(1)）\n- 衝突がある場合: m回（mは衝突したデータ数）\n\n【結論】\n大規模なデータ（n=1,000,000）では、2分探索またはハッシュ探索が圧倒的に高速。線形探索は平均500,000回の比較が必要で、非効率。",
      "importance": 4
    }
  ]
}
