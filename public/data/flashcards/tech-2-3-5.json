{
  "topicId": "tech-2-3-5",
  "title": "仮想記憶管理",
  "flashcards": [
    {
      "id": "tech-2-3-5-fc-1",
      "front": "仮想記憶とは？主な利点3つは？",
      "back": "仮想記憶（Virtual Memory）: 物理メモリ（RAM）とハードディスク（SSD）を組み合わせて、実際のメモリ容量より大きな仮想的なメモリ空間をプログラムに提供する技術。\n\n主な利点:\n①物理メモリより大きなプログラムを実行できる（例: 8GBのRAMで10GBのプログラムを実行）\n②複数のプログラムを効率的に同時実行できる\n③プログラマはメモリ容量を気にせずプログラムを開発できる（透過性）\n\n主な方式:\n①ページング方式（現在の主流）: プログラムを固定サイズのページ（例: 4KB）に分割\n②セグメント方式: プログラムを論理的な単位（コード、データ、スタック）に分割",
      "importance": 5
    },
    {
      "id": "tech-2-3-5-fc-2",
      "front": "ページング方式とは？ページとページフレームの違いは？",
      "back": "ページング方式（Paging）: プログラムの仮想メモリ空間を固定サイズの小さな単位（ページ）に分割し、物理メモリも同じサイズの単位（ページフレーム）に分割して管理する方式。\n\nページ（Page）:\n仮想メモリ空間を分割した固定サイズの単位。一般的に4KB（4,096バイト）。プログラムから見たメモリの単位。\n\nページフレーム（Page Frame）:\n物理メモリ（RAM）を分割した固定サイズの単位。ページと同じサイズ（4KB）。実際のRAMの単位。\n\n流れ:\n①プログラムをページに分割（例: 16KB → 4ページ）\n②必要なページだけをRAMのページフレームに配置\n③使わないページはハードディスクに保存\n④ページテーブルで仮想アドレスと物理アドレスを対応付け",
      "importance": 5
    },
    {
      "id": "tech-2-3-5-fc-3",
      "front": "ページフォルトとは？発生時のOSの処理は？",
      "back": "ページフォルト（Page Fault）: プログラムがアクセスしようとしたページが物理メモリ（RAM）に存在しない場合に発生する例外。仮想記憶では正常な動作だが、頻繁に発生するとシステムが遅くなる。\n\nページフォルト発生時のOSの処理:\n①プログラムが仮想アドレスにアクセス\n②ページテーブルを確認 → 有効ビット = 0（ページがHDD内）\n③ページフォルト発生\n④RAMが満杯の場合、ページ置き換えアルゴリズム（LRU）で1つのページを選び、HDDに退避（ページアウト）\n⑤必要なページをHDDからRAMに読み込み（ページイン）\n⑥ページテーブルを更新（有効ビット = 1、物理アドレスを設定）\n⑦プログラムの実行を再開\n\n所要時間: 数ミリ秒～数十ミリ秒（HDDアクセスを含む）",
      "importance": 5
    },
    {
      "id": "tech-2-3-5-fc-4",
      "front": "FIFO、LRU、LFUの違いは？どれが最も効率的？",
      "back": "ページ置き換えアルゴリズム（ページフォルト発生時、どのページをHDDに退避するか決定）:\n\n①FIFO（First In First Out）:\n最も古くRAMに読み込まれたページを置き換える\n利点: 実装が簡単\n欠点: よく使われるページも置き換えられる可能性\n\n②LRU（Least Recently Used）:\n最も長い間使われていないページを置き換える\n利点: 効率的（よく使われるページは残る）\n欠点: 実装が複雑、管理のオーバーヘッド\n\n③LFU（Least Frequently Used）:\n最も使用頻度が低いページを置き換える\n利点: 使用頻度を考慮できる\n欠点: 過去の使用頻度が高くても、今は使わないページが残る\n\n最も効率的: LRU（現在のOSで広く使用）",
      "importance": 5
    },
    {
      "id": "tech-2-3-5-fc-5",
      "front": "ページテーブルとアドレス変換の流れは？",
      "back": "ページテーブル（Page Table）: 仮想アドレスと物理アドレスの対応を記録した表。各プログラムが独自のページテーブルを持つ。\n\nアドレス変換の流れ（32ビットシステム、1ページ = 4KB）:\n①プログラムが仮想アドレス（例: 0x00123456）にアクセス\n②仮想アドレスを分割\n  - ページ番号: 上位20ビット（例: 0x123 = 291）\n  - ページ内オフセット: 下位12ビット（例: 0x456 = 1110バイト）\n③ページテーブルを参照\n  - ページ番号291 → ページフレーム番号5000（RAMに配置）\n④物理アドレスを計算\n  - 物理アドレス = ページフレーム番号 × ページサイズ + ページ内オフセット\n  - = 5000 × 4096 + 1110 = 20,481,110バイト\n⑤物理アドレスにアクセス\n\n高速化: TLB（キャッシュ）で最近のエントリを保存",
      "importance": 4
    },
    {
      "id": "tech-2-3-5-fc-6",
      "front": "TLB（Translation Lookaside Buffer）とは？ヒット率は？",
      "back": "TLB（Translation Lookaside Buffer）: 最近使われたページテーブルのエントリをキャッシュするCPUのハードウェア。アドレス変換を高速化する。\n\n動作:\n①TLBヒット（キャッシュにエントリがある）:\n  ページテーブルへのアクセスなしで、直接物理アドレスを取得\n  所要時間: 数ナノ秒\n  確率: 90%以上\n\n②TLBミス（キャッシュにエントリがない）:\n  ページテーブル（RAM）にアクセスして物理アドレスを取得\n  所要時間: 数十ナノ秒\n  確率: 10%未満\n\nヒット率: 一般的に90%以上\n\n効果: アドレス変換を大幅に高速化（TLBなしだと全てのメモリアクセスでページテーブルへのアクセスが必要 → 2倍遅い）",
      "importance": 4
    },
    {
      "id": "tech-2-3-5-fc-7",
      "front": "スラッシングとは？原因と対策は？",
      "back": "スラッシング（Thrashing）: ページフォルトが頻繁に発生し、システムがほとんどページの読み込み・退避の処理に時間を使い、プログラムの実行が進まなくなる現象。\n\n原因:\n物理メモリに対して実行するプログラムが多すぎる（例: 4GBのRAMで10個のプログラム（各500MB）を同時実行 → 合計5GB > 4GB）\n\n症状:\n①システムが非常に遅い（マウスのクリックに数秒～数十秒）\n②ハードディスクのアクセスランプが常に点灯\n③CPU使用率が低い（CPUがページフォルト処理を待っている）\n④メモリ使用率が100%\n\n対策:\n①同時に実行するプログラムを減らす\n②物理メモリを増設する\n③不要なバックグラウンドプログラムを終了する\n④ページ置き換えアルゴリズムを改善する（LRU）\n⑤ワーキングセットモデルを使用する",
      "importance": 5
    },
    {
      "id": "tech-2-3-5-fc-8",
      "front": "ワーキングセットとは？スラッシング防止にどう役立つ？",
      "back": "ワーキングセット（Working Set）: プログラムが一定期間内に頻繁にアクセスするページの集合。プログラムの実行に必要な最小限のページ数。\n\nスラッシング防止:\nOSは、各プログラムのワーキングセットを計算し、ワーキングセット全体が物理メモリに収まるように実行するプログラム数を調整（プロセス数の制御）。\n\n例:\n物理メモリ: 4GB\n各プログラムのワーキングセット: 500MB\n→ OSは最大8個のプログラムしか同時に実行しない（8 × 500MB = 4GB）\n→ 9個目のプログラムは実行を一時停止（サスペンド）\n\n効果:\n①ワーキングセット全体がRAMに収まる → ページフォルトが少ない\n②スラッシングを防ぎ、システムの性能を維持\n\nワーキングセットモデル: Windows、Linux等で使用",
      "importance": 4
    },
    {
      "id": "tech-2-3-5-fc-9",
      "front": "局所性の原理とは？時間的局所性と空間的局所性の違いは？",
      "back": "局所性の原理（Principle of Locality）: プログラムがメモリにアクセスする際、ランダムではなく、特定のパターンに従う性質。仮想記憶の性能の基礎。\n\n①時間的局所性（Temporal Locality）:\n最近アクセスされたメモリは、近い将来も再びアクセスされる可能性が高い\n例: ループ内の変数、関数のローカル変数\n→ LRUアルゴリズムが効果的\n\n②空間的局所性（Spatial Locality）:\nあるメモリ領域がアクセスされると、その近くのメモリ領域もアクセスされる可能性が高い\n例: 配列の要素（arr[0]の次にarr[1]をアクセス）、命令の順次実行\n→ ページング方式が効果的（1ページ = 4KB、近くのアドレスは同じページ内）\n\n効果:\n局所性の原理により、ページフォルト率を低く保てる（例: 1%未満）",
      "importance": 4
    },
    {
      "id": "tech-2-3-5-fc-10",
      "front": "セグメント方式とは？ページング方式との違いは？",
      "back": "セグメント方式（Segmentation）: プログラムを論理的な単位（セグメント）に分割して管理する方式。セグメントは可変サイズ。\n\nセグメントの例:\n①コードセグメント: プログラムのコード（命令）\n②データセグメント: グローバル変数、静的変数\n③スタックセグメント: 関数の引数、ローカル変数\n\nページング方式との違い:\n\n分割単位:\nページング: 固定サイズのページ（4KB）\nセグメント: 可変サイズのセグメント（論理的な単位）\n\n外部フラグメンテーション:\nページング: 発生しない\nセグメント: 発生する（可変サイズのため）\n\n利点:\nページング: 管理しやすい、外部フラグメンテーションがない\nセグメント: 論理的な管理、アクセス制御が容易\n\n使用状況:\nページング: 現在の主流\nセグメント: ほとんど使われていない",
      "importance": 3
    },
    {
      "id": "tech-2-3-5-fc-11",
      "front": "実効アクセス時間の計算式は？ページフォルト率の影響は？",
      "back": "実効アクセス時間の計算式:\n実効アクセス時間 = (1 - ページフォルト率) × RAMアクセス時間 + ページフォルト率 × ページフォルト処理時間\n\n例:\nRAMアクセス時間: 100ナノ秒\nページフォルト処理時間: 10ミリ秒 = 10,000,000ナノ秒\nページフォルト率: 0.01%（= 0.0001）\n\n実効アクセス時間 = (1 - 0.0001) × 100 + 0.0001 × 10,000,000\n               = 99.99 + 1,000\n               = 1,099.99ナノ秒\n               ≒ 1,100ナノ秒（11倍遅い）\n\nページフォルト率が1%になると:\n実効アクセス時間 ≒ 100,000ナノ秒（1000倍遅い！）\n\n結論:\nページフォルト処理時間が非常に長いため、ページフォルト率をわずか1%減らすだけで、大幅に性能が向上する。",
      "importance": 4
    },
    {
      "id": "tech-2-3-5-fc-12",
      "front": "仮想記憶の応用技術4つは？",
      "back": "①メモリマップドファイル（Memory-Mapped File）:\nファイルを仮想メモリ空間にマッピングし、ファイルをメモリのように読み書き。大規模ファイルの処理に有効。\n\n②共有メモリ（Shared Memory）:\n複数のプログラムが同じ物理メモリ領域を共有し、高速にデータをやり取り。プロセス間通信（IPC）の一種。\n\n③コピーオンライト（Copy-On-Write, COW）:\nプログラムをコピー（fork）する際、最初は親プロセスと子プロセスが同じ物理メモリを共有。データを書き換えようとした時点でコピーを作成。メモリ使用量を削減。\n\n④デマンドページング（Demand Paging）:\nプログラム起動時に全てのページをRAMに読み込まず、必要になったページだけを読み込む。プログラムの起動時間を短縮。現在のOSで標準的に使用。\n\nこれらの技術により、仮想記憶は現代のOSの基盤技術となっている。",
      "importance": 3
    }
  ]
}
