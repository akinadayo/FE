{
  "topicId": "tech-4-3-4",
  "title": "整列アルゴリズム",
  "flashcards": [
    {
      "id": "tech-4-3-4-fc-1",
      "front": "6つの主要な整列アルゴリズムの計算量（平均・最悪）と空間計算量、安定性を比較せよ",
      "back": "①バブルソート: 平均O(n²)、最悪O(n²)、空間O(1)、安定\n②選択ソート: 平均O(n²)、最悪O(n²)、空間O(1)、不安定\n③挿入ソート: 平均O(n²)、最悪O(n²)、空間O(1)、安定\n④クイックソート: 平均O(n log n)、最悪O(n²)、空間O(log n)、不安定\n⑤マージソート: 平均O(n log n)、最悪O(n log n)、空間O(n)、安定\n⑥ヒープソート: 平均O(n log n)、最悪O(n log n)、空間O(1)、不安定\n\nO(n²)アルゴリズム: 単純だが遅い、小規模データ向き\nO(n log n)アルゴリズム: 高速、大規模データ向き",
      "importance": 5
    },
    {
      "id": "tech-4-3-4-fc-2",
      "front": "バブルソートで配列[5, 2, 8, 1, 9]を昇順に整列する。各パスでの配列の状態と交換回数は？",
      "back": "【初期】[5, 2, 8, 1, 9]\n\n【1回目のパス】\n5と2を交換 → [2, 5, 8, 1, 9]\n8と1を交換 → [2, 5, 1, 8, 9]\n→ 最大値9が末尾に確定（交換2回）\n\n【2回目のパス】\n5と1を交換 → [2, 1, 5, 8, 9]\n→ 2番目の最大値8が確定（交換1回）\n\n【3回目のパス】\n2と1を交換 → [1, 2, 5, 8, 9]\n→ 3番目の最大値5が確定（交換1回）\n\n【4回目のパス】\n交換なし → [1, 2, 5, 8, 9]\n→ 整列完了（交換0回）\n\n合計交換回数: 4回\n比較回数: (n-1) + (n-2) + ... + 1 = n(n-1)/2 = 10回",
      "importance": 4
    },
    {
      "id": "tech-4-3-4-fc-3",
      "front": "選択ソートで配列[5, 2, 8, 1, 9]を昇順に整列する。各ステップでの最小値選択と交換は？",
      "back": "【初期】[5, 2, 8, 1, 9]\n\n【1回目】\n未整列部分[5, 2, 8, 1, 9]から最小値1を選択\n→ 先頭の5と交換 → [1, 2, 8, 5, 9]\n\n【2回目】\n未整列部分[2, 8, 5, 9]から最小値2を選択\n→ 2は既に正しい位置なので交換不要 → [1, 2, 8, 5, 9]\n\n【3回目】\n未整列部分[8, 5, 9]から最小値5を選択\n→ 8と交換 → [1, 2, 5, 8, 9]\n\n【4回目】\n未整列部分[8, 9]から最小値8を選択\n→ 8は既に正しい位置なので交換不要 → [1, 2, 5, 8, 9]\n\n合計交換回数: 2回（バブルソートの4回より少ない）\n比較回数: n(n-1)/2 = 10回（バブルソートと同じ）",
      "importance": 4
    },
    {
      "id": "tech-4-3-4-fc-4",
      "front": "挿入ソートで配列[5, 2, 8, 1]を昇順に整列する。各要素の挿入処理の詳細は？",
      "back": "【初期】[5, 2, 8, 1]\n整列済み: [5]、未整列: [2, 8, 1]\n\n【1回目: 2を挿入】\n2を[5]に挿入\n→ 5 > 2なので5を右にシフト\n→ 2を挿入 → [2, 5, 8, 1]\nシフト回数: 1回\n\n【2回目: 8を挿入】\n8を[2, 5]に挿入\n→ 5 < 8なので挿入位置は末尾\n→ [2, 5, 8, 1]\nシフト回数: 0回\n\n【3回目: 1を挿入】\n1を[2, 5, 8]に挿入\n→ 8 > 1なので8を右にシフト\n→ 5 > 1なので5を右にシフト\n→ 2 > 1なので2を右にシフト\n→ 1を挿入 → [1, 2, 5, 8]\nシフト回数: 3回\n\n合計シフト回数: 4回\n最良ケース（既に整列済み）: O(n)、最悪ケース（逆順）: O(n²)",
      "importance": 4
    },
    {
      "id": "tech-4-3-4-fc-5",
      "front": "クイックソートの分割処理（パーティション）の仕組みは？ピボット5で[5, 2, 8, 1, 9, 3]を分割せよ",
      "back": "【ピボット選択】\nピボット = 5（先頭要素）\n\n【分割の目標】\nピボットより小さい要素を左、大きい要素を右に配置\n\n【分割処理（Hoareの分割法）】\n①左ポインタ(L)を右に移動（5以上の要素を探す）\n  [5, 2, 8, 1, 9, 3] → L = 2（8は5以上）\n\n②右ポインタ(R)を左に移動（5未満の要素を探す）\n  [5, 2, 8, 1, 9, 3] → R = 5（3は5未満）\n\n③L < R なので、8と3を交換\n  [5, 2, 3, 1, 9, 8]\n\n④L, Rを更新 → L = 4（9は5以上）、R = 3（1は5未満）\n\n⑤L > R なので、分割終了\n\n【分割結果】\n左側（5未満）: [2, 3, 1]、ピボット: [5]、右側（5以上）: [9, 8]\n→ これを再帰的に整列\n\n計算量: 平均O(n log n)、最悪O(n²)",
      "importance": 5
    },
    {
      "id": "tech-4-3-4-fc-6",
      "front": "クイックソートが最悪ケースO(n²)になる状況と、その回避策は？",
      "back": "【最悪ケースO(n²)になる状況】\n①既に整列済みのデータ（昇順または降順）\n②ピボットが常に最小値または最大値\n→ 分割が極端に偏る（片側のみ分割、もう片側は空）\n→ 分割の深さがnになり、各層でn回の比較 → O(n²)\n\n例: [1, 2, 3, 4, 5]を先頭をピボットで整列\n→ ピボット1: 左[]、右[2, 3, 4, 5]\n→ ピボット2: 左[]、右[3, 4, 5]\n→ ... → 深さ5、合計10回の比較\n\n【回避策】\n①ピボット選択を工夫\n  - 中央値を選ぶ（median-of-three: 先頭、中央、末尾の3つの中央値）\n  - ランダムな要素を選ぶ\n\n②最悪ケースでヒープソートに切り替え（イントロソート）\n  - 再帰の深さがlog nを超えたらヒープソートに切り替え\n  - C++ std::sortの実装\n\n③小規模データは挿入ソートに切り替え（n < 10程度）",
      "importance": 5
    },
    {
      "id": "tech-4-3-4-fc-7",
      "front": "マージソートで2つの整列済み配列[2, 5, 8]と[1, 3, 9]をマージする手順は？",
      "back": "【初期状態】\n左配列: [2, 5, 8]、左ポインタL=0\n右配列: [1, 3, 9]、右ポインタR=0\n結果配列: []\n\n【マージ処理】\n①L=2、R=1 → 1 < 2 → 結果に1を追加、R++\n  結果: [1]\n\n②L=2、R=3 → 2 < 3 → 結果に2を追加、L++\n  結果: [1, 2]\n\n③L=5、R=3 → 3 < 5 → 結果に3を追加、R++\n  結果: [1, 2, 3]\n\n④L=5、R=9 → 5 < 9 → 結果に5を追加、L++\n  結果: [1, 2, 3, 5]\n\n⑤L=8、R=9 → 8 < 9 → 結果に8を追加、L++\n  結果: [1, 2, 3, 5, 8]\n\n⑥左配列終了 → 右配列の残り[9]をコピー\n  結果: [1, 2, 3, 5, 8, 9]\n\n比較回数: 5回（n₁ + n₂ - 1）\n計算量: O(n₁ + n₂)",
      "importance": 5
    },
    {
      "id": "tech-4-3-4-fc-8",
      "front": "マージソートとクイックソートの違いを、計算量、空間計算量、安定性、適した用途で比較せよ",
      "back": "【マージソート】\n計算量: 常にO(n log n)（最悪ケースでも保証）\n空間計算量: O(n)（追加配列が必要）\n安定性: 安定（同じ値の順序が保たれる）\n適した用途: 安定ソート必須、大規模データ、外部ソート、並列化\n\n【クイックソート】\n計算量: 平均O(n log n)、最悪O(n²)\n空間計算量: O(log n)（再帰スタック）\n安定性: 不安定\n適した用途: 平均的に最速、キャッシュ効率が良い、実用的\n\n【選択基準】\n①安定ソートが必須 → マージソート\n②平均的に最速 → クイックソート\n③最悪ケースO(n²)を回避 → マージソート\n④メモリ制約が厳しい → クイックソート（またはヒープソート）\n\n実用的なハイブリッド:\nC++ std::sort: クイックソート + ヒープソート（イントロソート）\nPython sort: マージソート + 挿入ソート（Timsort）",
      "importance": 5
    },
    {
      "id": "tech-4-3-4-fc-9",
      "front": "ヒープソートの仕組みとヒープ構造の特徴は？配列[5, 2, 8, 1, 9]のヒープ化の手順は？",
      "back": "【ヒープ構造】\n完全2分木で、親ノード ≧ 子ノード（最大ヒープ）または親ノード ≦ 子ノード（最小ヒープ）を満たす\n\n【ヒープ化の手順】\n初期配列: [5, 2, 8, 1, 9]\n\n①配列を完全2分木として見る\n       5\n     /   \\\n    2     8\n   / \\\n  1   9\n\n②最大ヒープの条件を満たすように調整\n  - ノード2の子[1, 9]: 9 > 2なので交換\n       5\n     /   \\\n    9     8\n   / \\\n  1   2\n\n  - ルート5の子[9, 8]: 9 > 5なので交換\n       9\n     /   \\\n    5     8\n   / \\\n  1   2\n\n③整列フェーズ\n  - ルート9を取り出し、末尾と交換 → [2, 5, 8, 1, | 9]\n  - ヒープ再構築 → [8, 5, 2, 1, | 9]\n  - 繰り返す → [1, 2, 5, 8, 9]\n\n計算量: O(n log n)、空間: O(1)",
      "importance": 4
    },
    {
      "id": "tech-4-3-4-fc-10",
      "front": "安定ソートとは？具体例を挙げて説明し、安定/不安定のアルゴリズムを分類せよ",
      "back": "【安定ソートの定義】\n同じ値を持つ要素の元の順序が保たれるソートアルゴリズム\n\n【具体例】\n学生データ: [(1年, 80点, 太郎), (2年, 90点, 花子), (1年, 80点, 次郎)]\n\n①学年でソート（安定）\n→ [(1年, 80点, 太郎), (1年, 80点, 次郎), (2年, 90点, 花子)]\n\n②成績でソート（安定）\n→ [(1年, 80点, 太郎), (1年, 80点, 次郎), (2年, 90点, 花子)]\n→ 太郎と次郎の順序が保たれる（同じ80点でも元の順序を維持）\n\n【分類】\n安定ソート: バブルソート、挿入ソート、マージソート\n不安定ソート: 選択ソート、クイックソート、ヒープソート\n\n【重要性】\n複数キーによる整列（まず学年、次に成績）で必須\nデータベースのソート、スプレッドシートのソートなど",
      "importance": 5
    },
    {
      "id": "tech-4-3-4-fc-11",
      "front": "実用的なハイブリッドソートアルゴリズム（イントロソート、Timsort）の仕組みと利点は？",
      "back": "【イントロソート（C++ std::sort）】\n仕組み: クイックソート + ヒープソート + 挿入ソート\n①まずクイックソートで整列\n②再帰の深さが2×log nを超えたらヒープソートに切り替え（最悪ケース対策）\n③小規模データ（n < 16程度）は挿入ソートに切り替え\n\n利点:\n- クイックソートの平均的な速さ（O(n log n)）\n- 最悪ケースO(n²)を回避（ヒープソートで保証）\n- 小規模データの最適化（挿入ソートでオーバーヘッド削減）\n\n【Timsort（Python、Java）】\n仕組み: マージソート + 挿入ソート\n①配列を「run」（自然な連続部分）に分割\n②各runを挿入ソートで整列（小規模データに高速）\n③runをマージソートで併合\n\n利点:\n- 安定ソート\n- ほぼ整列済みのデータに高速（最良O(n)）\n- 実用的なデータに最適化（逆順の連続部分も検出）",
      "importance": 4
    },
    {
      "id": "tech-4-3-4-fc-12",
      "front": "整列アルゴリズムの選択基準は？データサイズ、要件、環境による使い分けを説明せよ",
      "back": "【データサイズ】\n①小規模（n < 50）→ 挿入ソート\n  理由: シンプル、オーバーヘッド小、ほぼ整列済みならO(n)\n\n②中～大規模 → クイックソート\n  理由: 平均O(n log n)、キャッシュ効率良、実用的に最速\n\n【要件】\n①安定ソート必須 → マージソート\n  例: 複数キーによる整列（まず名前、次に年齢）\n\n②最悪ケースO(n²)回避 → マージソートまたはヒープソート\n  例: リアルタイムシステム（処理時間予測可能）\n\n【環境】\n①メモリ制約が厳しい → ヒープソート\n  理由: 追加メモリO(1)、常にO(n log n)\n  例: 組み込みシステム、大規模データ\n\n②並列化したい → マージソート\n  理由: 分割統治法で並列化が容易\n\n【実用的な選択】\n①汎用ライブラリ → イントロソート（C++）、Timsort（Python）\n②データベースの内部ソート → マージソート（安定性）\n③クイックアクセス必要 → ヒープソート（優先度付きキュー）",
      "importance": 5
    }
  ]
}
