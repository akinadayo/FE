{
  "topicId": "tech-2-3-4",
  "title": "実記憶管理",
  "flashcards": [
    {
      "id": "tech-2-3-4-fc-1",
      "front": "実記憶管理とは？主な方式4つは？",
      "back": "実記憶管理: OSがコンピュータの主記憶装置（RAM）を効率的に管理する技術。物理的に存在するメモリを直接管理し、複数のプログラムに割り当てる。\n\n主な方式:\n①固定区画方式: メモリを固定サイズの区画に分割\n②可変区画方式: プログラムのサイズに応じて動的に区画を作成\n③オーバーレイ方式: プログラムを分割し、必要な部分だけをメモリに配置\n④スワッピング方式: プログラムをハードディスクに退避してメモリを確保\n\n現在の主流は仮想記憶（ページング方式）で、実記憶管理の重要性は相対的に低下しているが、組み込みシステムでは重要。",
      "importance": 5
    },
    {
      "id": "tech-2-3-4-fc-2",
      "front": "固定区画方式の特徴と内部フラグメンテーションとは？",
      "back": "固定区画方式: メモリをあらかじめ固定サイズの区画（例: 2GB、2GB、2GB、2GB）に分割し、各プログラムを区画に割り当てる方式。\n\n利点:\n①実装が簡単\n②管理のオーバーヘッドが小さい\n\n欠点:\n①内部フラグメンテーション: 割り当てられた区画の一部が使われず無駄になる（例: 2GBの区画に0.8GBのプログラム → 1.2GBが無駄）\n②柔軟性がない: 区画サイズより大きいプログラムは実行できない\n\n内部フラグメンテーション: 割り当てられたメモリ領域の「内部」で無駄が発生する現象。固定区画方式の最大の欠点。",
      "importance": 5
    },
    {
      "id": "tech-2-3-4-fc-3",
      "front": "可変区画方式の特徴と外部フラグメンテーションとは？",
      "back": "可変区画方式: プログラムが必要とするメモリサイズに応じて、動的に区画を作成する方式。\n\n利点:\n①内部フラグメンテーションが発生しない（必要な分だけ割り当てる）\n②メモリを効率的に使用できる\n\n欠点:\n①外部フラグメンテーション: 空きメモリが細かく分散し、合計では十分なメモリがあるのに連続した領域として確保できない\n②管理が複雑\n\n外部フラグメンテーション: 空きメモリの合計は十分（例: 1.5GB + 0.8GB + 1.4GB = 3.7GB）だが、断片化しているため大きなプログラム（例: 2GB）を割り当てられない現象。\n\n対策: メモリコンパクション（空き領域をまとめる）",
      "importance": 5
    },
    {
      "id": "tech-2-3-4-fc-4",
      "front": "メモリコンパクションとは？利点と欠点は？",
      "back": "メモリコンパクション（ガベージコレクション）: メモリ上のプログラムを移動させて、断片化した空き領域を1つにまとめる技術。\n\n流れ:\n①実行中のプログラムをメモリの先頭に移動\n②空き領域をまとめて、連続した1つの大きな空き領域にする\n③新しいプログラムを割り当てられるようになる\n\n利点:\n外部フラグメンテーションを解決できる\n\n欠点:\n①処理時間がかかる（プログラムを移動させる）\n②システムが一時的に停止する（オーバーヘッド）\n\nそのため、頻繁に実行せず、外部フラグメンテーションが深刻になった場合のみ実行する。",
      "importance": 4
    },
    {
      "id": "tech-2-3-4-fc-5",
      "front": "First Fit、Best Fit、Worst Fitの違いは？",
      "back": "メモリ割り当てアルゴリズム（可変区画方式で使用）:\n\n①First Fit（最初適合）:\n先頭から順番に探し、最初に見つかった十分なサイズの空き領域に割り当てる。\n利点: 探索が高速\n欠点: 大きな空き領域が細かく分割されやすい\n使用状況: 最も一般的\n\n②Best Fit（最良適合）:\n全ての空き領域を調べ、サイズが最も近い領域に割り当てる。\n利点: 無駄が少ない\n欠点: 小さな空き領域が大量に発生（外部フラグメンテーション）、探索に時間がかかる\n\n③Worst Fit（最悪適合）:\n全ての空き領域を調べ、最も大きい領域に割り当てる。\n利点: 残り領域が大きい\n欠点: 大きな空き領域が減る、探索に時間がかかる",
      "importance": 4
    },
    {
      "id": "tech-2-3-4-fc-6",
      "front": "オーバーレイ方式とは？利点と欠点は？",
      "back": "オーバーレイ方式: プログラムを複数のモジュール（部品）に分割し、必要なモジュールだけを順次メモリに読み込む方式。使い終わったモジュールは、次のモジュールで上書き（オーバーレイ）される。\n\n利点:\n①メモリ容量より大きなプログラムを実行できる（例: 8GBのメモリで10GBのプログラムを実行）\n②メモリが少ないシステムでも大規模プログラムを実行可能\n\n欠点:\n①プログラマがモジュール分割を設計する必要がある（複雑）\n②モジュールの切り替えに時間がかかる（ディスクからメモリへの読み込み）\n③現在はほとんど使われていない（仮想記憶が主流）\n\n使用状況: 1960年代～1980年代に広く使用。現在は組み込みシステムで一部使用。",
      "importance": 3
    },
    {
      "id": "tech-2-3-4-fc-7",
      "front": "スワッピング方式とは？スワップアウト・スワップインとは？",
      "back": "スワッピング方式: メモリが不足した場合、実行中のプログラムを一時的にハードディスクに退避し、メモリを空けて新しいプログラムを実行する方式。\n\nスワップアウト: プログラムのデータをメモリからハードディスク（スワップ領域）に退避すること\n\nスワップイン: 退避されたプログラムのデータをハードディスクからメモリに戻すこと\n\n流れ:\n①メモリが不足\n②OSがしばらく使われていないプログラムを選択\n③そのプログラムをスワップアウト（HDDに退避）\n④メモリが空く\n⑤新しいプログラムをメモリに配置（スワップイン）\n⑥ユーザーが退避されたプログラムに切り替える → スワップイン\n\n利点: 物理メモリより多くのプログラムを実行可能",
      "importance": 5
    },
    {
      "id": "tech-2-3-4-fc-8",
      "front": "スワッピングの欠点とスラッシングとは？",
      "back": "スワッピングの欠点:\n①ハードディスクへのアクセスが非常に遅い（メモリ: 数ナノ秒、HDD: 数ミリ秒、100万倍遅い）\n②スラッシングが発生する可能性\n\nスラッシング（Thrashing）:\nスワッピングが頻繁に発生し、システムがほとんどスワッピングの処理に時間を使い、プログラムの実行が進まなくなる現象。\n\n発生原因:\nメモリに対して実行するプログラムが多すぎる（例: 8GBのメモリで10個のプログラム（各1GB）を同時実行）\n\nスラッシングの対策:\n①メモリを増設する\n②同時に実行するプログラムを減らす\n③仮想記憶のページング アルゴリズム（LRU）を改善する",
      "importance": 5
    },
    {
      "id": "tech-2-3-4-fc-9",
      "front": "内部フラグメンテーションと外部フラグメンテーションの違いは？",
      "back": "内部フラグメンテーション:\n割り当てられた区画の「内部」で無駄が発生する現象。固定区画方式で発生。\n例: 2GBの区画に0.8GBのプログラム → 1.2GBが無駄（他のプログラムには使えない）\n\n外部フラグメンテーション:\n空きメモリが細かく分散し、合計では十分なメモリがあるのに連続した領域として確保できない現象。可変区画方式で発生。\n例: 空き領域が1.5GB、0.8GB、1.4GBに分散 → 合計3.7GBあるが、2GBのプログラムを割り当てられない\n\n対策:\n内部フラグメンテーション: 可変区画方式を使用\n外部フラグメンテーション: メモリコンパクションを実行、またはFirst Fitアルゴリズムを使用",
      "importance": 5
    },
    {
      "id": "tech-2-3-4-fc-10",
      "front": "スワッピング方式と仮想記憶の違いは？",
      "back": "スワッピング方式:\nプログラム全体をメモリとハードディスクの間で移動する。\n単位: プログラム全体（例: 1GB）\n欠点: プログラム全体を移動するため時間がかかる、スラッシングが発生しやすい\n使用状況: 古いOS（1970年代～1990年代）\n\n仮想記憶（ページング方式）:\nプログラムを小さな単位（ページ、例: 4KB）に分割し、必要なページだけをメモリに配置する。\n単位: ページ（例: 4KB）\n利点: 必要なページだけを移動するため効率的、スラッシングが発生しにくい\n使用状況: 現在のOS（Windows、macOS、Linux）の主流\n\n関係: スワッピング方式は仮想記憶の基礎となる技術。仮想記憶は、スワッピングをページ単位で実行する改良版。",
      "importance": 4
    },
    {
      "id": "tech-2-3-4-fc-11",
      "front": "実記憶管理の各方式が適したシステムは？",
      "back": "①固定区画方式:\nリアルタイム性が求められるシステム（工場の制御システム、組み込みシステム）\n理由: 実装が簡単、処理時間が予測可能、オーバーヘッドが小さい\n\n②可変区画方式:\nメモリが少ない組み込みシステム\n理由: 内部フラグメンテーションが発生しない、メモリを効率的に使用\n\n③オーバーレイ方式:\nメモリが極端に少ないシステム（古いマイコン、IoTデバイス）\n理由: メモリ容量より大きなプログラムを実行可能\n\n④スワッピング方式:\n古いOS（現在はほとんど使われない）\n\n⑤仮想記憶（ページング方式）:\n現在の一般的なOS（Windows、macOS、Linux）\n理由: 効率的、柔軟、スラッシングが発生しにくい",
      "importance": 4
    },
    {
      "id": "tech-2-3-4-fc-12",
      "front": "メモリ管理の歴史的変遷は？",
      "back": "①1960年代～1970年代:\n固定区画方式、オーバーレイ方式が主流。メモリが非常に少ない（数KB～数MB）ため、効率的なメモリ管理が必須。\n\n②1980年代:\n可変区画方式、スワッピング方式が普及。メモリが増加（数MB～数十MB）し、複数のプログラムを同時実行できるようになった。\n\n③1990年代～現在:\n仮想記憶（ページング方式）が主流。メモリが急増（数GB～数百GB）し、仮想記憶技術が普及。実記憶管理の重要性は相対的に低下。\n\n④現在:\n一般的なOS: 仮想記憶（ページング方式）\n組み込みシステム: 可変区画方式、一部オーバーレイ方式\nリアルタイムOS: 固定区画方式\n\nメモリの容量増加と仮想記憶技術の進化により、メモリ管理は進化してきた。",
      "importance": 3
    }
  ]
}
