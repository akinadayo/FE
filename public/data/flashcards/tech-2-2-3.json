{
  "topicId": "tech-2-2-3",
  "title": "システムの信頼性",
  "flashcards": [
    {
      "id": "tech-2-2-3-001",
      "front": "RASISとは何ですか？",
      "back": "システムの信頼性を評価する5つの指標の頭文字です。R（Reliability：信頼性）システムが正常に動作し続ける能力、A（Availability：可用性）システムが使用可能な時間の割合、S（Serviceability：保守性）障害からの復旧の容易さ、I（Integrity：保全性）データの整合性と正確性、S（Security：安全性）不正アクセスからの保護能力。これら5要素でシステムの総合的な信頼性を評価します。",
      "importance": "high"
    },
    {
      "id": "tech-2-2-3-002",
      "front": "MTBF（平均故障間隔）とは何ですか？",
      "back": "Mean Time Between Failuresの略で、システムが故障してから次に故障するまでの平均時間です。MTBF = 総稼働時間 ÷ 故障回数 で計算されます。MTBFが長いほど信頼性が高いシステムです。例えば、1000時間稼働して5回故障した場合、MTBF = 1000 ÷ 5 = 200時間となります。信頼性の定量的評価に使用されます。",
      "importance": "high"
    },
    {
      "id": "tech-2-2-3-003",
      "front": "MTTR（平均修理時間）とは何ですか？",
      "back": "Mean Time To Repairの略で、システムが故障してから修理が完了するまでの平均時間です。MTTR = 総修理時間 ÷ 故障回数 で計算されます。MTTRが短いほど保守性が高いシステムです。例えば、5回の故障で合計10時間修理した場合、MTTR = 10 ÷ 5 = 2時間となります。可用性の向上にはMTTRの短縮が重要です。",
      "importance": "high"
    },
    {
      "id": "tech-2-2-3-004",
      "front": "稼働率の計算式を説明してください。",
      "back": "稼働率 = MTBF ÷ (MTBF + MTTR) で計算されます。または、稼働率 = 稼働時間 ÷ (稼働時間 + 停止時間) でも求められます。例えば、MTBF = 100時間、MTTR = 5時間の場合、稼働率 = 100 ÷ (100 + 5) = 100 ÷ 105 ≒ 0.952 = 95.2% となります。稼働率が高いほど可用性の高いシステムです。",
      "importance": "high"
    },
    {
      "id": "tech-2-2-3-005",
      "front": "直列システムの稼働率はどのように計算しますか？",
      "back": "複数のシステムが直列に接続されている場合、全体の稼働率は各システムの稼働率の積になります。稼働率 = R1 × R2 × R3 × ... となります。例えば、稼働率90%のシステムを3台直列に接続すると、全体の稼働率 = 0.9 × 0.9 × 0.9 = 0.729 = 72.9% となり、個々の稼働率より低下します。直列システムは信頼性が低下するため、冗長化が重要です。",
      "importance": "high"
    },
    {
      "id": "tech-2-2-3-006",
      "front": "並列システムの稼働率はどのように計算しますか？",
      "back": "複数のシステムが並列（冗長構成）の場合、全体の稼働率は 1 - (1 - R1) × (1 - R2) × ... で計算されます。例えば、稼働率90%のシステムを2台並列にすると、全体の稼働率 = 1 - (1 - 0.9) × (1 - 0.9) = 1 - 0.1 × 0.1 = 1 - 0.01 = 0.99 = 99% となり、個々の稼働率より向上します。並列化により信頼性が大幅に向上します。",
      "importance": "high"
    },
    {
      "id": "tech-2-2-3-007",
      "front": "デュアルシステムとは何ですか？",
      "back": "同じ処理を2つのシステムで同時に実行し、結果を照合する冗長構成です。一方が故障しても他方で処理を継続できます。特徴は、1) 常に2系統で同じ処理を実行、2) 結果を比較して誤りを検出、3) 無停止運転が可能。高い信頼性が求められるミッションクリティカルなシステム（金融システム、航空管制など）で使用されますが、コストは2倍になります。",
      "importance": "medium"
    },
    {
      "id": "tech-2-2-3-008",
      "front": "デュプレックスシステムとは何ですか？",
      "back": "現用系と待機系の2系統を用意し、現用系の故障時に待機系に切り替える冗長構成です。ホットスタンバイ（待機系も常時起動）とコールドスタンバイ（待機系は停止）があります。デュアルシステムと異なり、通常は1系統のみで処理を行うため、処理能力は2倍になりません。切り替え時に短時間の停止が発生する可能性があります。",
      "importance": "medium"
    },
    {
      "id": "tech-2-2-3-009",
      "front": "フォールトトレランスとは何ですか？",
      "back": "Fault Toleranceで、耐障害性を意味します。システムの一部に障害が発生しても、全体としては正常に動作を継続できる設計思想です。冗長化（二重化、三重化）により実現します。例：RAID、デュアルシステム、クラスタリングなど。ハードウェア障害だけでなく、ソフトウェアバグにも対応できる設計が理想です。高可用性システムに不可欠な概念です。",
      "importance": "medium"
    },
    {
      "id": "tech-2-2-3-010",
      "front": "フェールセーフとは何ですか？",
      "back": "Fail Safeで、システムに障害が発生した際に、常に安全側に動作するように設計する考え方です。例えば、1) 信号機は故障時に赤信号になる、2) エレベーターは停電時に最寄り階で停止、3) 遮断機は故障時に閉じる、などです。人命や財産への被害を最小限にすることが目的です。安全性が最優先されるシステムで採用されます。",
      "importance": "medium"
    },
    {
      "id": "tech-2-2-3-011",
      "front": "フェールソフトとは何ですか？",
      "back": "Fail Softで、システムの一部に障害が発生した際に、機能や性能を縮小しても運転を継続する設計思想です。例えば、1) 一部のサーバが故障しても残りで処理続行、2) 画質を落として動画配信を継続、3) 一部機能を停止して基本機能は維持、などです。完全停止より縮退運転を優先し、サービスの継続性を重視します。",
      "importance": "medium"
    },
    {
      "id": "tech-2-2-3-012",
      "front": "稼働率99%と99.9%の違いを年間停止時間で説明してください。",
      "back": "稼働率99%の場合、年間停止時間は約87.6時間（約3.6日）です。稼働率99.9%の場合、年間停止時間は約8.76時間です。稼働率99.99%（フォーナイン）では約52.6分、99.999%（ファイブナイン）では約5.26分となります。わずかな稼働率の差が、実際の停止時間では大きな差になることがわかります。",
      "importance": "low"
    },
    {
      "id": "tech-2-2-3-013",
      "front": "フェールオーバーとフェールバックの違いは何ですか？",
      "back": "フェールオーバーは、現用系が故障した際に待機系に処理を切り替えることです。フェールバックは、故障した現用系が復旧した後、待機系から現用系に処理を戻すことです。フェールバックを行わず、そのまま待機系で運用を続ける場合もあります。計画的なフェールバックは、メンテナンス時間を設けて実施することが多いです。",
      "importance": "low"
    },
    {
      "id": "tech-2-2-3-014",
      "front": "フェールファストとは何ですか？",
      "back": "Fail Fastで、異常を検出したらすぐに処理を停止してエラーを報告する設計思想です。異常な状態での処理継続によるデータ破損や二次障害を防ぎます。プログラミングでは、入力値のバリデーションを最初に行い、不正な値の場合は即座に例外を投げるなどの実装が該当します。早期発見・早期対応により、問題の影響範囲を最小化できます。",
      "importance": "low"
    }
  ]
}