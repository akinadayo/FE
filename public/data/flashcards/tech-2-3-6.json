{
  "topicId": "tech-2-3-6",
  "title": "プログラムの性質",
  "flashcards": [
    {
      "id": "tech-2-3-6-fc-1",
      "front": "プログラムの4つの重要な性質は？",
      "back": "①再配置可能（Relocatable、リロケータブル）: メモリのどの位置に配置しても実行できる\n\n②再使用可能（Reusable、リユーザブル）: 実行後、再度読み込むことなく繰り返し実行できる\n\n③再入可能（Reentrant、リエントラント）: 複数のプログラムから同時に呼び出しても正しく動作する\n\n④再帰的（Recursive、リカーシブ）: 関数が自分自身を呼び出せる\n\nこれらの性質により、メモリを効率的に使用でき、マルチタスク環境で安全に実行できる。",
      "importance": 5
    },
    {
      "id": "tech-2-3-6-fc-2",
      "front": "リロケータブルプログラムとは？絶対アドレスと相対アドレスの違いは？",
      "back": "リロケータブルプログラム（再配置可能）: メモリのどの位置に配置しても正しく実行できるプログラム。相対アドレスを使用。\n\n絶対アドレス:\n固定されたメモリアドレス（例: 0x10000100）\n問題点: OSがプログラムを別の位置に配置すると正しく動作しない\n\n相対アドレス:\nプログラムの先頭からの相対的な位置（例: BASEレジスタ + 0x100）\n利点: OSがプログラムをどこに配置しても正しく動作\n\n現在のOSでは、ほとんどのプログラムがリロケータブル。仮想記憶により、プログラムは常に同じ仮想アドレスから始まるように見える。",
      "importance": 4
    },
    {
      "id": "tech-2-3-6-fc-3",
      "front": "リユーザブルプログラムとは？条件は？",
      "back": "リユーザブルプログラム（再使用可能）: 実行後、再度ディスクから読み込むことなく、繰り返し実行できるプログラム。\n\n条件:\n①コード部分（命令）を変更しない（自己書き換えコードを使わない）\n②データ部分だけを変更\n③実行終了後、データ部分を初期状態に戻す\n\n利点:\n①メモリ節約（同じプログラムを複数回実行する場合、1回だけメモリに読み込めばよい）\n②ディスクアクセスの削減\n\n実装:\nコード部分を読み取り専用（Read-Only）、データ部分を読み書き可能（Read-Write）に設定",
      "importance": 4
    },
    {
      "id": "tech-2-3-6-fc-4",
      "front": "リエントラントプログラムとは？条件は？",
      "back": "リエントラントプログラム（再入可能）: 複数のプログラム（プロセス、スレッド）から同時に呼び出されても、正しく動作するプログラム。\n\n条件:\n①グローバル変数や静的変数を変更しない（読み取り専用はOK）\n②各呼び出しごとに独立したデータ領域（スタック、引数）を使用\n③共有リソース（ファイル、データベース）へのアクセスは排他制御（ロック）を使用\n\n利点:\n①共有ライブラリとして使用できる\n②マルチスレッドプログラムで安全に使用できる\n③メモリ節約（1つのプログラムを複数のプロセスで共有）\n\n主な用途: 共有ライブラリ（libc.so、kernel32.dll）、Webサーバのリクエスト処理",
      "importance": 5
    },
    {
      "id": "tech-2-3-6-fc-5",
      "front": "リカーシブプログラムとは？利点と欠点は？",
      "back": "リカーシブプログラム（再帰的）: 関数が自分自身を呼び出すプログラム。\n\n利点:\n①アルゴリズムがシンプルで理解しやすい（問題の定義をそのままコードにできる）\n②コードが短い（ループを使うより簡潔）\n\n欠点:\n①スタックオーバーフロー（再帰の深さが深すぎるとスタックが溢れる）\n②パフォーマンスが低い（関数呼び出しのオーバーヘッド、同じ計算を繰り返す）\n\n主な用途:\n階乗、フィボナッチ数列、木構造の探索、分割統治法（クイックソート、マージソート）、ディレクトリ探索\n\n基底条件: 再帰を終了する条件（例: factorial(0) = 1）が必須",
      "importance": 4
    },
    {
      "id": "tech-2-3-6-fc-6",
      "front": "リユーザブルとリエントラントの違いは？",
      "back": "リユーザブル（再使用可能）:\n呼び出し: 1つのプロセスから繰り返し呼び出し\nデータ: 実行後にデータを初期状態に戻す\n用途: メモリ節約（再度ディスクから読み込まない）\n\nリエントラント（再入可能）:\n呼び出し: 複数のプロセス・スレッドから同時に呼び出し\nデータ: 各呼び出しごとに独立したデータ領域を使用\n用途: 共有ライブラリ、マルチスレッドプログラム\n\n関係:\n①リエントラントならリユーザブル（各呼び出しが独立 → 繰り返し実行可能）\n②リユーザブルでもリエントラントとは限らない（グローバル変数を使う場合）\n\nリエントラントの方が厳しい条件。",
      "importance": 5
    },
    {
      "id": "tech-2-3-6-fc-7",
      "front": "グローバル変数を使う関数がリエントラントでない理由は？具体例は？",
      "back": "グローバル変数は全てのスレッドで共有されるため、複数のスレッドから同時に変更すると競合状態（Race Condition）が発生する。\n\n具体例:\n```c\nint counter = 0;  // グローバル変数\nvoid increment() {\n    counter = counter + 1;\n}\n```\n\n問題:\nスレッドAとスレッドBが同時にincrement()を呼び出すと:\n①両方がcounter = 0を読み込む\n②両方がcounter = 1を計算\n③結果: counter = 1（期待値: 2）\n\n対策:\n①ローカル変数を使う（各スレッドのスタックに配置）\n②引数として受け取る\n③排他制御（ロック）を使う\n\nリエントラントな関数は、グローバル変数を変更せず、独立したデータ領域を使う。",
      "importance": 5
    },
    {
      "id": "tech-2-3-6-fc-8",
      "front": "再帰プログラムでスタックオーバーフローが発生する理由と対策は？",
      "back": "理由:\n各関数呼び出しごとに、スタックにローカル変数、戻りアドレスなどが積まれる。再帰の深さが深すぎると、スタックが溢れる。\n\nスタックサイズの制限:\nLinux: 8MB、Windows: 1MB\n\n例:\n1回の関数呼び出しで100バイトのスタックを使う場合\n再帰の深さ: 10,000回 → スタック使用量: 1MB\n→ スタックオーバーフロー\n\n対策:\n①再帰を反復（ループ）に書き換える\n  → スタック使用量: 定数（ループの深さに依存しない）\n②末尾再帰最適化（Tail Recursion Optimization）を使う\n  → コンパイラが最適化し、スタックを使わないループに変換\n③再帰の深さを制限する\n  → 例: n > 1000の場合、エラーを返す",
      "importance": 4
    },
    {
      "id": "tech-2-3-6-fc-9",
      "front": "共有ライブラリ（Shared Library、DLL）に必要な性質は？",
      "back": "共有ライブラリ（例: libc.so、kernel32.dll）に必要な性質:\n\n①リロケータブル:\nメモリのどの位置に配置しても実行できる\n→ 複数のプログラムが同じライブラリを異なるアドレスで使用\n\n②リユーザブル:\n繰り返し実行できる\n→ 複数のプログラムが同じライブラリを繰り返し呼び出す\n\n③リエントラント:\n複数のプログラム・スレッドから同時に呼び出しても正しく動作\n→ Webサーバなどで複数のクライアントから同時にライブラリを使用\n\n利点:\n①メモリ節約（10個のプログラムが同じライブラリを使う場合、メモリには1つだけ配置）\n②ライブラリのアップデートが容易（プログラムを再コンパイルせず、ライブラリだけ更新）",
      "importance": 5
    },
    {
      "id": "tech-2-3-6-fc-10",
      "front": "リカーシブプログラムはリエントラントである必要がある理由は？",
      "back": "再帰プログラムは、関数が自分自身を呼び出すため、同じ関数が複数回（階層的に）同時に実行される。\n\n例: factorial(5)を呼び出すと:\nfactorial(5) → factorial(4) → factorial(3) → factorial(2) → factorial(1) → factorial(0)\n\n同じ関数factorial()が6つ同時に実行中（スタックに積まれている）。\n\nリエントラントでない場合:\nグローバル変数を使うと、各呼び出しが同じグローバル変数を変更 → 競合状態、データ破損\n\nリエントラントの場合:\n各呼び出しごとに独立したデータ領域（スタック上のローカル変数）を使用 → 正しく動作\n\n結論:\n再帰プログラムは、リエントラントである必要がある（各呼び出しが独立したスタック領域を使う）。",
      "importance": 4
    },
    {
      "id": "tech-2-3-6-fc-11",
      "front": "プログラムの性質の関係は？",
      "back": "①リエントラントならリユーザブル:\nリエントラントプログラムは、各呼び出しごとに独立したデータ領域を使うため、繰り返し実行できる（リユーザブル）。\n逆は成り立たない（リユーザブルでもグローバル変数を使う場合、リエントラントでない）。\n\n②リカーシブはリエントラント:\n再帰プログラムは、関数が自分自身を呼び出すため、リエントラントである必要がある（各呼び出しごとに独立したスタック領域を使う）。\n\n③リロケータブルは独立:\nリロケータブルは、配置の柔軟性を示す性質で、他の性質とは独立。\n\n現在のOSで動作するプログラムは、ほとんどがリロケータブル、リユーザブル、リエントラント、リカーシブの全てを満たす。",
      "importance": 4
    },
    {
      "id": "tech-2-3-6-fc-12",
      "front": "4つの性質の実際の活用例は？",
      "back": "①共有ライブラリ（libc.so、kernel32.dll）:\n必要な性質: リロケータブル、リユーザブル、リエントラント\n理由: 複数のプログラムで共有、同時に呼び出される\n\n②Webサーバ（Apache、Nginx）:\n必要な性質: リエントラント\n理由: 複数のスレッドから同時にリクエスト処理関数を呼び出す\n\n③再帰的なアルゴリズム（クイックソート、ディレクトリ探索）:\n必要な性質: リカーシブ\n理由: 関数が自分自身を呼び出す\n\n④OSのメモリ管理:\n必要な性質: リロケータブル\n理由: プログラムをメモリのどこに配置してもよい\n\nこれらの性質を理解することで、効率的で安全なソフトウェアを開発できる。",
      "importance": 3
    }
  ]
}
