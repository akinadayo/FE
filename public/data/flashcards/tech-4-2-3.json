{
  "topicId": "tech-4-2-3",
  "title": "オブジェクト指向",
  "flashcards": [
    {
      "id": "tech-4-2-3-fc-1",
      "front": "オブジェクト指向プログラミングの3つの主な特徴は？",
      "back": "①カプセル化（Encapsulation）：データと処理を1つのクラスにまとめ、外部から直接アクセスできないように隠蔽\n\n②継承（Inheritance）：既存のクラス（親クラス）の属性とメソッドを引き継いで、新しいクラス（子クラス）を定義\n\n③ポリモーフィズム（Polymorphism、多態性）：同じメソッド名でも、オブジェクトの型によって異なる処理が実行される",
      "importance": 5
    },
    {
      "id": "tech-4-2-3-fc-2",
      "front": "クラスとインスタンスの違いは？具体例は？",
      "back": "クラス（Class）：オブジェクトの設計図（テンプレート）。属性とメソッドを定義。\n\nインスタンス（Instance）：クラスを基に生成された実体（オブジェクト）。クラスが「設計図」、インスタンスが「製品」。\n\n具体例：\nクラス：Car（車の設計図）\nインスタンス：satoCar（佐藤さんの車）、tanakaCar（田中さんの車）\n→ 1つのクラスから複数のインスタンスを生成可能",
      "importance": 5
    },
    {
      "id": "tech-4-2-3-fc-3",
      "front": "カプセル化とは？目的は？",
      "back": "定義：データ（属性）と処理（メソッド）を1つのクラスにまとめ、外部から直接アクセスできないように隠蔽する仕組み。\n\n目的：\n①データの不正な変更を防ぐ（例：残高がマイナスにならない）\n②クラス内部の実装を隠し、インターフェース（公開メソッド）のみを外部に公開\n③変更の影響範囲を限定する\n\n実現方法：アクセス修飾子（public, private, protected）を使用\nベストプラクティス：属性は private、メソッドは public（必要に応じて）",
      "importance": 5
    },
    {
      "id": "tech-4-2-3-fc-4",
      "front": "アクセス修飾子4種類（public, private, protected, なし）とアクセス可能範囲は？",
      "back": "①public：どこからでもアクセス可能\n範囲：クラス内、同じパッケージ、サブクラス、外部クラス\n\n②private：クラス内部のみアクセス可能\n範囲：クラス内のみ\n\n③protected：同じパッケージとサブクラスからアクセス可能\n範囲：クラス内、同じパッケージ、サブクラス\n\n④（なし、package-private）：同じパッケージ内からアクセス可能\n範囲：クラス内、同じパッケージ",
      "importance": 4
    },
    {
      "id": "tech-4-2-3-fc-5",
      "front": "継承とは？汎化と特化の違いは？",
      "back": "継承（Inheritance）：既存のクラス（親クラス、スーパークラス）の属性とメソッドを引き継いで、新しいクラス（子クラス、サブクラス）を定義する仕組み。コードの再利用性が高まる。\n\n汎化（Generalization）：複数のクラスから共通部分を抽出して親クラスを作成\n例：Dog と Cat から Animal を抽出\n\n特化（Specialization）：親クラスを継承して、子クラスに固有の属性やメソッドを追加\n例：Animal を継承して Dog に bark メソッドを追加",
      "importance": 5
    },
    {
      "id": "tech-4-2-3-fc-6",
      "front": "オーバーライドとは？具体例は？",
      "back": "定義：子クラスで、親クラスのメソッドを再定義すること。\n\n具体例：\n```java\npublic class Animal {\n    public void eat() {\n        System.out.println(\"食べています。\");\n    }\n}\n\npublic class Dog extends Animal {\n    @Override\n    public void eat() {  // Animal の eat を上書き\n        System.out.println(\"ドッグフードを食べています。\");\n    }\n}\n\nDog dog = new Dog();\ndog.eat();  // 出力: ドッグフードを食べています。\n```\n\n効果：子クラスで親クラスのメソッドの振る舞いを変更できる",
      "importance": 4
    },
    {
      "id": "tech-4-2-3-fc-7",
      "front": "ポリモーフィズム（多態性）とは？利点は？",
      "back": "定義：「同じメソッド名でも、オブジェクトの型によって異なる処理が実行される」という性質。異なるクラスのオブジェクトを統一的に扱える。\n\n例：Animal 型の変数に Dog や Cat を代入し、makeSound() を呼ぶと、実際の型に応じた処理が実行される。\n\n利点：\n①拡張性：新しいクラス（Bird）を追加しても、既存のコードを変更不要\n②統一的な処理：異なるクラスを同じインターフェースで扱える\n③コードの簡潔化：if-else で型を判定する必要がない",
      "importance": 5
    },
    {
      "id": "tech-4-2-3-fc-8",
      "front": "オーバーロードとオーバーライドの違いは？",
      "back": "オーバーロード（Overload）：\n定義：同じメソッド名で、引数の型や個数が異なるメソッドを複数定義\n例：void print(int x)、void print(String s)\n\nオーバーライド（Override）：\n定義：子クラスで親クラスのメソッドを再定義\n例：親クラスの eat() を子クラスで再定義\n\n違い：\nオーバーロード：同じクラス内で引数が異なる\nオーバーライド：親子クラス間でメソッドを上書き",
      "importance": 4
    },
    {
      "id": "tech-4-2-3-fc-9",
      "front": "集約（Aggregation）とは？コンポジションとアグリゲーションの違いは？",
      "back": "集約（Aggregation）：複数のオブジェクトを組み合わせて、1つの大きなオブジェクトを構成する関係。\n例：車 = エンジン + タイヤ + ハンドル\n\nコンポジション（Composition、強い集約）：\n部品が全体に強く依存。全体が削除されると部品も削除される。\n例：車とエンジン（車が削除されるとエンジンも削除）\n\nアグリゲーション（Aggregation、弱い集約）：\n部品が全体に弱く依存。全体が削除されても部品は残る。\n例：車と運転手（車が削除されても運転手は残る）",
      "importance": 4
    },
    {
      "id": "tech-4-2-3-fc-10",
      "front": "抽象クラスとインターフェースの違いは？",
      "back": "抽象クラス（Abstract Class）：\nインスタンスを生成できないクラス。子クラスで実装を強制するための設計図。\n例：abstract class Animal { abstract void makeSound(); }\n\nインターフェース（Interface）：\n抽象メソッドのみを定義する「契約」。複数のクラスで共通のメソッドを強制。\n例：interface Flyable { void fly(); } → Bird と Airplane が実装\n\n違い：\n抽象クラス：一部の実装を持てる、単一継承のみ\nインターフェース：実装を持たない、多重実装可能",
      "importance": 4
    },
    {
      "id": "tech-4-2-3-fc-11",
      "front": "オブジェクト指向の利点は？",
      "back": "①再利用性が高い：既存のクラスを継承して再利用できる\n例：Animal クラスを継承して Dog、Cat を作成\n\n②保守性が高い：変更の影響範囲が限定される（カプセル化）\n例：クラス内部の実装を変更しても、外部には影響しない\n\n③拡張性が高い：新しい機能を追加しやすい（ポリモーフィズム）\n例：新しい動物 Bird を追加しても、既存のコード（for ループ）を変更不要",
      "importance": 4
    },
    {
      "id": "tech-4-2-3-fc-12",
      "front": "コンストラクタとは？役割は？",
      "back": "定義：インスタンス生成時に自動的に呼ばれる特殊なメソッド。初期化処理を記述。\n\n役割：\n①属性の初期値を設定\n②必要な準備処理を実行\n\n具体例：\n```java\npublic class Car {\n    private String color;\n    \n    public Car(String color) {  // コンストラクタ\n        this.color = color;  // 初期化\n    }\n}\n\nCar car = new Car(\"赤\");  // インスタンス生成時にコンストラクタが呼ばれる\n```\n\n特徴：クラス名と同じ名前、戻り値なし",
      "importance": 3
    }
  ]
}
