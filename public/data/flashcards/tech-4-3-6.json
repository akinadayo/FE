{
  "topicId": "tech-4-3-6",
  "title": "その他のアルゴリズム",
  "flashcards": [
    {
      "id": "tech-4-3-6-fc-1",
      "front": "再帰アルゴリズムの2つの構成要素は？factorial(5)の実行過程は？",
      "back": "【2つの構成要素】\n①基底ケース（Base Case）: 再帰を終了する条件（例: n = 0 または n = 1 のとき 1 を返す）\n②再帰ケース（Recursive Case）: 問題を小さな問題に分割し、自分自身を呼び出す（例: n × factorial(n-1)）\n\n【factorial(5)の実行過程】\n①factorial(5) → 5 × factorial(4)\n②factorial(4) → 4 × factorial(3)\n③factorial(3) → 3 × factorial(2)\n④factorial(2) → 2 × factorial(1)\n⑤factorial(1) → 1（基底ケース）\n⑥戻り値の計算: 2×1=2 → 3×2=6 → 4×6=24 → 5×24=120\n\n最終結果: 120",
      "importance": 5
    },
    {
      "id": "tech-4-3-6-fc-2",
      "front": "再帰の利点と欠点は？どのような問題に適している？",
      "back": "【利点】\n①コードが簡潔で読みやすい（階乗の定義をそのまま書ける）\n②問題を自然に小さな部分問題に分割できる\n③木構造やグラフ探索など、再帰的な構造を持つ問題に適している\n\n【欠点】\n①関数呼び出しのオーバーヘッド（スタックのメモリ消費）\n②深い再帰（n が大きい）は、スタックオーバーフローを引き起こす可能性\n③同じ計算を繰り返す場合がある（例: フィボナッチ数列）→ 動的計画法で改善\n\n【適している問題】\n①木構造の走査（ファイルシステム、DOM操作）\n②分割統治法（マージソート、クイックソート）\n③組み合わせ問題（バックトラック）",
      "importance": 5
    },
    {
      "id": "tech-4-3-6-fc-3",
      "front": "分割統治法の3ステップは？マージソートとクイックソートの違いは？",
      "back": "【分割統治法の3ステップ】\n①分割（Divide）: 問題を小さな部分問題に分割\n②統治（Conquer）: 部分問題を再帰的に解決\n③統合（Combine）: 部分問題の解を統合して元の問題の解を得る\n\n【マージソートとクイックソートの違い】\n\nマージソート:\n  分割: 配列を2つに均等分割\n  統合: ソート済み配列をマージ（O(n)）\n  計算量: O(n log n)（常に）\n  安定性: 安定ソート\n  メモリ: 追加メモリが必要\n\nクイックソート:\n  分割: ピボットより小さい/大きい要素に分割\n  統合: 不要（分割時にソート完了）\n  計算量: 平均 O(n log n)、最悪 O(n²)\n  安定性: 不安定ソート\n  メモリ: 追加メモリ不要",
      "importance": 5
    },
    {
      "id": "tech-4-3-6-fc-4",
      "front": "マージソートで [38, 27, 43, 3] をソートする過程は？",
      "back": "【分割フェーズ】\n[38, 27, 43, 3]\n  ↓\n[38, 27]  [43, 3]\n  ↓         ↓\n[38] [27]  [43] [3]\n\n【マージフェーズ】\nステップ①: [38] と [27] をマージ\n  → 27 < 38 → [27, 38]\n\nステップ②: [43] と [3] をマージ\n  → 3 < 43 → [3, 43]\n\nステップ③: [27, 38] と [3, 43] をマージ\n  左: [27, 38]、右: [3, 43]\n  ①3 < 27 → [3]\n  ②27 < 43 → [3, 27]\n  ③38 < 43 → [3, 27, 38]\n  ④右の残り（43）を追加 → [3, 27, 38, 43]\n\n最終結果: [3, 27, 38, 43]",
      "importance": 4
    },
    {
      "id": "tech-4-3-6-fc-5",
      "front": "動的計画法とは？どのような問題に適用できる？",
      "back": "【動的計画法（Dynamic Programming, DP）】\n大きな問題を小さな部分問題に分割し、部分問題の解を記録（メモ化）して、同じ計算を繰り返さないようにする手法。\n\n【適用できる問題の2つの性質】\n①重複部分問題（Overlapping Subproblems）:\n  同じ部分問題が何度も出現する\n  例: フィボナッチ数列（fib(5) = fib(4) + fib(3)、fib(4) = fib(3) + fib(2)、fib(3) が重複）\n\n②最適部分構造（Optimal Substructure）:\n  問題の最適解が部分問題の最適解から構成される\n  例: ナップサック問題（容量 w の最適解は、容量 w-1 の最適解から構成）\n\n【代表的な例】\n①フィボナッチ数列: 再帰 O(2^n) → DP O(n)\n②ナップサック問題: O(n×W)\n③最長共通部分列（LCS）: O(n×m)\n④最短経路問題（ワーシャル-フロイド法）: O(n³)",
      "importance": 5
    },
    {
      "id": "tech-4-3-6-fc-6",
      "front": "0-1ナップサック問題の解法手順は？DPテーブルの漸化式は？",
      "back": "【問題】\n容量 W のナップサックに、価値を最大化するように品物を詰める。各品物は1つだけ（分割不可）。\n\n【解法手順】\n①DPテーブル dp[i][w] を作成\n  dp[i][w] = 品物 1～i を使って、容量 w のナップサックに詰めたときの最大価値\n\n②初期化: dp[0][w] = 0（品物0個の場合、価値は0）\n\n③DPテーブルを埋める（品物 i=1～n、容量 w=0～W）\n\n④dp[n][W] が最大価値\n\n⑤バックトラックで詰める品物を特定\n\n【漸化式】\ndp[i][w] = max(\n  dp[i-1][w],                        // 品物 i を詰めない場合\n  dp[i-1][w - weight[i]] + value[i]  // 品物 i を詰める場合（容量が足りる場合のみ）\n)\n\n【時間計算量】O(n×W)\n【空間計算量】O(n×W)",
      "importance": 5
    },
    {
      "id": "tech-4-3-6-fc-7",
      "front": "ナップサック問題で、容量10kg、品物[重さ2kg価値3, 重さ3kg価値4, 重さ5kg価値6]のとき、最適解は？",
      "back": "【DPテーブルの計算】\n品物1（重さ2kg、価値3）:\n  容量2～10kg: dp[1][2～10] = 3\n\n品物2（重さ3kg、価値4）:\n  容量3kg: max(3, 0+4) = 4\n  容量5kg: max(3, 3+4) = 7\n  容量6～10kg: dp[2][6～10] = 7\n\n品物3（重さ5kg、価値6）:\n  容量5kg: max(7, 0+6) = 7\n  容量7kg: max(7, 4+6) = 10\n  容量8kg: max(7, 4+6) = 10\n  容量10kg: max(7, 7+6) = 13\n\n【最適解】\ndp[3][10] = 13\n\n【詰める品物】\nバックトラック:\n  品物3を詰めた（重さ5kg、価値6）→ 容量5kgで品物1～2\n  品物2を詰めた（重さ3kg、価値4）→ 容量2kgで品物1\n  品物1を詰めた（重さ2kg、価値3）\n\n詰める品物: 品物1 + 品物2 + 品物3\n合計重さ: 2 + 3 + 5 = 10kg\n合計価値: 3 + 4 + 6 = 13",
      "importance": 4
    },
    {
      "id": "tech-4-3-6-fc-8",
      "front": "貪欲法とは？コイン問題での解法手順は？",
      "back": "【貪欲法（Greedy Algorithm）】\n各ステップで局所的に最適な選択をして、最終的に全体の解を得る手法。\n①その時点で最も良さそうな選択をする（局所最適）\n②一度選択したら後戻りしない\n\n【コイン問題での解法手順】\n問題: 日本の硬貨（500円、100円、50円、10円、5円、1円）で630円を支払う。使用枚数を最小化。\n\nステップ①: 最大額の硬貨（500円）から使う\n  630 ÷ 500 = 1枚（余り130円）\n  使用: 500円×1枚、残金: 130円\n\nステップ②: 100円硬貨を使う\n  130 ÷ 100 = 1枚（余り30円）\n  使用: 100円×1枚、残金: 30円\n\nステップ③: 50円硬貨を使う\n  30 ÷ 50 = 0枚（使えない）\n\nステップ④: 10円硬貨を使う\n  30 ÷ 10 = 3枚（余り0円）\n  使用: 10円×3枚、残金: 0円\n\n最終結果: 500円×1枚、100円×1枚、10円×3枚 = 合計5枚（最小）",
      "importance": 4
    },
    {
      "id": "tech-4-3-6-fc-9",
      "front": "貪欲法が最適解を得られる条件は？最適解を得られない例は？",
      "back": "【貪欲法で最適解が得られる条件】\n①貪欲選択性質（Greedy Choice Property）:\n  その時点で最良の選択をすれば、最終的に最適解が得られる\n②最適部分構造（Optimal Substructure）:\n  問題の最適解が部分問題の最適解から構成される\n\n【最適解を得られない例】\n硬貨が {1円, 6円, 10円} の場合、12円を支払う。\n\n貪欲法:\n  ①10円×1枚（余り2円）\n  ②1円×2枚（余り0円）\n  → 合計3枚\n\n最適解:\n  6円×2枚 = 12円 → 合計2枚\n\n貪欲法の解（3枚）≠ 最適解（2枚）\n\n【理由】\n硬貨が {1円, 6円, 10円} の場合、貪欲選択性質を満たさない（10円硬貨を選ぶことが局所最適だが、全体最適ではない）。\n日本の硬貨システムでは、大きい硬貨が小さい硬貨の倍数になっているため、貪欲法で最適解が得られる。",
      "importance": 5
    },
    {
      "id": "tech-4-3-6-fc-10",
      "front": "バックトラックとは？8クイーン問題での探索手順は？",
      "back": "【バックトラック（Backtracking）】\n全ての可能性を系統的に探索し、解を見つける手法。\n①候補解を順番に試す\n②制約を満たさない候補解は早期に枝刈り（探索を打ち切る）\n③解が見つからない場合は前の状態に戻る（バックトラック）\n\n【8クイーン問題での探索手順】\n問題: 8×8のチェス盤に8個のクイーンを配置。互いに攻撃し合わないように配置。\n\nステップ①: 1行目にクイーンを配置\n  1列目を試す → 配置可能 → (1,1)に配置\n\nステップ②: 2行目にクイーンを配置\n  1列目を試す → (1,1)と同じ列、NG\n  2列目を試す → (1,1)と同じ斜め線、NG\n  3列目を試す → 配置可能 → (2,3)に配置\n\nステップ③: 3行目にクイーンを配置\n  1～4列目を試す → 全てNG\n  → バックトラック（2行目に戻る）\n\nステップ④: 2行目のクイーンを別の位置に移動\n  4列目を試す → 配置可能 → (2,4)に配置\n\n... このプロセスを繰り返す ...\n\n8×8の盤には92個の解が存在。",
      "importance": 5
    },
    {
      "id": "tech-4-3-6-fc-11",
      "front": "再帰、分割統治法、動的計画法、貪欲法、バックトラックの計算量と特徴は？",
      "back": "【再帰】\n計算量: 問題による（階乗 O(n)、フィボナッチ O(2^n)）\n特徴: コードが簡潔、スタックメモリ消費\n\n【分割統治法】\n計算量: O(n log n)（マージソート、クイックソート）\n特徴: 問題を分割し、統合。並列処理に適している\n\n【動的計画法】\n計算量: O(n×W)（ナップサック問題）\n特徴: 部分問題の解をメモ化、同じ計算を繰り返さない。追加メモリが必要\n\n【貪欲法】\n計算量: O(n)（コイン問題）\n特徴: 局所最適を選択、高速。必ずしも最適解が得られるとは限らない\n\n【バックトラック】\n計算量: O(n!)（8クイーン問題）\n特徴: 全探索より効率的（枝刈り）。最悪の場合は指数時間",
      "importance": 5
    },
    {
      "id": "tech-4-3-6-fc-12",
      "front": "各アルゴリズム手法に適した問題の例は？",
      "back": "【再帰】\n①階乗、フィボナッチ数列\n②木構造の走査（ファイルシステム、DOM操作）\n③分割統治法の実装（マージソート、クイックソート）\n\n【分割統治法】\n①ソート（マージソート、クイックソート）\n②2分探索\n③FFT（高速フーリエ変換）\n\n【動的計画法】\n①ナップサック問題\n②最長共通部分列（LCS）\n③最短経路問題（ワーシャル-フロイド法）\n④フィボナッチ数列（メモ化）\n\n【貪欲法】\n①日本の硬貨システムのコイン問題\n②ハフマン符号化\n③ダイクストラ法（最短経路）\n④クラスカル法（最小全域木）\n\n【バックトラック】\n①8クイーン問題\n②数独\n③迷路探索\n④グラフの彩色問題\n⑤制約充足問題（CSP）",
      "importance": 4
    }
  ]
}
