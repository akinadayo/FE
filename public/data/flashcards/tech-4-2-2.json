{
  "topicId": "tech-4-2-2",
  "title": "プログラミング",
  "flashcards": [
    {
      "id": "tech-4-2-2-fc-1",
      "front": "低級言語と高級言語の違いは？（4つの観点）",
      "back": "低級言語（機械語、アセンブリ言語）：\n①CPUに近い（ハードウェアを直接制御）\n②実行速度が速い（機械語に変換する手間が少ない）\n③記述が難しい（人間には理解困難）\n④移植性が低い（CPUごとに命令セットが異なる）\n\n高級言語（C、Java、Python）:\n①人間に近い（英語に近い構文）\n②実行速度がやや遅い（変換に手間がかかる）\n③記述が容易（理解しやすい）\n④移植性が高い（異なるCPUでも動く）",
      "importance": 4
    },
    {
      "id": "tech-4-2-2-fc-2",
      "front": "プログラミング言語の4世代とは？",
      "back": "第1世代：機械語（0と1のビット列、CPUが直接実行）\n例：10110000 01100001\n\n第2世代：アセンブリ言語（機械語を記号で表現、MOV、ADDなど）\n例：MOV AL, 61h\n\n第3世代：高級言語（英語に近い構文、C、Java、Pythonなど）\n例：int x = 5;\n\n第4世代：4GL（さらに高レベル、SQL、Excelマクロなど）\n例：SELECT * FROM users;",
      "importance": 4
    },
    {
      "id": "tech-4-2-2-fc-3",
      "front": "コンパイラとインタプリタの違いは？（変換タイミング、実行速度、開発効率、具体例）",
      "back": "コンパイラ方式：\n変換タイミング：事前に全体を変換（コンパイル時）\n実行速度：速い（事前に機械語に変換済み）\n開発効率：やや低い（コンパイルに時間）\n具体例：C、C++、Java\n\nインタプリタ方式：\n変換タイミング：実行時に1行ずつ変換\n実行速度：遅い（毎回変換が必要）\n開発効率：高い（すぐに実行できる）\n具体例：Python、Ruby、JavaScript",
      "importance": 5
    },
    {
      "id": "tech-4-2-2-fc-4",
      "front": "ビルドプロセス4ステップ（プリプロセッサ、コンパイラ、リンカ、ローダ）の役割は？",
      "back": "①プリプロセッサ（前処理）：#include や #define を展開\n入力：main.c → 出力：main.i\n\n②コンパイラ（翻訳）：ソースコードをオブジェクトコード（機械語）に変換\n入力：main.i → 出力：main.o\n\n③リンカ（結合）：複数のオブジェクトコード+ライブラリを結合して実行可能ファイルを生成\n入力：main.o + ライブラリ → 出力：main.exe\n\n④ローダ（読み込み）：実行可能ファイルをメモリに読み込んで実行\n入力：main.exe → 出力：メモリ上のプログラム",
      "importance": 5
    },
    {
      "id": "tech-4-2-2-fc-5",
      "front": "プリプロセッサの役割は？具体例は？",
      "back": "役割：ソースコードの前処理。#include や #define を展開。\n\n具体例：\n①#include <stdio.h> → stdio.h の内容（数千行）が挿入される\n②#define PI 3.14 → ソースコード中の PI が 3.14 に置換される\n\nBefore: printf(\"円周率: %f\", PI);\nAfter: printf(\"円周率: %f\", 3.14);",
      "importance": 4
    },
    {
      "id": "tech-4-2-2-fc-6",
      "front": "リンカの役割は？なぜ必要か？",
      "back": "役割：複数のオブジェクトコードとライブラリを結合して実行可能ファイル(.exe)を生成。\n\nなぜ必要か：\n①複数のソースファイル（main.c、func.c）をそれぞれコンパイルしたオブジェクトコード（main.o、func.o）を結合\n②printf などの標準ライブラリ関数を結合\n\n例：main.o の中で使われている printf 関数を、標準ライブラリから探して結合",
      "importance": 4
    },
    {
      "id": "tech-4-2-2-fc-7",
      "front": "構造化プログラミングとは？3つの基本構造は？",
      "back": "定義：プログラムを「順次」「選択」「反復」の3つの基本構造の組み合わせで記述する手法。goto文を使わない。\n\n3つの基本構造：\n①順次（Sequence）：命令を上から順番に実行\n例：a = 5; b = 10; c = a + b;\n\n②選択（Selection）：条件によって処理を分岐（if-else、switch）\n例：if (x > 0) { ... } else { ... }\n\n③反復（Iteration）：条件を満たす間、処理を繰り返す（while、for）\n例：for (int i = 0; i < 10; i++) { ... }",
      "importance": 5
    },
    {
      "id": "tech-4-2-2-fc-8",
      "front": "構造化プログラミングの目的と利点は？",
      "back": "目的：プログラムの可読性（読みやすさ）と保守性（修正しやすさ）を向上させる\n\n利点：\n①可読性：処理の流れが上から下へ一直線で、読みやすい（goto文がないため）\n②保守性：修正が容易（どこから処理が飛んでくるか心配不要）\n③デバッグ：バグが見つけやすい\n\n対比：1960年代までは goto 文を多用したスパゲッティコード（複雑に絡み合ったコード）だった。1968年にダイクストラが構造化プログラミングを提唱。",
      "importance": 4
    },
    {
      "id": "tech-4-2-2-fc-9",
      "front": "プログラミングパラダイム4種類（手続き型、オブジェクト指向、関数型、宣言型）の違いは？",
      "back": "①手続き型：処理の手順を記述\n例：C、Pascal（順次・選択・反復の組み合わせ）\n\n②オブジェクト指向：データと処理をまとめたオブジェクトを操作\n例：Java、C++、Python（カプセル化、継承、ポリモーフィズム）\n\n③関数型：関数の組み合わせで記述\n例：Haskell、Lisp、Scala（副作用を避ける、数学的な関数）\n\n④宣言型：「何をするか」を記述（「どうやるか」は記述しない）\n例：SQL、HTML",
      "importance": 4
    },
    {
      "id": "tech-4-2-2-fc-10",
      "front": "Java の中間コード方式とは？処理フローは？",
      "back": "中間コード方式：コンパイラとインタプリタの両方の特徴を持つ方式\n\nJava の処理フロー：\n①ソースコード（.java）をコンパイラ（javac）でバイトコード（.class）に変換（中間コード）\n②JVM（Java仮想マシン）がバイトコードを1行ずつ解釈して実行（またはJITコンパイルで機械語に変換）\n\n利点：\n①移植性が高い（バイトコードはどのOSでも実行可能）\n②コンパイラ方式とインタプリタ方式の長所を両立",
      "importance": 4
    },
    {
      "id": "tech-4-2-2-fc-11",
      "front": "マルチパラダイム言語とは？Python の例は？",
      "back": "定義：複数のパラダイムをサポートするプログラミング言語。現代の主流。\n\nPython の例：\n①手続き型：for ループで処理を記述\nfor i in range(10): sum += i\n\n②オブジェクト指向：class を使ってオブジェクトを定義\nclass Calculator: ...\n\n③関数型：lambda や map、reduce を使って関数を組み合わせる\nreduce(lambda x, y: x + y, range(1, 11))\n\nプログラマは、問題に応じて最適なパラダイムを選択できる。",
      "importance": 3
    },
    {
      "id": "tech-4-2-2-fc-12",
      "front": "コンパイラ方式とインタプリタ方式の処理フローの違いは？",
      "back": "コンパイラ方式（C言語）：\n①ソースコード（main.c）を作成\n②コンパイラ（gcc）でコンパイル → main.exe（機械語）に変換\n③実行：./main.exe → 機械語を直接実行（速い）\n\nインタプリタ方式（Python）：\n①ソースコード（main.py）を作成\n②実行（コンパイル不要）：python main.py → その場で1行ずつ機械語に変換して実行（コンパイル時間不要だが、実行速度がやや遅い）\n\nまとめ：\nコンパイラ：「コンパイル→実行」の2段階\nインタプリタ：「実行」の1段階",
      "importance": 4
    }
  ]
}
